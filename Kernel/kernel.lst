
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass --long-address --intel-hex -o kernel.hex --list kernel.lst kernel.asm
; Sun Aug 19 00:16:31 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm


;******  Processing file: macros_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: directpage_inc.asm

=$0000					RESET          = $0000 ;4 Bytes Jumps to the beginning of kernel ROM. ($F8:0000).
=$0004					RETURN         = $0004 ;4 Bytes Called when the RETURN key is pressed in the immediate mode screen. This will process a command in MONITOR, execute a BASIC command, or add a BASIC program line.
=$0008					KEYDOWN        = $0008 ;4 Bytes Custom keyboard handler. This defaults to the kernel keypress handler, but you can redirect this to your own routines. Make sure to JML to the original address at the end of your custom routine. Use this to make F-Key macros or custom keyboard commands.
=$000c					KEYWP          = $000C ;2 Bytes Keyboard buffer next write position.
=$000e					KEYRP          = $000E ;2 Bytes Keyboard buffer next read position. When KEYRP = KEYWP, the buffer is empty. When KEYWP = KEYRP-1, buffer is full.
=$0010					SCREENBEGIN    = $0010 ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$0013					SCRWIDTH       = $0013 ;2 Bytes Width of screen
=$0015					SCRHEIGHT      = $0015 ;2 Bytes Height of screen
=$0017					CURSORPOS      = $0017 ;3 Bytes The next character written to the screen will be written in this location.
=$001a					CURSORX        = $001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$001c					CURSORY        = $001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$001e					CURCOLOR       = $001E ;2 Bytes Color of next character to be printed to the screen.
=$0020					CURATTR        = $0020 ;2 Bytes Attribute of next character to be printed to the screen.
=$0022					STACKBOT       = $0022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$0024					STACKTOP       = $0024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$00f0					SYSPC          = $00F0 ;2 Bytes CPU Program Counter. Stored by BRK. Stores CPU state after ML routine is finished running. These values are also loaded back into the CPU on a BASIC SYS command or MONITOR GO command.
=$00f2					CPUPBR         = $00F2 ;1 Byte  Program Bank
=$00f3					CPUPC          = $00F3 ;2 Bytes Program Counter
=$00f5					CPUFLAGS       = $00F5 ;1 Byte  Flags
=$00f6					CPUA           = $00F6 ;2 Bytes Accumulator
=$00f8					CPUX           = $00F8 ;2 Bytes X Index
=$00fa					CPUY           = $00FA ;2 Bytes Y Index
=$00fc					CPUDBR         = $00FC ;1 Byte  Data Bank
=$00fd					CPUSTACK       = $00FD ;2 Bytes Stack Pointer
=$0100					MCMDADDR       = $0100 ;3 Bytes Address of the current line of text being processed by the MONITOR command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$0103					MCMDLEN        = $0103 ;2 Bytes Length of string being read by the parser. This should be the screen width when in screen memory. Otherwise should be as long as the buffer used to hold the text to parse.
=$0105					MCMDPOS        = $0105 ;3 Bytes Next character being read by the command parser.
=$0108					MCMD           = $0108 ;3 Bytes Address of the command text. The first character is used to decide which function to execute
=$010b					MARG1          = $010B ;3 Bytes Address of the command arguments.
=$010e					MARG2          = $010E ;3 Bytes Address of the command arguments.
=$0111					MARG3          = $0111 ;3 Bytes Address of the command arguments.
=$0114					MARG4          = $0114 ;3 Bytes Address of the command arguments.
=$0117					MARG5          = $0117 ;3 Bytes Address of the command arguments.
=$011a					MARG6          = $011A ;3 Bytes Address of the command arguments.
=$011d					MARG7          = $011D ;3 Bytes Address of the command arguments.
=$100					BCMDADDR       = $100 ;3 Bytes Pointer to current BASIC line on screen
=$1000					SCREEN_PAGE0   = $1000 ;6400 Bytes First page of display RAM. This is used at boot time to display the welcome screen and the BASIC or MONITOR command screens.
=$2900					SCREEN_PAGE1   = $2900 ;6400 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$4200					SCREEN_PAGE2   = $4200 ;6400 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$5b00					SCREEN_PAGE3   = $5B00 ;6400 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$7400					USER_VARIABLES = $7400 ;0 Byte  This space is avaialble for user code and variables, up to the beginning of the stack. Make sure not to write past STACKBOT without adjusting that value.
=$009700				STACK_BEGIN    = $009700 ;16384 Bytes The default beginning of stack space
=$00d6ff				STACK_END      = $00D6FF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ffe4				VECTOR_COP     = $00FFE4 ;2 Bytes
=$00ffe6				VECTOR_BRK     = $00FFE6 ;2 Bytes
=$00ffe8				VECTOR_ABORT   = $00FFE8 ;2 Bytes
=$00ffea				VECTOR_NMI     = $00FFEA ;2 Bytes
=$00fffc				VECTOR_RESET   = $00FFFC ;2 Bytes
=$00ffee				VECTOR_IRQ     = $00FFEE ;2 Bytes
=$00fff4				VECTOR_ECOP    = $00FFF4 ;2 Bytes
=$00fff6				VECTOR_EBRK    = $00FFF6 ;2 Bytes
=$00fff8				VECTOR_EABORT  = $00FFF8 ;2 Bytes
=$00fffa				VECTOR_ENMI    = $00FFFA ;2 Bytes
=$00fffc				VECTOR_ERESET  = $00FFFC ;2 Bytes
=$00fffe				VECTOR_EIRQ    = $00FFFE ;2 Bytes

;******  Return to file: kernel.asm


;******  Processing file: monitor_inc.asm

=$f10000				MONITOR     = $F10000
=$f10004				MBREAK      = $F10004
=$f10008				MSTATUS     = $F10008
=$f1000b				MREADY      = $F1000B
=$f10010				MRETURN		= $F10010
=$f10014				MPARSE      = $F10014

;******  Return to file: kernel.asm

.f80000	5c 03 10 f8	jmp $f81003	BOOT        JML IBOOT
.f81000	4c 03 10	jmp $f81003	IRESET          JMP IBOOT
.f81003					IBOOT
.f81003	18		clc		                CLC           ; clear the carry flag
.f81004	fb		xce		                XCE           ; move carry to emulation flag.
.f81005	c2 10		rep #$10	                REP #$10
.f81007	c2 20		rep #$20	                REP #$20
.f81009	a9 00 00	lda #$0000	                LDA #$0000      ; init direct page
.f8100c	5b		tcd		                TCD
.f8100d	c2 20		rep #$20	                REP #$20
.f8100f	a9 00 10	lda #$1000	                LDA #$1000      ; store the initial screen buffer location
.f81012	85 10		sta $10		                STA SCREENBEGIN
.f81014	e2 20		sep #$20	                SEP #$20
.f81016	a9 00		lda #$00	                LDA #$00
.f81018	85 12		sta $12		                STA SCREENBEGIN+2
.f8101a	c2 20		rep #$20	                REP #$20
.f8101c	a9 00 10	lda #$1000	                LDA #$1000      ; store the initial cursor position
.f8101f	85 17		sta $17		                STA CURSORPOS
.f81021	e2 20		sep #$20	                SEP #$20
.f81023	a9 00		lda #$00	                LDA #$00
.f81025	85 19		sta $19		                STA CURSORPOS+2
.f81027	e2 20		sep #$20	                SEP #$20
.f81029	a9 50		lda #$50	                LDA #80         ; Set screen dimensions
.f8102b	85 13		sta $13		                STA SCRWIDTH
.f8102d	a9 19		lda #$19	                LDA #25
.f8102f	85 15		sta $15		                STA SCRHEIGHT
.f81031					greet
.f81031	48		pha		                PHA
.f81032	08		php		                PHP
.f81033	e2 20		sep #$20	                SEP #$20
.f81035	a9 f8		lda #$f8			LDA #$F8
.f81037	48		pha		                PHA
.f81038	ab		plb		                PLB
.f81039	28		plp		                PLP
.f8103a	68		pla		                PLA
.f8103b	a2 f8 10	ldx #$10f8	                LDX #<>greet_msg
.f8103e	a0 50 00	ldy #$0050			LDY #80
.f81041	22 62 10 f8	jsl $f81062	                JSL IPUTS       ; print the string
.f81045	a2 19 11	ldx #$1119	                LDX #<>greet_msg1
.f81048	a0 50 00	ldy #$0050			LDY #80
.f8104b	22 62 10 f8	jsl $f81062	                JSL IPUTS       ; print the string
.f8104f	a2 3f 11	ldx #$113f	                LDX #<>greet_msg2
.f81052	a0 50 00	ldy #$0050			LDY #80
.f81055	22 62 10 f8	jsl $f81062	                JSL IPUTS       ; print the string
.f81059	e2 20		sep #$20	                SEP #$20
.f8105b	a9 01		lda #$01	                LDA #$01        ;set data bank to 1 (Kernel Variables)
.f8105d	48		pha		                PHA
.f8105e	ab		plb		                PLB
.f8105f	db		stp		greet_done      STP             ;halt the CPU
.f81060	00		brk #		IKEYDOWN        BRK             ; Keyboard key pressed
.f81061	00		brk #		IRETURN         BRK
.f81062	48		pha		IPUTS           PHA
.f81063	08		php		                PHP
.f81064	e2 20		sep #$20	                SEP #$20
.f81066	c2 10		rep #$10	                REP #$10
.f81068	bd 00 00	lda $f80000,x	iputs1          LDA $0,b,x ; read from the string
.f8106b	f0 15		beq $f81082	                BEQ iputs_done
.f8106d	c9 0d		cmp #$0d			CMP #$0D   ; handle CR
.f8106f	d0 06		bne $f81077			BNE iputs2
.f81071	22 9c 10 f8	jsl $f8109c			JSL IPRINTCR
.f81075	80 04		bra $f8107b			BRA iputs3
.f81077	22 85 10 f8	jsl $f81085	iputs2          JSL IPUTC
.f8107b	e8		inx		iputs3          INX
.f8107c	88		dey		                DEY
.f8107d	f0 03		beq $f81082	                BEQ iputs_done
.f8107f	4c 68 10	jmp $f81068	                jmp iputs1
.f81082	28		plp		iputs_done      PLP
.f81083	68		pla		                PLA
.f81084	6b		rtl		                RTL
.f81085	0b		phd		IPUTC           PHD
.f81086	08		php				PHP             ; stash the flags (we'll be changing M)
.f81087	48		pha		                PHA
.f81088	08		php				PHP
.f81089	c2 20		rep #$20	                REP #$20
.f8108b	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.f8108e	5b		tcd		                TCD             ; and get character back
.f8108f	28		plp				PLP
.f81090	68		pla		                PLA
.f81091	e2 20		sep #$20	                SEP #$20
.f81093	87 17		sta [$17]	                STA [CURSORPOS] ; Save the character on the screen
.f81095	22 ad 10 f8	jsl $f810ad	                JSL ICSRRIGHT
.f81099	28		plp		                PLP
.f8109a	2b		pld		                PLD
.f8109b	6b		rtl		                RTL
.f8109c	da		phx		IPRINTCR	PHX
.f8109d	5a		phy				PHY
.f8109e	08		php				PHP
.f8109f	a2 00 00	ldx #$0000			LDX #0
.f810a2	a4 1c		ldy $1c				LDY CURSORY
.f810a4	c8		iny				INY
.f810a5	22 da 10 f8	jsl $f810da			JSL ILOCATE
.f810a9	28		plp				PLP
.f810aa	7a		ply				PLY
.f810ab	fa		plx				PLX
.f810ac	6b		rtl				RTL
.f810ad					ICSRRIGHT
.f810ad	da		phx		                PHX
.f810ae	8b		phb		                PHB
.f810af	c2 20		rep #$20	                REP #$20
.f810b1	c2 10		rep #$10	                REP #$10
.f810b3	48		pha		                PHA
.f810b4	08		php				PHP
.f810b5	c2 20		rep #$20	                REP #$20
.f810b7	a9 00 00	lda #$0000	                LDA #$0         ; set DP to page 0
.f810ba	5b		tcd		                TCD             ; and get character back
.f810bb	28		plp				PLP
.f810bc	68		pla		                PLA
.f810bd	e6 17		inc $17		                INC CURSORPOS
.f810bf	a6 1a		ldx $1a		                LDX CURSORX
.f810c1	e8		inx		                INX
.f810c2	e4 13		cpx $13		                CPX SCRWIDTH
.f810c4	90 0c		bcc $f810d2	                BCC icsr_nowrap  ; wrap if the cursor is at or past column 80
.f810c6	a2 00 00	ldx #$0000	                LDX #0
.f810c9	5a		phy		                PHY
.f810ca	a4 1c		ldy $1c		                LDY CURSORY
.f810cc	c8		iny		                INY
.f810cd	22 da 10 f8	jsl $f810da	                JSL ILOCATE
.f810d1	7a		ply		                PLY
.f810d2	86 1a		stx $1a		icsr_nowrap     STX CURSORX
.f810d4	ab		plb		                PLB
.f810d5	fa		plx		                PLX
.f810d6	6b		rtl		                RTL
.f810d7	6b		rtl		ISRLEFT		RTL
.f810d8	6b		rtl		ICSRUP		RTL
.f810d9	6b		rtl		ICSRDOWN	RTL
.f810da	48		pha		ILOCATE         PHA
.f810db	08		php		                PHP
.f810dc	c2 20		rep #$20	                REP #$20
.f810de	c2 10		rep #$10	                REP #$10
.f810e0	86 1a		stx $1a				STX CURSORX
.f810e2	84 1c		sty $1c				STY CURSORY
.f810e4	a5 10		lda $10		                LDA SCREENBEGIN
.f810e6	18		clc		ilocate_down    CLC
.f810e7	65 13		adc $13		                ADC SCRWIDTH
.f810e9	88		dey		                DEY
.f810ea	f0 03		beq $f810ef			BEQ ilocate_right
.f810ec	4c e6 10	jmp $f810e6	                JMP ilocate_down
.f810ef	65 1a		adc $1a		ilocate_right   ADC CURSORX             ; move the cursor right X columns
.f810f1	85 17		sta $17		                STA CURSORPOS
.f810f3	a4 1c		ldy $1c				LDY CURSORY
.f810f5	28		plp		ilocate_done    PLP
.f810f6	68		pla		                PLA
.f810f7	6b		rtl		                RTL
>f810f8	20 20 2f 2f 2f 2f 2f 20		greet_msg       .text "  ///// NU64 DEVELOPMENT SYSTEM",$0d,$00
>f81100	4e 55 36 34 20 44 45 56 45 4c 4f 50 4d 45 4e 54
>f81110	20 53 59 53 54 45 4d 0d 00
>f81119	20 2f 2f 2f 2f 2f 20 20		greet_msg1      .text " /////  NU64 BASIC (Not Implemented)",$0d,$00
>f81121	4e 55 36 34 20 42 41 53 49 43 20 28 4e 6f 74 20
>f81131	49 6d 70 6c 65 6d 65 6e 74 65 64 29 0d 00
>f8113f	2f 2f 2f 2f 2f 20 20 20		greet_msg2      .text "/////   Machine Monitor v0.1 (dev)",$0d,$00
>f81147	4d 61 63 68 69 6e 65 20 4d 6f 6e 69 74 6f 72 20
>f81157	76 30 2e 31 20 28 64 65 76 29 0d 00

;******  End of listing
