
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass --long-address --intel-hex -o kernel.hex --list kernel.lst kernel.asm
; Wed Oct 17 22:09:14 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm


;******  Processing file: macros_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: simulator_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: bank_00_inc.asm

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				CPU_REGISTERS    = $000000 ; Byte
=$000000				CPUPC            = $000000 ;2 Bytes Program Counter (PC)
=$000002				CPUPBR           = $000002 ;1 Byte  Program Bank Register (K)
=$000003				CPUA             = $000003 ;2 Bytes Accumulator (A)
=$000005				CPUX             = $000005 ;2 Bytes X Register (X)
=$000007				CPUY             = $000007 ;2 Bytes Y Register (Y)
=$000009				CPUSTACK         = $000009 ;2 Bytes Stack Pointer (S)
=$00000b				CPUDP            = $00000B ;2 Bytes Direct Page Register (D)
=$00000d				CPUDBR           = $00000D ;1 Byte  Data Bank Register (B)
=$00000e				CPUFLAGS         = $00000E ;1 Byte  Flags (P)
=$000010				SCREENBEGIN      = $000010 ;2 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what VICKY is displaying, especiall if you are using mirror mode.
=$000012				SCREENBANK       = $000012 ;1 Byte  Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what VICKY is displaying, especiall if you are using mirror mode.
=$000013				COLS_VISIBLE     = $000013 ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000015				COLS_PER_LINE    = $000015 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000017				LINES_VISIBLE    = $000017 ;2 Bytes The number of rows visible on the screen. Default=25
=$000019				LINES_MAX        = $000019 ;2 Bytes The number of rows in memory for the screen. Default=64
=$00001b				CURSORPOS        = $00001B ;2 Bytes The next character written to the screen will be written in this location.
=$00001d				CURSORPOS_B      = $00001D ;1 Byte  The next character written to the screen will be written in this location.
=$00001e				MIRROR_MODE      = $00001E ;1 Byte  1=Mirror Mode enabled. Reserve 32K (somewhere) in SRAM for a display mirror. 0=Disable Mirror Mode and write directly to VICKY.
=$00001f				CURSOR_X         = $00001F ;2 Bytes Address of the beginning of the current text row
=$000021				CURSOR_Y         = $000021 ;2 Bytes 1=Mirror Mode enabled. Reserve 32K (somewhere) in SRAM for a display mirror. 0=Disable Mirror Mode and write directly to VICKY.
=$000023				CURCOLOR         = $000023 ;2 Bytes Color of next character to be printed to the screen.
=$000025				CURATTR          = $000025 ;2 Bytes Attribute of next character to be printed to the screen.
=$000027				STACKBOT         = $000027 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000029				STACKTOP         = $000029 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$00002b				READPOS          = $00002B ;2 Bytes Location of input buffer for parsing text
=$00002d				READPOS_B        = $00002D ;1 Byte  Location of input buffer for parsing text
=$00002e				READEND          = $00002E ;2 Bytes End of the input buffer
=$000030				READEND_B        = $000030 ;1 Byte  End of the input buffer
=$000031				WRITEPOS         = $000031 ;2 Bytes Address to write parsed data
=$000033				WRITEPOS_B       = $000033 ;1 Byte  Address to write parsed data
=$0000c0				KERNEL_TEMP      = $0000C0 ;32 Bytes Temp space for kernel
=$0000e0				USER_TEMP        = $0000E0 ;32 Bytes Temp space for user programs
=$000100				Page0_Check      = $000100 ; Byte  Expected $0000100
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Unsigned divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 0 Divisor ex B in A/B
=$000114				D0_RESULT        = $000114 ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Signed divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 1 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				GAVIN_MISC       = $000120 ;224 Bytes GAVIN vector controller (TBD)
=$0001ff				VECTOR_STATE     = $0001FF ;1 Byte  Interrupt Vector State. See VECTOR_STATE_ENUM
=$000200				KEY_BUFFER       = $000200 ;64 Bytes keyboard buffer
=$40					KEY_BUFFER_SIZE  = $40 ;64 Bytes (constant) keyboard buffer length
=$000240				KEY_BUFFER_END   = $000240 ;2 Bytes Last byte of keyboard buffer
=$000242				KEY_BUFFER_RPOS  = $000242 ;2 Bytes keyboard buffer read position
=$000244				KEY_BUFFER_WPOS  = $000244 ;2 Bytes keyboard buffer write position
=$001000				TEST_BEGIN       = $001000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ff00				ISR_BEGIN        = $00FF00 ; Byte  Beginning of CPU vectors in Direct page
=$00ff00				HRESET           = $00FF00 ;16 Bytes Handle RESET asserted. Reboot computer and re-initialize the kernel.
=$00ff10				HCOP             = $00FF10 ;16 Bytes Handle the COP instruction. Program use; not used by OS
=$00ff20				HBRK             = $00FF20 ;16 Bytes Handle the BRK instruction. Returns to BASIC Ready prompt.
=$00ff30				HABORT           = $00FF30 ;16 Bytes Handle ABORT asserted. Return to Ready prompt with an error message.
=$00ff40				HNMI             = $00FF40 ;32 Bytes Handle NMI
=$00ff60				HIRQ             = $00FF60 ;32 Bytes Handle IRQ
=$00ff80				Unused_FF80      = $00FF80 ;End of direct page Interrrupt handlers
=$00ffe0				VECTORS_BEGIN    = $00FFE0 ;0 Byte  Interrupt vectors
=$00ffe0				JMP_READY        = $00FFE0 ;4 Bytes Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$00ffe4				VECTOR_COP       = $00FFE4 ;2 Bytes Native COP Interrupt vector
=$00ffe6				VECTOR_BRK       = $00FFE6 ;2 Bytes Native BRK Interrupt vector
=$00ffe8				VECTOR_ABORT     = $00FFE8 ;2 Bytes Native ABORT Interrupt vector
=$00ffea				VECTOR_NMI       = $00FFEA ;2 Bytes Native NMI Interrupt vector
=$00ffec				VECTOR_RESET     = $00FFEC ;2 Bytes Unused (Native RESET vector)
=$00ffee				VECTOR_IRQ       = $00FFEE ;2 Bytes Native IRQ Vector
=$00fff0				RETURN           = $00FFF0 ;4 Bytes RETURN key handler. Points to BASIC or MONITOR subroutine to execute when RETURN is pressed.
=$00fff4				VECTOR_ECOP      = $00FFF4 ;2 Bytes Emulation mode interrupt handler
=$00fff6				VECTOR_EBRK      = $00FFF6 ;2 Bytes Emulation mode interrupt handler
=$00fff8				VECTOR_EABORT    = $00FFF8 ;2 Bytes Emulation mode interrupt handler
=$00fffa				VECTOR_ENMI      = $00FFFA ;2 Bytes Emulation mode interrupt handler
=$00fffc				VECTOR_ERESET    = $00FFFC ;2 Bytes Emulation mode interrupt handler
=$00fffe				VECTOR_EIRQ      = $00FFFE ;2 Bytes Emulation mode interrupt handler
=$010000				VECTORS_CHECK    = $010000 ;*End of vector space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: kernel.asm


;******  Processing file: bank_00_data.asm

>0001	00 00				                .word      0                ; CPUPC, 000000, 2 B, Program Counter (PC)
>0003	00				                .byte      0                ; CPUPBR, 000002, 1 B, Program Bank Register (K)
>0004	00 00				                .word      0                ; CPUA, 000003, 2 B, Accumulator (A)
>0006	00 00				                .word      0                ; CPUX, 000005, 2 B, X Register (X)
>0008	00 00				                .word      0                ; CPUY, 000007, 2 B, Y Register (Y)
>000a	00 00				                .word      0                ; CPUSTACK, 000009, 2 B, Stack Pointer (S)
>000c	00 00				                .word      0                ; CPUDP, 00000B, 2 B, Direct Page Register (D)
>000e	00				                .byte      0                ; CPUDBR, 00000D, 1 B, Data Bank Register (B)
>000f	00				                .byte      0                ; CPUFLAGS, 00000E, 1 B, Flags (P)
>0010	00 80 02			                .long      TEXT_PAGE0       ; SCREENBEGIN, 000010, 3 B, Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what VICKY is displaying, especiall if you are using mirror mode.
>0013	50 00				                .word      80               ; COLS_VISIBLE, 000013, 2 B, Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
>0015	80 00				                .word      128              ; COLS_PER_LINE, 000015, 2 B, Columns in memory per screen line. A virtual line can be this long. Default=128
>0017	3c 00				                .word      60               ; LINES_VISIBLE, 000017, 2 B, The number of rows visible on the screen. Default=25
>0019	40 00				                .word      64               ; LINES_MAX, 000019, 2 B, The number of rows in memory for the screen. Default=64
>001b	00 80 02			                .long      TEXT_PAGE0       ; CURSORPOS, 00001B, 3 B, The next character written to the screen will be written in this location.
>001e	00 80 02			                .long      TEXT_PAGE0       ; CURSORROW, 00001E, 3 B, Address of the beginning of the current text row
>0021	01				                .byte      1                ; MIRROR_MODE, 000021, 1 B, 1=Mirror Mode enabled. Reserve 32K (somewhere) in SRAM for a display mirror. 0=Disable Mirror Mode and write directly to VICKY.
>0022	00 00				                .word      0                ; CURSOR_X, 000022, 2 B, Address of the beginning of the current text row
>0024	00 00				                .word      0                ; CURSOR_Y, 000024, 2 B, 1=Mirror Mode enabled. Reserve 32K (somewhere) in SRAM for a display mirror. 0=Disable Mirror Mode and write directly to VICKY.
>0026	0f 00				                .word      $0F              ; CURCOLOR, 000026, 2 B, Color of next character to be printed to the screen.
>0028	00 00				                .word      $00              ; CURATTR, 000028, 2 B, Attribute of next character to be printed to the screen.
>002a	ff fe				                .word      STACK_END        ; STACKBOT, 00002A, 2 B, Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
>002c	00 80				                .word      STACK_BEGIN      ; STACKTOP, 00002C, 2 B, Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
>002e	00 00 00 00 00 00 00 00		                .fill 32,  0                ; KERNEL_TEMP, 0000C0, 32 B, Temp space for kernel
>0036	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>0046	00 00 00 00 00 00 00 00
>004e	00 00 00 00 00 00 00 00		                .fill 32,  0                ; USER_TEMP, 0000E0, 32 B, Temp space for user programs
>0056	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>0066	00 00 00 00 00 00 00 00

;******  Return to file: kernel.asm


;******  Processing file: bank_00_code.asm

.ff00	18		clc		RHRESET         CLC
.ff01	fb		xce		                XCE
.ff02	5c 00 00 01	jmp $010000	                JML BOOT
.ff10					RHCOP
.ff10	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff12	8b		phb		                PHB
.ff13	0b		phd		                PHD
.ff14	48		pha		                PHA
.ff15	da		phx		                PHX
.ff16	5a		phy		                PHY
.ff17	5c 08 00 01	jmp $010008	                JML BREAK
.ff20					RHBRK
.ff20	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff22	8b		phb		                PHB
.ff23	0b		phd		                PHD
.ff24	48		pha		                PHA
.ff25	da		phx		                PHX
.ff26	5a		phy		                PHY
.ff27	5c 08 00 01	jmp $010008	                JML BREAK
.ff30					RHABORT
.ff30	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff32	8b		phb		                PHB
.ff33	0b		phd		                PHD
.ff34	48		pha		                PHA
.ff35	da		phx		                PHX
.ff36	5a		phy		                PHY
.ff37	5c 08 00 01	jmp $010008	                JML BREAK
.ff40					 RHNMI
.ff40	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff42	8b		phb		                PHB
.ff43	0b		phd		                PHD
.ff44	48		pha		                PHA
.ff45	da		phx		                PHX
.ff46	5a		phy		                PHY
.ff47	7a		ply		                PLY
.ff48	fa		plx		                PLX
.ff49	68		pla		                PLA
.ff4a	2b		pld		                PLD
.ff4b	ab		plb		                PLB
.ff4c	40		rti		                RTI
.ff60					RHIRQ
.ff60	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff62	8b		phb		                PHB
.ff63	0b		phd		                PHD
.ff64	48		pha		                PHA
.ff65	da		phx		                PHX
.ff66	5a		phy		                PHY
.ff67	7a		ply		                PLY
.ff68	fa		plx		                PLX
.ff69	68		pla		                PLA
.ff6a	2b		pld		                PLD
.ff6b	ab		plb		                PLB
.ff6c	40		rti		                RTI
.ffe0	5c 66 80 01	jmp $018066	JUMP_READY      JML IMREADY     ; Kernel READY routine. Rewrite this address to jump to a custom kernel.
>ffe4	10 ff				RVECTOR_COP     .word HCOP     ; FFE4
>ffe6	20 ff				RVECTOR_BRK     .word HBRK     ; FFE6
>ffe8	30 ff				RVECTOR_ABORT   .word HABORT   ; FFE8
>ffea	40 ff				RVECTOR_NMI     .word HNMI     ; FFEA
>ffec	00 00				                .word $0000    ; FFEC
>ffee	60 ff				RVECTOR_IRQ     .word HIRQ     ; FFEE
.fff0	5c db 04 01	jmp $0104db	RRETURN         JML IRETURN
>fff4	10 ff				RVECTOR_ECOP    .word HCOP     ; FFF4
>fff6	20 ff				RVECTOR_EBRK    .word HBRK     ; FFF6
>fff8	30 ff				RVECTOR_EABORT  .word HABORT   ; FFF8
>fffa	40 ff				RVECTOR_ENMI    .word HNMI     ; FFFA
>fffc	00 ff				RVECTOR_ERESET  .word HRESET   ; FFFC
>fffe	60 ff				RVECTOR_EIRQ    .word HIRQ     ; FFFE

;******  Return to file: kernel.asm


;******  Processing file: bank_02_inc.asm

=$020000				BANK2_BEGIN      = $020000 ;Start of Bank 2 (Buffers and VRAM)
=$020000				MONITOR_VARS     = $020000 ;MONITOR Variables. BASIC variables may overlap this space
=$020000				MCMDADDR         = $020000 ;2 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$020002				MCMDADDR_B       = $020002 ;1 Byte  Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$020003				MCMP_TEXT        = $020003 ;2 Bytes Address of symbol being evaluated for COMPARE routine
=$020005				MCMP_TEXT_B      = $020005 ;1 Byte  Address of symbol being evaluated for COMPARE routine
=$020006				MCMP_LEN         = $020006 ;2 Bytes Length of symbol being evaluated for COMPARE routine
=$020008				MCMD             = $020008 ;4 Bytes Command. Can be 32-bit number, 24-bit address, 24+8 address+len, or 4 text characters.
=$02000c				MARG0            = $02000C ;4 Bytes Argument. Can be 32-bit number, 24-bit address, 24+8 address+len, or 4 text characters.
=$020010				MARG1            = $020010 ;4 Bytes Argument. Can be 32-bit number, 24-bit address, 24+8 address+len, or 4 text characters.
=$020014				MARG2            = $020014 ;4 Bytes Argument. Can be 32-bit number, 24-bit address, 24+8 address+len, or 4 text characters.
=$020018				MARG3            = $020018 ;4 Bytes Argument. Can be 32-bit number, 24-bit address, 24+8 address+len, or 4 text characters.
=$02001c				MARG4            = $02001C ;4 Bytes Argument. Can be 32-bit number, 24-bit address, 24+8 address+len, or 4 text characters.
=$020020				MARG5            = $020020 ;4 Bytes Argument. Can be 32-bit number, 24-bit address, 24+8 address+len, or 4 text characters.
=$020024				MARG6            = $020024 ;4 Bytes Argument. Can be 32-bit number, 24-bit address, 24+8 address+len, or 4 text characters.
=$020028				MARG7            = $020028 ;4 Bytes Argument. Can be 32-bit number, 24-bit address, 24+8 address+len, or 4 text characters.
=$020100				LOADFILE_VARS    = $020100 ;
=$020100				LOADFILE_NAME    = $020100 ;2 Bytes (addr) Name of file to load. Address in Data Page
=$020102				LOADFILE_NAME_B  = $020102 ;1 Byte  (addr) Name of file to load. Address in Data Page
=$020103				LOADFILE_LEN     = $020103 ;1 Byte  Length of filename. 0=Null Terminated
=$020104				LOADPBR          = $020104 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$020105				LOADPC           = $020105 ;2 Bytes Start address of loaded file ($05 segment)
=$020107				LOADDBR          = $020107 ;1 Byte  First data bank of loaded file ($06 segment)
=$020108				LOADADDR         = $020108 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$02010a				LOADFILE_TYPE    = $02010A ;2 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$02010c				LOADFILE_TYPE_B  = $02010C ;1 Byte  (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$02010d				BLOCK_LEN        = $02010D ;2 Bytes Length of block being loaded
=$02010f				BLOCK_ADDR       = $02010F ;2 Bytes (temp) Address of block being loaded
=$020111				BLOCK_BANK       = $020111 ;1 Byte  (temp) Bank of block being loaded
=$020112				BLOCK_COUNT      = $020112 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$2000					TEXT_PAGE_SIZE   = $2000 ;Constant: Number of bytes in one page of video RAM
=$028000				TEXT_PAGE0       = $028000 ;8192 Bytes Video RAM Character data
=$02a000				TEXT_PAGE1       = $02A000 ;8192 Bytes Video RAM Color Data
=$02c000				TEXT_PAGE2       = $02C000 ;8192 Bytes Video RAM Attribute data
=$02e000				TEXT_PAGE3       = $02E000 ;8192 Bytes Video RAM Additional data

;******  Return to file: kernel.asm


;******  Processing file: bank_7f_inc.asm

=$7fd800				IO_BEGIN             = $7FD800 ; Byte  Beginning of IO space
=$7f0000				MASTER_CTRL_REG_L    = $7F0000 ;1 Byte
=$7f0001				MASTER_CTRL_REG_H    = $7F0001 ;1 Byte
=$7f0008				TXT_CTRL_REG         = $7F0008 ;2 Bytes
=$7f0008				TXT_CTRL_REG_L       = $7F0008 ;1 Byte
=$7f0009				TXT_CTRL_REG_H       = $7F0009 ;1 Byte
=$7f000a				TXT_CURSOR_CTRL      = $7F000A ;1 Byte
=$01					TXT_CURSOR_ENABLE    = $01 ; Byte  Bit 0: Flash Enabled
=$00					TXT_CURSOR_FLASH_0   = $00 ; Byte  Bits 1-2: Cursor Flash: 0-Transparent
=$02					TXT_CURSOR_FLASH_1   = $02 ; Byte  Bits 1-2: Cursor Flash: 1-Full On
=$04					TXT_CURSOR_FLASH_2   = $04 ; Byte  Bits 1-2: Cursor Flash: 2-1Hz
=$06					TXT_CURSOR_FLASH_3   = $06 ; Byte  Bits 1-2: Cursor Flash: 3-2Hz
=$7f000b				TXT_CURSOR_COLOR     = $7F000B ;1 Byte
=$7f000c				TXT_CURSOR_X_REG_L   = $7F000C ;1 Byte
=$7f000d				TXT_CURSOR_X_REG_H   = $7F000D ;1 Byte
=$7f000e				TXT_CURSOR_Y_REG_L   = $7F000E ;1 Byte
=$7f000f				TXT_CURSOR_Y_REG_H   = $7F000F ;1 Byte
=$7f1100				PME_STS_REG          = $7F1100 ;1 Byte
=$7f1102				PME_EN_REG           = $7F1102 ;1 Byte
=$7f1104				PME_STS1_REG         = $7F1104 ;1 Byte
=$7f1105				PME_STS2_REG         = $7F1105 ;1 Byte
=$7f1106				PME_STS3_REG         = $7F1106 ;1 Byte
=$7f1107				PME_STS4_REG         = $7F1107 ;1 Byte
=$7f1108				PME_STS5_REG         = $7F1108 ;1 Byte
=$7f110a				PME_EN1_REG          = $7F110A ;1 Byte
=$7f110b				PME_EN2_REG          = $7F110B ;1 Byte
=$7f110c				PME_EN3_REG          = $7F110C ;1 Byte
=$7f110d				PME_EN4_REG          = $7F110D ;1 Byte
=$7f110e				PME_EN5_REG          = $7F110E ;1 Byte
=$7f1110				SMI_STS1_REG         = $7F1110 ;1 Byte
=$7f1111				SMI_STS2_REG         = $7F1111 ;1 Byte
=$7f1112				SMI_STS3_REG         = $7F1112 ;1 Byte
=$7f1113				SMI_STS4_REG         = $7F1113 ;1 Byte
=$7f1114				SMI_STS5_REG         = $7F1114 ;1 Byte
=$7f1116				SMI_EN1_REG          = $7F1116 ;1 Byte
=$7f1117				SMI_EN2_REG          = $7F1117 ;1 Byte
=$7f1118				SMI_EN3_REG          = $7F1118 ;1 Byte
=$7f1119				SMI_EN4_REG          = $7F1119 ;1 Byte
=$7f111a				SMI_EN5_REG          = $7F111A ;1 Byte
=$7f111c				MSC_ST_REG           = $7F111C ;1 Byte
=$7f111e				FORCE_DISK_CHANGE    = $7F111E ;1 Byte
=$7f111f				FLOPPY_DATA_RATE     = $7F111F ;1 Byte
=$7f1120				UART1_FIFO_CTRL_SHDW = $7F1120 ;1 Byte
=$7f1121				UART2_FIFO_CTRL_SHDW = $7F1121 ;1 Byte
=$7f1122				DEV_DISABLE_REG      = $7F1122 ;1 Byte
=$7f1123				GP10_REG             = $7F1123 ;1 Byte
=$7f1124				GP11_REG             = $7F1124 ;1 Byte
=$7f1125				GP12_REG             = $7F1125 ;1 Byte
=$7f1126				GP13_REG             = $7F1126 ;1 Byte
=$7f1127				GP14_REG             = $7F1127 ;1 Byte
=$7f1128				GP15_REG             = $7F1128 ;1 Byte
=$7f1129				GP16_REG             = $7F1129 ;1 Byte
=$7f112a				GP17_REG             = $7F112A ;1 Byte
=$7f112b				GP20_REG             = $7F112B ;1 Byte
=$7f112c				GP21_REG             = $7F112C ;1 Byte
=$7f112d				GP22_REG             = $7F112D ;1 Byte
=$7f112f				GP24_REG             = $7F112F ;1 Byte
=$7f1130				GP25_REG             = $7F1130 ;1 Byte
=$7f1131				GP26_REG             = $7F1131 ;1 Byte
=$7f1132				GP27_REG             = $7F1132 ;1 Byte
=$7f1133				GP30_REG             = $7F1133 ;1 Byte
=$7f1134				GP31_REG             = $7F1134 ;1 Byte
=$7f1135				GP32_REG             = $7F1135 ;1 Byte
=$7f1136				GP33_REG             = $7F1136 ;1 Byte
=$7f1137				GP34_REG             = $7F1137 ;1 Byte
=$7f1138				GP35_REG             = $7F1138 ;1 Byte
=$7f1139				GP36_REG             = $7F1139 ;1 Byte
=$7f113a				GP37_REG             = $7F113A ;1 Byte
=$7f113b				GP40_REG             = $7F113B ;1 Byte
=$7f113c				GP41_REG             = $7F113C ;1 Byte
=$7f113d				GP42_REG             = $7F113D ;1 Byte
=$7f113e				GP43_REG             = $7F113E ;1 Byte
=$7f113f				GP50_REG             = $7F113F ;1 Byte
=$7f1140				GP51_REG             = $7F1140 ;1 Byte
=$7f1141				GP52_REG             = $7F1141 ;1 Byte
=$7f1142				GP53_REG             = $7F1142 ;1 Byte
=$7f1143				GP54_REG             = $7F1143 ;1 Byte
=$7f1144				GP55_REG             = $7F1144 ;1 Byte
=$7f1145				GP56_REG             = $7F1145 ;1 Byte
=$7f1146				GP57_REG             = $7F1146 ;1 Byte
=$7f1147				GP60_REG             = $7F1147 ;1 Byte
=$7f1148				GP61_REG             = $7F1148 ;1 Byte
=$7f114b				GP1_REG              = $7F114B ;1 Byte
=$7f114c				GP2_REG              = $7F114C ;1 Byte
=$7f114d				GP3_REG              = $7F114D ;1 Byte
=$7f114e				GP4_REG              = $7F114E ;1 Byte
=$7f114f				GP5_REG              = $7F114F ;1 Byte
=$7f1150				GP6_REG              = $7F1150 ;1 Byte
=$7f1156				FAN1_REG             = $7F1156 ;1 Byte
=$7f1157				FAN2_REG             = $7F1157 ;1 Byte
=$7f1158				FAN_CTRL_REG         = $7F1158 ;1 Byte
=$7f1159				FAN1_TACH_REG        = $7F1159 ;1 Byte
=$7f115a				FAN2_TACH_REG        = $7F115A ;1 Byte
=$7f115b				FAN1_PRELOAD_REG     = $7F115B ;1 Byte
=$7f115c				FAN2_PRELOAD_REG     = $7F115C ;1 Byte
=$7f115d				LED1_REG             = $7F115D ;1 Byte
=$7f115e				LED2_REG             = $7F115E ;1 Byte
=$7f115f				KEYBOARD_SCAN_CODE   = $7F115F ;1 Byte
=$7f1f40				FG_CHAR_LUT_PTR      = $7F1F40 ;64 Bytes
=$7f1f80				BG_CHAR_LUT_PTR      = $7F1F80 ;64 Bytes
=$7f2000				GRPH_LUT0_PTR        = $7F2000 ;1024 Bytes
=$7f2400				GRPH_LUT1_PTR        = $7F2400 ;1024 Bytes
=$7f2800				GRPH_LUT2_PTR        = $7F2800 ;1024 Bytes
=$7f2c00				GRPH_LUT3_PTR        = $7F2C00 ;1024 Bytes
=$7f3000				GRPH_LUT4_PTR        = $7F3000 ;1024 Bytes
=$7f3400				GRPH_LUT5_PTR        = $7F3400 ;1024 Bytes
=$7f3800				GRPH_LUT6_PTR        = $7F3800 ;1024 Bytes
=$7f3c00				GAMMA_LUT_PTR        = $7F3C00 ;1024 Bytes
=$7fd800				IO_GAVIN             = $7FD800 ;1024 Bytes GAVIN I/O space
=$7fdc00				IO_SUPERIO           = $7FDC00 ;1024 Bytes SuperIO I/O space
=$7fe000				IO_VICKY             = $7FE000 ;1024 Bytes VICKY I/O space
=$7fe400				IO_BEATRIX           = $7FE400 ;1024 Bytes BEATRIX I/O space
=$7fe800				IO_RTC               = $7FE800 ;1024 Bytes RTC I/O space
=$7fec00				IO_CIA               = $7FEC00 ;4864 Bytes CIA I/O space
=$7fffff				IO_END               = $7FFFFF ; Byte  *End of I/O space

;******  Return to file: kernel.asm


;******  Processing file: dram_inc.asm

=$800000				SCREEN_PAGE0     = $800000 ;8192 Bytes First page of display RAM. This is used at boot time to display the welcome screen and the BASIC or MONITOR command screens.
=$802000				SCREEN_PAGE1     = $802000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$804000				SCREEN_PAGE2     = $804000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$806000				SCREEN_PAGE3     = $806000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$808000				SCREEN_END       = $808000 ;End of display memory

;******  Return to file: kernel.asm


;******  Processing file: keyboard_def.asm

=$7f1064				STATUS_PORT 	        =	$7F1064
=$7f1060				KBD_OUT_BUF 	        =	$7F1060
=$7f1060				KBD_INPT_BUF	        = 	$7F1060
=$7f1064				KBD_CMD_BUF		= 	$7F1064
=$7f1060				KBD_DATA_BUF	        = 	$7F1060
=$7f1060				PORT_A			= 	$7F1060
=$7f1061				PORT_B			= 	$7F1061
=$01					OUT_BUF_FULL	        = 	$01
=$02					INPT_BUF_FULL	        = 	$02
=$04					SYS_FLAG		= 	$04
=$08					CMD_DATA		=	$08
=$10					KEYBD_INH		=	$10
=$20					TRANS_TMOUT		=	$20
=$40					RCV_TMOUT		=	$40
=$80					PARITY_EVEN		=	$80
=$10					INH_KEYBOARD	        =	$10
=$ae					KBD_ENA			=	$AE
=$ad					KBD_DIS			=	$AD
=$f1					KB_MENU			=	$F1
=$f4					KB_ENABLE		=	$F4
=$f7					KB_MAKEBREAK	        =	$F7
=$fe					KB_ECHO			=	$FE
=$ff					KB_RESET		=	$FF
=$ed					KB_LED_CMD		=	$ED
=$aa					KB_OK			=	$AA
=$fa					KB_ACK			=	$FA
=$ff					KB_OVERRUN		=	$FF
=$fe					KB_RESEND		=	$FE
=$f0					KB_BREAK		=	$F0
=$10					KB_FA			=	$10
=$20					KB_FE			=	$20
=$40					KB_PR_LED		=	$40

;******  Return to file: kernel.asm


;******  Processing file: monitor.asm

.018000	5c 5c 80 01	jmp $01805c	MONITOR         JML IMONITOR
.018004	5c 92 80 01	jmp $018092	MSTATUS         JML IMSTATUS
.018008	5c 66 80 01	jmp $018066	MREADY          JML IMREADY
.01800c	5c 55 81 01	jmp $018155	MRETURN         JML IMRETURN
.018010	5c 5a 81 01	jmp $01815a	MPARSE          JML IMPARSE
.018014	5c 16 82 01	jmp $018216	MPARSE1         JML IMPARSE1
.018018	5c 17 82 01	jmp $018217	MEXECUTE        JML IMEXECUTE
.01801c	5c 18 82 01	jmp $018218	MASSEMBLE       JML IMASSEMBLE
.018020	5c 19 82 01	jmp $018219	MASSEMBLEA      JML IMASSEMBLEA
.018024	5c 1a 82 01	jmp $01821a	MCOMPARE        JML IMCOMPARE
.018028	5c 1b 82 01	jmp $01821b	MDISASSEMBLE    JML IMDISASSEMBLE
.01802c	5c 1c 82 01	jmp $01821c	MFILL           JML IMFILL
.018030	5c 1e 82 01	jmp $01821e	MJUMP           JML IMJUMP
.018034	5c 1f 82 01	jmp $01821f	MHUNT           JML IMHUNT
.018038	5c 20 82 01	jmp $018220	MLOAD           JML IMLOAD
.01803c	5c 21 82 01	jmp $018221	MMEMORY         JML IMMEMORY
.018040	5c 22 82 01	jmp $018222	MREGISTERS      JML IMREGISTERS
.018044	5c 23 82 01	jmp $018223	MSAVE           JML IMSAVE
.018048	5c 24 82 01	jmp $018224	MTRANSFER       JML IMTRANSFER
.01804c	5c 25 82 01	jmp $018225	MVERIFY         JML IMVERIFY
.018050	5c 26 82 01	jmp $018226	MEXIT           JML IMEXIT
.018054	5c 27 82 01	jmp $018227	MMODIFY         JML IMMODIFY
.018058	5c 28 82 01	jmp $018228	MDOS            JML IMDOS
.01805c	18		clc		IMONITOR        CLC           ; clear the carry flag
.01805d	fb		xce		                XCE           ; move carry to emulation flag.
.01805e	a9 ff fe	lda #$feff	                LDA #STACK_END ; Reset the stack
.018061	1b		tcs		                TAS
.018062	5c 66 80 01	jmp $018066	                JML IMREADY
.018066					IMREADY
.018066	48		pha		                PHA             ; begin setdbr macro
.018067	08		php		                PHP
.018068	e2 20		sep #$20	                SEP #$20        ; set A short
.01806a	a9 00		lda #$00	                LDA #`JMP_READY
.01806c	48		pha		                PHA
.01806d	ab		plb		                PLB
.01806e	28		plp		                PLP
.01806f	68		pla		                PLA             ; end setdbr macro
.018070	c2 30		rep #$30	                REP #$30        ; set A&X long
.018072	a9 66 80	lda #$8066	                LDA #<>IMREADY
.018075	8d e1 ff	sta $ffe1	                STA JMP_READY+1
.018078	e2 20		sep #$20	                SEP #$20        ; set A short
.01807a	a9 01		lda #$01	                LDA #`IMREADY
.01807c	8d e3 ff	sta $ffe3	                STA JMP_READY+3
.01807f	c2 20		rep #$20	                REP #$20        ; set A long
.018081	a9 55 81	lda #$8155	                LDA #<>IMRETURN
.018084	8d f1 ff	sta $fff1	                STA RETURN+1
.018087	e2 20		sep #$20	                SEP #$20        ; set A short
.018089	a9 01		lda #$01	                LDA #`IMRETURN
.01808b	8d f3 ff	sta $fff3	                STA RETURN+3
.01808e	5c 92 80 01	jmp $018092	                JML IMSTATUS
.018092					IMSTATUS
.018092	48		pha		                PHA             ; begin setdp macro
.018093	08		php		                PHP
.018094	c2 20		rep #$20	                REP #$20        ; set A long
.018096	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.018099	5b		tcd		                TCD
.01809a	28		plp		                PLP
.01809b	68		pla		                PLA             ; end setdp macro
.01809c	48		pha		                PHA             ; begin setdbr macro
.01809d	08		php		                PHP
.01809e	e2 20		sep #$20	                SEP #$20        ; set A short
.0180a0	a9 01		lda #$01	                LDA #`MONITOR_DATA
.0180a2	48		pha		                PHA
.0180a3	ab		plb		                PLB
.0180a4	28		plp		                PLP
.0180a5	68		pla		                PLA             ; end setdbr macro
.0180a6	a2 30 82	ldx #$8230	                LDX #<>MREGISTERS_MSG
.0180a9	22 38 05 01	jsl $010538	                JSL IPRINT
.0180ad	c2 10		rep #$10	                REP #$10        ; set X long
.0180af	e2 20		sep #$20	                SEP #$20        ; set A short
.0180b1	48		pha		                PHA             ; begin setdbr macro
.0180b2	08		php		                PHP
.0180b3	e2 20		sep #$20	                SEP #$20        ; set A short
.0180b5	a9 00		lda #$00	                LDA #$0
.0180b7	48		pha		                PHA
.0180b8	ab		plb		                PLB
.0180b9	28		plp		                PLP
.0180ba	68		pla		                PLA             ; end setdbr macro
.0180bb	a9 3b		lda #$3b	                LDA #';'
.0180bd	22 58 05 01	jsl $010558	                JSL IPUTC
.0180c1	a0 03 00	ldy #$0003	                LDY #3
.0180c4	a2 02 00	ldx #$0002	                LDX #CPUPC+2
.0180c7	22 3b 06 01	jsl $01063b	                JSL IPRINTH
.0180cb	e2 20		sep #$20	                SEP #$20        ; set A short
.0180cd	a9 20		lda #$20	                LDA #' '
.0180cf	22 58 05 01	jsl $010558	                JSL IPUTC
.0180d3	a0 02 00	ldy #$0002	                LDY #2
.0180d6	a2 04 00	ldx #$0004	                LDX #CPUA+1
.0180d9	22 3b 06 01	jsl $01063b	                JSL IPRINTH
.0180dd	e2 20		sep #$20	                SEP #$20        ; set A short
.0180df	a9 20		lda #$20	                LDA #' '
.0180e1	22 58 05 01	jsl $010558	                JSL IPUTC
.0180e5	a0 02 00	ldy #$0002	                LDY #2
.0180e8	a2 06 00	ldx #$0006	                LDX #CPUX+1
.0180eb	22 3b 06 01	jsl $01063b	                JSL IPRINTH
.0180ef	e2 20		sep #$20	                SEP #$20        ; set A short
.0180f1	a9 20		lda #$20	                LDA #' '
.0180f3	22 58 05 01	jsl $010558	                JSL IPUTC
.0180f7	a0 02 00	ldy #$0002	                LDY #2
.0180fa	a2 08 00	ldx #$0008	                LDX #CPUY+1
.0180fd	22 3b 06 01	jsl $01063b	                JSL IPRINTH
.018101	e2 20		sep #$20	                SEP #$20        ; set A short
.018103	a9 20		lda #$20	                LDA #' '
.018105	22 58 05 01	jsl $010558	                JSL IPUTC
.018109	a0 02 00	ldy #$0002	                LDY #2
.01810c	a2 0a 00	ldx #$000a	                LDX #CPUSTACK+1
.01810f	22 3b 06 01	jsl $01063b	                JSL IPRINTH
.018113	e2 20		sep #$20	                SEP #$20        ; set A short
.018115	a9 20		lda #$20	                LDA #' '
.018117	22 58 05 01	jsl $010558	                JSL IPUTC
.01811b	a0 01 00	ldy #$0001	                LDY #1
.01811e	a2 0d 00	ldx #$000d	                LDX #CPUDBR
.018121	22 3b 06 01	jsl $01063b	                JSL IPRINTH
.018125	e2 20		sep #$20	                SEP #$20        ; set A short
.018127	a9 20		lda #$20	                LDA #' '
.018129	22 58 05 01	jsl $010558	                JSL IPUTC
.01812d	22 58 05 01	jsl $010558	                JSL IPUTC
.018131	a0 02 00	ldy #$0002	                LDY #2
.018134	a2 0c 00	ldx #$000c	                LDX #CPUDP+1
.018137	22 3b 06 01	jsl $01063b	                JSL IPRINTH
.01813b	e2 20		sep #$20	                SEP #$20        ; set A short
.01813d	a9 20		lda #$20	                LDA #' '
.01813f	22 58 05 01	jsl $010558	                JSL IPUTC
.018143	a0 01 00	ldy #$0001	                LDY #1
.018146	a2 0e 00	ldx #$000e	                LDX #CPUFLAGS
.018149	22 3b 06 01	jsl $01063b	                JSL IPRINTH
.01814d	22 76 05 01	jsl $010576	                JSL IPRINTCR
.018151	5c c6 04 01	jmp $0104c6	                JML IREADYWAIT
.018155	22 5a 81 01	jsl $01815a	IMRETURN        JSL IMPARSE
.018159	6b		rtl		                RTL
.01815a	08		php		IMPARSE         PHP
.01815b	48		pha		                PHA             ; begin setdp macro
.01815c	08		php		                PHP
.01815d	c2 20		rep #$20	                REP #$20        ; set A long
.01815f	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.018162	5b		tcd		                TCD
.018163	28		plp		                PLP
.018164	68		pla		                PLA             ; end setdp macro
.018165	48		pha		                PHA             ; begin setdbr macro
.018166	08		php		                PHP
.018167	e2 20		sep #$20	                SEP #$20        ; set A short
.018169	a9 02		lda #$02	                LDA #`MONITOR_VARS
.01816b	48		pha		                PHA
.01816c	ab		plb		                PLB
.01816d	28		plp		                PLP
.01816e	68		pla		                PLA             ; end setdbr macro
.01816f	c2 30		rep #$30	                REP #$30        ; set A&X long
.018171	a9 08 00	lda #$0008	                LDA #<>MCMD
.018174	85 31		sta $31		                STA WRITEPOS
.018176	a2 00 00	ldx #$0000	                LDX #0
.018179	a4 21		ldy $21		                LDY CURSOR_Y
.01817b	22 c8 05 01	jsl $0105c8	                JSL ILOCATE
.01817f	a5 1b		lda $1b		                LDA CURSORPOS
.018181	85 2b		sta $2b		                STA READPOS
.018183	e2 20		sep #$20	                SEP #$20        ; set A short
.018185	a5 1d		lda $1d		                LDA CURSORPOS_B
.018187	48		pha		                PHA
.018188	ab		plb		                PLB
.018189	85 2d		sta $2d		                STA READPOS_B ; Set bank # for read buffer
.01818b	85 33		sta $33		                STA WRITEPOS_B  ; Set the bank # for the parsed output
.01818d	ea		nop		imparse_1       NOP
.01818e	e2 20		sep #$20	                SEP #$20        ; set A short
.018190	22 c4 81 01	jsl $0181c4	                JSL IMPARSECMD
.018194	22 76 05 01	jsl $010576	                JSL IPRINTCR
.018198	c9 3f		cmp #$3f	                CMP #'?'
.01819a	d0 15		bne $0181b1	                BNE imparse_cmd_error
.01819c	0b		phd		                PHD
.01819d	48		pha		                PHA             ; begin setdbr macro
.01819e	08		php		                PHP
.01819f	e2 20		sep #$20	                SEP #$20        ; set A short
.0181a1	a9 01		lda #$01	                LDA #`MHELP_MSG
.0181a3	48		pha		                PHA
.0181a4	ab		plb		                PLB
.0181a5	28		plp		                PLP
.0181a6	68		pla		                PLA             ; end setdbr macro
.0181a7	a2 5f 82	ldx #$825f	                LDX #<>MHELP_MSG
.0181aa	22 38 05 01	jsl $010538	                JSL IPRINT
.0181ae	2b		pld		                PLD
.0181af	80 11		bra $0181c2	                BRA imparse_done
.0181b1					imparse_cmd_error
.0181b1	48		pha		                PHA             ; begin setdbr macro
.0181b2	08		php		                PHP
.0181b3	e2 20		sep #$20	                SEP #$20        ; set A short
.0181b5	a9 01		lda #$01	                LDA #`MMERROR
.0181b7	48		pha		                PHA
.0181b8	ab		plb		                PLB
.0181b9	28		plp		                PLP
.0181ba	68		pla		                PLA             ; end setdbr macro
.0181bb	a2 29 82	ldx #$8229	                LDX #<>MMERROR
.0181be	22 38 05 01	jsl $010538	                JSL IPRINT
.0181c2					imparse_done
.0181c2	28		plp		                PLP
.0181c3	6b		rtl		                RTL
.0181c4					IMPARSECMD
.0181c4	c2 30		rep #$30	                REP #$30        ; set A&X long
.0181c6	9c 08 00	stz $020008	                STZ MCMD
.0181c9	9c 0a 00	stz $02000a	                STZ MCMD+2
.0181cc	a5 2b		lda $2b		                LDA READPOS
.0181ce	18		clc		                CLC
.0181cf	65 13		adc $13		                ADC COLS_VISIBLE
.0181d1	85 2e		sta $2e		                STA READEND
.0181d3	e2 20		sep #$20	                SEP #$20        ; set A short
.0181d5	22 dd 81 01	jsl $0181dd	                JSL IMREADCHAR
.0181d9	8d 08 00	sta $020008	impcmd_found    STA MCMD
.0181dc	6b		rtl		                RTL
.0181dd					IMREADCHAR
.0181dd	a5 2b		lda $2b		                LDA READPOS
.0181df	c5 2e		cmp $2e		                CMP READEND
.0181e1	90 05		bcc $0181e8	                BCC imrc_1
.0181e3	a5 00		lda $00		                LDA 0
.0181e5	38		sec		                SEC
.0181e6	80 04		bra $0181ec	                BRA imrc_ns_done
.0181e8	b2 2b		lda ($2b)	imrc_1          LDA (READPOS)
.0181ea	e6 2b		inc $2b		                INC READPOS
.0181ec	6b		rtl		imrc_ns_done    RTL
.0181ed	b2 2b		lda ($2b)	IMREADCHAR_ID   LDA (READPOS)
.0181ef	c9 30		cmp #$30	                CMP #'0'
.0181f1	90 18		bcc $01820b	                BCC imcrid_loop
.0181f3	c9 3a		cmp #$3a	                CMP #'9'+1
.0181f5	90 1e		bcc $018215	                BCC imrcid_done
.0181f7	c9 41		cmp #$41	                CMP #'A'
.0181f9	90 10		bcc $01820b	                BCC imcrid_loop
.0181fb	c9 5b		cmp #$5b	                CMP #'Z'+1
.0181fd	90 16		bcc $018215	                BCC imrcid_done
.0181ff	c9 61		cmp #$61	                CMP #'a'
.018201	90 08		bcc $01820b	                BCC imcrid_loop
.018203	c9 7b		cmp #$7b	                CMP #'z'+1
.018205	90 0e		bcc $018215	                BCC imrcid_done
.018207	c5 5f		cmp $5f		                CMP '_'
.018209	f0 0a		beq $018215	                BEQ imrcid_done
.01820b	e6 2b		inc $2b		imcrid_loop     INC READPOS
.01820d	a5 2b		lda $2b		                LDA READPOS
.01820f	c5 2e		cmp $2e		                CMP READEND
.018211	90 da		bcc $0181ed	                BCC IMREADCHAR_ID
.018213	a9 00		lda #$00	imrcid_0        LDA #0                  ;
.018215	6b		rtl		imrcid_done     RTL
.018216					IMWRITEARG4
.018216	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.018217	00		brk #		IMEXECUTE       BRK ; Execute the current command line (requires MCMD and MARG1-MARG8 to be populated)
.018218	00		brk #		IMASSEMBLE      BRK ; Assemble a line of text.
.018219	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.01821a	00		brk #		IMCOMPARE       BRK ; Compare memory. len=1
.01821b	00		brk #		IMDISASSEMBLE   BRK ; Disassemble memory. end=1 instruction
.01821c	00		brk #		IMFILL          BRK ; Fill memory with specified value. Start and end must be in the same bank.
.01821d	00		brk #		IMGO            BRK ; Execute from specified address
.01821e	00		brk #		IMJUMP          BRK ; Execute from spefified address
.01821f	00		brk #		IMHUNT          BRK ; Hunt (find) value in memory
.018220	00		brk #		IMLOAD          BRK ; Load data from disk. Device=1 (internal floppy) Start=Address in file
.018221	00		brk #		IMMEMORY        BRK ; View memory
.018222	00		brk #		IMREGISTERS     BRK ; View/edit registers
.018223	00		brk #		IMSAVE          BRK ; Save memory to disk
.018224	00		brk #		IMTRANSFER      BRK ; Transfer (copy) data in memory
.018225	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.018226	00		brk #		IMEXIT          BRK ; Exit monitor and return to BASIC command prompt
.018227	00		brk #		IMMODIFY        BRK ; Modify memory
.018228	00		brk #		IMDOS           BRK ; Execute DOS command
.018229					MONITOR_DATA
>018229	3f 45 52 52 4f 52 00		MMERROR         .null "?ERROR"
>018230	0d 20 50 43 20 20 20 20		MREGISTERS_MSG  .null $0D," PC     A    X    Y    SP   DBR DP   NVMXDIZC"
>018238	20 41 20 20 20 20 58 20 20 20 20 59 20 20 20 20
>018248	53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e 56
>018258	4d 58 44 49 5a 43 00
>01825f	43 6d 64 20 20 20 43 6f		MHELP_MSG       .text "Cmd   Command      Params",$0D
>018267	6d 6d 61 6e 64 20 20 20 20 20 20 50 61 72 61 6d
>018277	73 0d
>018279	41 20 20 20 20 20 41 53		                .text "A     ASSEMBLE     [Start] [Assembly code]",$0D
>018281	53 45 4d 42 4c 45 20 20 20 20 20 5b 53 74 61 72
>018291	74 5d 20 5b 41 73 73 65 6d 62 6c 79 20 63 6f 64
>0182a1	65 5d 0d
>0182a4	43 20 20 20 20 20 43 4f		                .text "C     COMPARE      Start1 Start2 [Len (1 if blank)]",$0D
>0182ac	4d 50 41 52 45 20 20 20 20 20 20 53 74 61 72 74
>0182bc	31 20 53 74 61 72 74 32 20 5b 4c 65 6e 20 28 31
>0182cc	20 69 66 20 62 6c 61 6e 6b 29 5d 0d
>0182d8	44 20 20 20 20 20 44 49		                .text "D     DISASSEMBLE  Start [End]",$0D
>0182e0	53 41 53 53 45 4d 42 4c 45 20 20 53 74 61 72 74
>0182f0	20 5b 45 6e 64 5d 0d
>0182f7	46 20 20 20 20 20 46 49		                .text "F     FILL         Start End Byte",$0D
>0182ff	4c 4c 20 20 20 20 20 20 20 20 20 53 74 61 72 74
>01830f	20 45 6e 64 20 42 79 74 65 0d
>018319	47 20 20 20 20 20 47 4f		                .text "G     GO           [Address]",$0D
>018321	20 20 20 20 20 20 20 20 20 20 20 5b 41 64 64 72
>018331	65 73 73 5d 0d
>018336	4a 20 20 20 20 20 20 20		                .text "J                  [Address]",$0D
>01833e	20 20 20 20 20 20 20 20 20 20 20 5b 41 64 64 72
>01834e	65 73 73 5d 0d
>018353	48 20 20 20 20 20 48 55		                .text "H     HUNT (find)  Start End Byte [Byte]...",$0D
>01835b	4e 54 20 28 66 69 6e 64 29 20 20 53 74 61 72 74
>01836b	20 45 6e 64 20 42 79 74 65 20 5b 42 79 74 65 5d
>01837b	2e 2e 2e 0d
>01837f	4c 20 20 20 20 20 4c 4f		                .text "L     LOAD         ""File"" [Device] [Start]",$0D
>018387	41 44 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>018397	22 20 5b 44 65 76 69 63 65 5d 20 5b 53 74 61 72
>0183a7	74 5d 0d
>0183aa	4d 20 20 20 20 20 4d 45		                .text "M     MEMORY       [Start] [End]",$0D
>0183b2	4d 4f 52 59 20 20 20 20 20 20 20 5b 53 74 61 72
>0183c2	74 5d 20 5b 45 6e 64 5d 0d
>0183cb	52 20 20 20 20 20 52 45		                .text "R     REGISTERS    Register [Value]  (A 1234, F 00100011)",$0D
>0183d3	47 49 53 54 45 52 53 20 20 20 20 52 65 67 69 73
>0183e3	74 65 72 20 5b 56 61 6c 75 65 5d 20 20 28 41 20
>0183f3	31 32 33 34 2c 20 46 20 30 30 31 30 30 30 31 31
>018403	29 0d
>018405	3b 20 20 20 20 20 20 20		                .text ";                  PC A X Y SP DBR DP NVMXDIZC",$0D
>01840d	20 20 20 20 20 20 20 20 20 20 20 50 43 20 41 20
>01841d	58 20 59 20 53 50 20 44 42 52 20 44 50 20 4e 56
>01842d	4d 58 44 49 5a 43 0d
>018434	53 20 20 20 20 20 53 41		                .text "S     SAVE         ""File"" Device Start End",$0D
>01843c	56 45 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>01844c	22 20 44 65 76 69 63 65 20 53 74 61 72 74 20 45
>01845c	6e 64 0d
>01845f	54 20 20 20 20 20 54 52		                .text "T     TRANSFER     Start End Destination",$0D
>018467	41 4e 53 46 45 52 20 20 20 20 20 53 74 61 72 74
>018477	20 45 6e 64 20 44 65 73 74 69 6e 61 74 69 6f 6e
>018487	0d
>018488	56 20 20 20 20 20 56 45		                .text "V     VERIFY       ""File"" [Device] [Start]",$0D
>018490	52 49 46 59 20 20 20 20 20 20 20 22 46 69 6c 65
>0184a0	22 20 5b 44 65 76 69 63 65 5d 20 5b 53 74 61 72
>0184b0	74 5d 0d
>0184b3	58 20 20 20 20 20 45 58		                .text "X     EXIT",$0D
>0184bb	49 54 0d
>0184be	3e 20 20 20 20 20 4d 4f		                .text ">     MODIFY       Start Byte [Byte]...",$0D
>0184c6	44 49 46 59 20 20 20 20 20 20 20 53 74 61 72 74
>0184d6	20 42 79 74 65 20 5b 42 79 74 65 5d 2e 2e 2e 0d
>0184e6	40 20 20 20 20 20 44 4f		                .text "@     DOS          [Command] Returns drive status if no params.",$0D
>0184ee	53 20 20 20 20 20 20 20 20 20 20 5b 43 6f 6d 6d
>0184fe	61 6e 64 5d 20 52 65 74 75 72 6e 73 20 64 72 69
>01850e	76 65 20 73 74 61 74 75 73 20 69 66 20 6e 6f 20
>01851e	70 61 72 61 6d 73 2e 0d
>018526	3f 20 20 20 20 20 48 45		                .text "?     HELP         Display a short help screen ",$00
>01852e	4c 50 20 20 20 20 20 20 20 20 20 44 69 73 70 6c
>01853e	61 79 20 61 20 73 68 6f 72 74 20 68 65 6c 70 20
>01854e	73 63 72 65 65 6e 20 00

;******  Return to file: kernel.asm


;******  Processing file: kernel_jumptable.asm

.010000	5c 00 04 01	jmp $010400	BOOT            JML IBOOT
.010004	5c 9a 08 01	jmp $01089a	RESTORE         JML IRESTORE
.010008	5c 7e 04 01	jmp $01047e	BREAK           JML IBREAK
.01000c	5c b3 04 01	jmp $0104b3	READY           JML IREADY
.010010	5c 9b 08 01	jmp $01089b	SCINIT          JML ISCINIT
.010014	5c 9c 08 01	jmp $01089c	IOINIT          JML IIOINIT
.010018	5c 58 05 01	jmp $010558	PUTC            JML IPUTC
.01001c	5c 41 05 01	jmp $010541	PUTS            JML IPUTS
.010020	5c 75 05 01	jmp $010575	PUTB            JML IPUTB
.010024	5c 9d 08 01	jmp $01089d	PUTBLOCK        JML IPUTBLOCK
.010028	5c 9e 08 01	jmp $01089e	SETLFS          JML ISETLFS
.01002c	5c 9f 08 01	jmp $01089f	SETNAM          JML ISETNAM
.010030	5c a0 08 01	jmp $0108a0	OPEN            JML IOPEN
.010034	5c a1 08 01	jmp $0108a1	CLOSE           JML ICLOSE
.010038	5c a2 08 01	jmp $0108a2	SETIN           JML ISETIN
.01003c	5c a3 08 01	jmp $0108a3	SETOUT          JML ISETOUT
.010040	5c a4 08 01	jmp $0108a4	GETB            JML IGETB
.010044	5c a5 08 01	jmp $0108a5	GETBLOCK        JML IGETBLOCK
.010048	5c a6 08 01	jmp $0108a6	GETCH           JML IGETCH
.01004c	5c 07 05 01	jmp $010507	GETCHW          JML IGETCHW
.010050	5c fe 04 01	jmp $0104fe	GETCHE          JML IGETCHE
.010054	5c a7 08 01	jmp $0108a7	GETS            JML IGETS
.010058	5c a8 08 01	jmp $0108a8	GETLINE         JML IGETLINE
.01005c	5c a9 08 01	jmp $0108a9	GETFIELD        JML IGETFIELD
.010060	5c aa 08 01	jmp $0108aa	TRIM            JML ITRIM
.010064	5c ab 08 01	jmp $0108ab	PRINTC          JML IPRINTC
.010068	5c ac 08 01	jmp $0108ac	PRINTS          JML IPRINTS
.01006c	5c 76 05 01	jmp $010576	PRINTCR         JML IPRINTCR
.010070	5c ad 08 01	jmp $0108ad	PRINTF          JML IPRINTF
.010074	5c ae 08 01	jmp $0108ae	PRINTI          JML IPRINTI
.010078	5c 3b 06 01	jmp $01063b	PRINTH          JML IPRINTH
.01007c	5c af 08 01	jmp $0108af	PRINTAI         JML IPRINTAI
.010080	5c b0 08 01	jmp $0108b0	PRINTAH         JML IPRINTAH
.010084	5c c8 05 01	jmp $0105c8	LOCATE          JML ILOCATE
.010088	5c dc 04 01	jmp $0104dc	PUSHKEY         JML IPUSHKEY
.01008c	5c b1 08 01	jmp $0108b1	PUSHKEYS        JML IPUSHKEYS
.010090	5c 99 05 01	jmp $010599	CSRRIGHT        JML ICSRRIGHT
.010094	5c b2 08 01	jmp $0108b2	CSRLEFT         JML ICSRLEFT
.010098	5c c6 05 01	jmp $0105c6	CSRUP           JML ICSRUP
.01009c	5c c7 05 01	jmp $0105c7	CSRDOWN         JML ICSRDOWN
.0100a0	5c b3 08 01	jmp $0108b3	CSRHOME         JML ICSRHOME
.0100a4	5c fe 05 01	jmp $0105fe	SCROLLUP        JML ISCROLLUP
.0100a8	5c 69 06 01	jmp $010669	CLRSCREEN       JML ICLRSCREEN
.0100ac	5c c5 06 01	jmp $0106c5	INITCHLUT	JML IINITCHLUT
.0100b0	5c f4 06 01	jmp $0106f4	INITSUPERIO	JML IINITSUPERIO
.0100b4	5c f5 07 01	jmp $0107f5	INITKEYBOARD	JML IINITKEYBOARD

;******  Return to file: kernel.asm

.010400					IBOOT
.010400	18		clc		                CLC                 ; clear the carry flag
.010401	fb		xce		                XCE                 ; move carry to emulation flag.
.010402	48		pha		                PHA             ; begin setdbr macro
.010403	08		php		                PHP
.010404	e2 20		sep #$20	                SEP #$20        ; set A short
.010406	a9 00		lda #$00	                LDA #0
.010408	48		pha		                PHA
.010409	ab		plb		                PLB
.01040a	28		plp		                PLP
.01040b	68		pla		                PLA             ; end setdbr macro
.01040c	c2 30		rep #$30	                REP #$30        ; set A&X long
.01040e	a9 ff fe	lda #$feff	                LDA #STACK_END      ; initialize stack pointer
.010411	1b		tcs		                TAS
.010412	48		pha		                PHA             ; begin setdp macro
.010413	08		php		                PHP
.010414	c2 20		rep #$20	                REP #$20        ; set A long
.010416	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.010419	5b		tcd		                TCD
.01041a	28		plp		                PLP
.01041b	68		pla		                PLA             ; end setdp macro
.01041c	a9 00 80	lda #$8000	                LDA #<>TEXT_PAGE0 ; store initial screen buffer location
.01041f	85 10		sta $10		                STA SCREENBEGIN
.010421	e2 20		sep #$20	                SEP #$20        ; set A short
.010423	a9 02		lda #$02	                LDA #`TEXT_PAGE0
.010425	85 12		sta $12		                STA SCREENBEGIN+2
.010427	c2 30		rep #$30	                REP #$30        ; set A&X long
.010429	a9 00 80	lda #$8000	                LDA #<>TEXT_PAGE0 ; store initial screen buffer location
.01042c	85 1b		sta $1b		                STA CURSORPOS
.01042e	e2 20		sep #$20	                SEP #$20        ; set A short
.010430	a9 02		lda #$02	                LDA #`TEXT_PAGE0
.010432	85 1d		sta $1d		                STA CURSORPOS+2
.010434	c2 30		rep #$30	                REP #$30        ; set A&X long
.010436	a2 50 00	ldx #$0050	                LDX #80
.010439	86 13		stx $13		                STX COLS_VISIBLE
.01043b	a0 3c 00	ldy #$003c	                LDY #60
.01043e	84 17		sty $17		                STY LINES_VISIBLE
.010440	a2 80 00	ldx #$0080	                LDX #128
.010443	86 15		stx $15		                STX COLS_PER_LINE
.010445	a0 40 00	ldy #$0040	                LDY #64
.010448	84 19		sty $19		                STY LINES_MAX
.01044a	22 69 06 01	jsl $010669	                JSL ICLRSCREEN
.01044e	c2 20		rep #$20	                REP #$20        ; set A long
.010450	a2 00 00	ldx #$0000	                LDX #$0
.010453	a0 00 00	ldy #$0000	                LDY #$0
.010456	22 c8 05 01	jsl $0105c8	                JSL ILOCATE
.01045a	9c 42 02	stz $0242	                STZ KEY_BUFFER_RPOS
.01045d	9c 44 02	stz $0244	                STZ KEY_BUFFER_WPOS
.010460					greet
.010460	48		pha		                PHA             ; begin setdbr macro
.010461	08		php		                PHP
.010462	e2 20		sep #$20	                SEP #$20        ; set A short
.010464	a9 01		lda #$01	                LDA #`greet_msg
.010466	48		pha		                PHA
.010467	ab		plb		                PLB
.010468	28		plp		                PLP
.010469	68		pla		                PLA             ; end setdbr macro
.01046a	a2 b6 08	ldx #$08b6	                LDX #<>greet_msg
.01046d	22 38 05 01	jsl $010538	                JSL IPRINT       ; print the first line
.010471	e2 20		sep #$20	                SEP #$20        ; set A short
.010473	48		pha		                PHA             ; begin setdbr macro
.010474	08		php		                PHP
.010475	e2 20		sep #$20	                SEP #$20        ; set A short
.010477	a9 01		lda #$01	                LDA #$01
.010479	48		pha		                PHA
.01047a	ab		plb		                PLB
.01047b	28		plp		                PLP
.01047c	68		pla		                PLA             ; end setdbr macro
.01047d	00		brk #		greet_done      BRK             ;Terminate boot routine and go to Ready handler.
.01047e					IBREAK
.01047e	48		pha		                PHA             ; begin setdp macro
.01047f	08		php		                PHP
.010480	c2 20		rep #$20	                REP #$20        ; set A long
.010482	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.010485	5b		tcd		                TCD
.010486	28		plp		                PLP
.010487	68		pla		                PLA             ; end setdp macro
.010488	68		pla		                PLA             ; Pull .Y and stuff it in the CPUY variable
.010489	85 07		sta $07		                STA CPUY
.01048b	68		pla		                PLA             ; Pull .X and stuff it in the CPUY variable
.01048c	85 05		sta $05		                STA CPUX
.01048e	68		pla		                PLA             ; Pull .A and stuff it in the CPUY variable
.01048f	85 03		sta $03		                STA CPUA
.010491	68		pla		                PLA
.010492	85 0b		sta $0b		                STA CPUDP       ; Pull Direct page
.010494	e2 20		sep #$20	                SEP #$20        ; set A short
.010496	68		pla		                PLA             ; Pull Data Bank (8 bits)
.010497	85 0d		sta $0d		                STA CPUDBR
.010499	68		pla		                PLA             ; Pull Flags (8 bits)
.01049a	85 0e		sta $0e		                STA CPUFLAGS
.01049c	c2 20		rep #$20	                REP #$20        ; set A long
.01049e	68		pla		                PLA             ; Pull Program Counter (16 bits)
.01049f	85 00		sta $00		                STA CPUPC
.0104a1	e2 20		sep #$20	                SEP #$20        ; set A short
.0104a3	68		pla		                PLA             ; Pull Program Bank (8 bits)
.0104a4	85 02		sta $02		                STA CPUPBR
.0104a6	c2 20		rep #$20	                REP #$20        ; set A long
.0104a8	3b		tsc		                TSA             ; Get the stack
.0104a9	85 09		sta $09		                STA CPUSTACK    ; Store the stack at immediately before the interrupt was asserted
.0104ab	a9 ff fe	lda #$feff	                LDA #<>STACK_END   ; initialize stack pointer back to the bootup value
.0104ae	1b		tcs		                TAS
.0104af	5c e0 ff 00	jmp $00ffe0	                JML JMP_READY   ; Run READY routine (usually BASIC or MONITOR)
.0104b3					IREADY
.0104b3	48		pha		                PHA             ; begin setdbr macro
.0104b4	08		php		                PHP
.0104b5	e2 20		sep #$20	                SEP #$20        ; set A short
.0104b7	a9 01		lda #$01	                LDA #`ready_msg
.0104b9	48		pha		                PHA
.0104ba	ab		plb		                PLB
.0104bb	28		plp		                PLP
.0104bc	68		pla		                PLA             ; end setdbr macro
.0104bd	e2 20		sep #$20	                SEP #$20        ; set A short
.0104bf	a2 5a 0a	ldx #$0a5a	                LDX #<>ready_msg
.0104c2	22 38 05 01	jsl $010538	                JSL IPRINT
.0104c6					IREADYWAIT
.0104c6	22 07 05 01	jsl $010507	                JSL IGETCHW     ; Read a character from the buffer
.0104ca	c9 0d		cmp #$0d	                CMP #$0D         ; If it is Return, run the Return handler
.0104cc	f0 06		beq $0104d4	                BEQ ireadywait_return
.0104ce	22 58 05 01	jsl $010558	                JSL IPUTC
.0104d2	80 f2		bra $0104c6	                BRA IREADYWAIT
.0104d4					ireadywait_return
.0104d4	22 f0 ff 00	jsl $00fff0	                JSL RRETURN
.0104d8	80 ec		bra $0104c6	                BRA IREADYWAIT
.0104da	db		stp		IKEYDOWN        STP             ; Keyboard key pressed
.0104db	db		stp		IRETURN         STP
.0104dc	0b		phd		IPUSHKEY        PHD
.0104dd	08		php		                PHP
.0104de	48		pha		                PHA             ; begin setdp macro
.0104df	08		php		                PHP
.0104e0	c2 20		rep #$20	                REP #$20        ; set A long
.0104e2	a9 00 02	lda #$0200	                LDA #<>KEY_BUFFER         ; set DP to page 0
.0104e5	5b		tcd		                TCD
.0104e6	28		plp		                PLP
.0104e7	68		pla		                PLA             ; end setdp macro
.0104e8	c2 30		rep #$30	                REP #$30        ; set A&X long
.0104ea	92 44		sta ($0244)	                STA (KEY_BUFFER_WPOS)
.0104ec	e6 44		inc $0244	                INC KEY_BUFFER_WPOS
.0104ee	e6 44		inc $0244	                INC KEY_BUFFER_WPOS
.0104f0	a5 44		lda $0244	                LDA KEY_BUFFER_WPOS
.0104f2	c5 40		cmp $0240	                CMP KEY_BUFFER_END
.0104f4	90 05		bcc $0104fb	                BCC readkb_done
.0104f6	a9 00 02	lda #$0200	                LDA #KEY_BUFFER
.0104f9	85 44		sta $0244	                STA KEY_BUFFER_WPOS
.0104fb					readkb_done
.0104fb	28		plp		                PLP
.0104fc	2b		pld		                PLD
.0104fd	6b		rtl		                RTL
.0104fe	22 07 05 01	jsl $010507	IGETCHE         JSL IGETCHW
.010502	22 58 05 01	jsl $010558	                JSL IPUTC
.010506	6b		rtl		                RTL
.010507	0b		phd		IGETCHW         PHD
.010508	da		phx		                PHX
.010509	08		php		                PHP
.01050a	48		pha		                PHA             ; begin setdp macro
.01050b	08		php		                PHP
.01050c	c2 20		rep #$20	                REP #$20        ; set A long
.01050e	a9 00 02	lda #$0200	                LDA #<>KEY_BUFFER         ; set DP to page 0
.010511	5b		tcd		                TCD
.010512	28		plp		                PLP
.010513	68		pla		                PLA             ; end setdp macro
.010514	c2 30		rep #$30	                REP #$30        ; set A&X long
.010516	a6 42		ldx $0242	igetchw1        LDX KEY_BUFFER_RPOS
.010518	e4 44		cpx $0244	                CPX KEY_BUFFER_WPOS
.01051a	d0 05		bne $010521	                BNE igetchw2
>01051c	42 00				                .byte $42, $00
.01051e	4c 16 05	jmp $010516	                JMP igetchw1
.010521	b5 00		lda $0200,x	igetchw2        LDA $0,D,X  ; Read the value in the keyboard buffer
.010523	48		pha		                PHA
.010524	8a		txa		                TXA
.010525	18		clc		                CLC
.010526	69 02 00	adc #$0002	                ADC #$02
.010529	c9 40 00	cmp #$0040	                CMP #KEY_BUFFER_SIZE
.01052c	90 03		bcc $010531	                BCC igetchw3
.01052e	a9 00 00	lda #$0000	                LDA #$0
.010531	85 42		sta $0242	igetchw3        STA KEY_BUFFER_RPOS
.010533	68		pla		                PLA
.010534	28		plp		igetchw_done    PLP
.010535	fa		plx		                PLX             ; Restore the saved registers and return
.010536	2b		pld		                PLD
.010537	6b		rtl		                RTL
.010538	22 41 05 01	jsl $010541	IPRINT          JSL IPUTS
.01053c	22 76 05 01	jsl $010576	                JSL IPRINTCR
.010540	6b		rtl		                RTL
.010541	48		pha		IPUTS           PHA
.010542	08		php		                PHP
.010543	e2 20		sep #$20	                SEP #$20        ; set A short
.010545	c2 10		rep #$10	                REP #$10        ; set X long
.010547	bd 00 00	lda $010000,x	iputs1          LDA $0,b,x      ; read from the string
.01054a	f0 08		beq $010554	                BEQ iputs_done
.01054c	22 58 05 01	jsl $010558	iputs2          JSL IPUTC
.010550	e8		inx		iputs3          INX
.010551	4c 47 05	jmp $010547	                JMP iputs1
.010554	e8		inx		iputs_done      INX
.010555	28		plp		                PLP
.010556	68		pla		                PLA
.010557	6b		rtl		                RTL
.010558					IPUTC
.010558	e2 20		sep #$20	                SEP #$20        ; set A short
.01055a	c9 0d		cmp #$0d	                CMP #$0D        ; handle CR
.01055c	d0 06		bne $010564	                BNE iputc_bs
.01055e	22 76 05 01	jsl $010576	                JSL IPRINTCR
.010562	80 10		bra $010574	                BRA iputc_done
.010564	c9 08		cmp #$08	iputc_bs        CMP #$08        ; backspace
.010566	d0 06		bne $01056e	                BNE iputc_print
.010568	22 89 05 01	jsl $010589	                JSL IPRINTBS
.01056c	80 06		bra $010574	                BRA iputc_done
.01056e	87 1b		sta [$1b]	iputc_print     STA [CURSORPOS] ; Save the character on the screen
.010570	22 99 05 01	jsl $010599	                JSL ICSRRIGHT
.010574	6b		rtl		iputc_done	RTL
.010575					IPUTB
.010575	6b		rtl		                RTL
.010576	48		pha		IPRINTCR	PHA
.010577	da		phx		                PHX
.010578	5a		phy		                PHY
.010579	08		php		                PHP
.01057a	a2 00 00	ldx #$0000	                LDX #0
.01057d	a4 21		ldy $21		                LDY CURSOR_Y
.01057f	c8		iny		                INY
.010580	22 c8 05 01	jsl $0105c8	                JSL ILOCATE
.010584	28		plp		                PLP
.010585	7a		ply		                PLY
.010586	fa		plx		                PLX
.010587	68		pla		                PLA
.010588	6b		rtl		                RTL
.010589	da		phx		IPRINTBS	PHX
.01058a	5a		phy		                PHY
.01058b	08		php		                PHP
.01058c	a6 1f		ldx $1f		                LDX CURSOR_X
.01058e	a4 21		ldy $21		                LDY CURSOR_Y
.010590	ca		dex		                DEX
.010591	22 c8 05 01	jsl $0105c8	                JSL ILOCATE
.010595	28		plp		                PLP
.010596	7a		ply		                PLY
.010597	fa		plx		                PLX
.010598	6b		rtl		                RTL
.010599					ICSRRIGHT
.010599	da		phx		                PHX
.01059a	8b		phb		                PHB
.01059b	08		php		                PHP
.01059c	c2 20		rep #$20	                REP #$20        ; set A long
.01059e	c2 10		rep #$10	                REP #$10        ; set X long
.0105a0	48		pha		                PHA             ; begin setdp macro
.0105a1	08		php		                PHP
.0105a2	c2 20		rep #$20	                REP #$20        ; set A long
.0105a4	a9 00 00	lda #$0000	                LDA #$0         ; set DP to page 0
.0105a7	5b		tcd		                TCD
.0105a8	28		plp		                PLP
.0105a9	68		pla		                PLA             ; end setdp macro
.0105aa	e6 1b		inc $1b		                INC CURSORPOS
.0105ac	a6 1f		ldx $1f		                LDX CURSOR_X
.0105ae	e8		inx		                INX
.0105af	e4 13		cpx $13		                CPX COLS_VISIBLE
.0105b1	90 0c		bcc $0105bf	                BCC icsr_nowrap  ; wrap if the cursor is at or past column 80
.0105b3	a2 00 00	ldx #$0000	                LDX #0
.0105b6	5a		phy		                PHY
.0105b7	a4 21		ldy $21		                LDY CURSOR_Y
.0105b9	c8		iny		                INY
.0105ba	22 c8 05 01	jsl $0105c8	                JSL ILOCATE
.0105be	7a		ply		                PLY
.0105bf	86 1f		stx $1f		icsr_nowrap     STX CURSOR_X
.0105c1	28		plp		                PLP
.0105c2	ab		plb		                PLB
.0105c3	fa		plx		                PLX
.0105c4	6b		rtl		                RTL
.0105c5	6b		rtl		ISRLEFT	        RTL
.0105c6	6b		rtl		ICSRUP	        RTL
.0105c7	6b		rtl		ICSRDOWN	RTL
.0105c8	48		pha		ILOCATE         PHA
.0105c9	08		php		                PHP
.0105ca	c2 30		rep #$30	                REP #$30        ; set A&X long
.0105cc					ilocate_scroll
.0105cc	c4 17		cpy $17		                CPY LINES_VISIBLE
.0105ce	90 07		bcc $0105d7	                BCC ilocate_scrolldone
.0105d0	22 fe 05 01	jsl $0105fe	                JSL ISCROLLUP
.0105d4	88		dey		                DEY
.0105d5	80 f5		bra $0105cc	                BRA ilocate_scroll
.0105d7					ilocate_scrolldone
.0105d7	86 1f		stx $1f		                STX CURSOR_X
.0105d9	84 21		sty $21		                STY CURSOR_Y
.0105db	a5 10		lda $10		                LDA SCREENBEGIN
.0105dd					ilocate_row
.0105dd	c0 00 00	cpy #$0000	                CPY #$0
.0105e0	f0 08		beq $0105ea	                BEQ ilocate_right
.0105e2	18		clc		ilocate_down    CLC
.0105e3	65 15		adc $15		                ADC COLS_PER_LINE
.0105e5	88		dey		                DEY
.0105e6	f0 02		beq $0105ea	                BEQ ilocate_right
.0105e8	80 f8		bra $0105e2	                BRA ilocate_down
.0105ea	18		clc		ilocate_right   CLC
.0105eb	65 1f		adc $1f		                ADC CURSOR_X   ; move the cursor right X columns
.0105ed	85 1b		sta $1b		                STA CURSORPOS
.0105ef	a4 21		ldy $21		                LDY CURSOR_Y
.0105f1					ilocate_done
.0105f1	8a		txa		                TXA
.0105f2	8f 0c 00 7f	sta $7f000c	                STA TXT_CURSOR_X_REG_L
.0105f6	98		tya		                TYA
.0105f7	8f 0e 00 7f	sta $7f000e	                STA TXT_CURSOR_Y_REG_L
.0105fb	28		plp		                PLP
.0105fc	68		pla		                PLA
.0105fd	6b		rtl		                RTL
.0105fe					ISCROLLUP
.0105fe	48		pha		                PHA
.0105ff	da		phx		                PHX
.010600	5a		phy		                PHY
.010601	8b		phb		                PHB
.010602	08		php		                PHP
.010603	c2 30		rep #$30	                REP #$30        ; set A&X long
.010605	a2 80 80	ldx #$8080	                LDX #<>TEXT_PAGE0+128
.010608	a0 00 80	ldy #$8000	                LDY #<>TEXT_PAGE0
.01060b	a9 7f 1f	lda #$1f7f	                LDA #8063
.01060e	44 02 02	mvp $02,$02	                MVP `TEXT_PAGE0,`TEXT_PAGE0
.010611	a2 80 a0	ldx #$a080	                LDX #<>TEXT_PAGE1+128
.010614	a0 00 a0	ldy #$a000	                LDY #<>TEXT_PAGE1
.010617	a9 7f 1f	lda #$1f7f	                LDA #8063
.01061a	44 02 02	mvp $02,$02	                MVP `TEXT_PAGE0,`TEXT_PAGE0
.01061d	a2 80 c0	ldx #$c080	                LDX #<>TEXT_PAGE2+128
.010620	a0 00 c0	ldy #$c000	                LDY #<>TEXT_PAGE2
.010623	a9 7f 1f	lda #$1f7f	                LDA #8063
.010626	44 02 02	mvp $02,$02	                MVP `TEXT_PAGE0,`TEXT_PAGE0
.010629	a2 80 e0	ldx #$e080	                LDX #<>TEXT_PAGE3+128
.01062c	a0 00 e0	ldy #$e000	                LDY #<>TEXT_PAGE3
.01062f	a9 7f 1f	lda #$1f7f	                LDA #8063
.010632	44 02 02	mvp $02,$02	                MVP `TEXT_PAGE0,`TEXT_PAGE0
.010635					iscrollup_done
.010635	28		plp		                PLP
.010636	ab		plb		                PLB
.010637	7a		ply		                PLY
.010638	fa		plx		                PLX
.010639	68		pla		                PLA
.01063a	6b		rtl		                RTL
.01063b	48		pha		IPRINTH         PHA
.01063c	08		php		                PHP
.01063d					iprinth1
.01063d	e2 20		sep #$20	                SEP #$20        ; set A short
.01063f	bd 00 00	lda $010000,x	                LDA #0,b,x      ; Read the value to be printed
.010642	4a		lsr a		                LSR
.010643	4a		lsr a		                LSR
.010644	4a		lsr a		                LSR
.010645	4a		lsr a		                LSR
.010646	22 58 06 01	jsl $010658	                JSL iprint_digit
.01064a	bd 00 00	lda $010000,x	                LDA #0,b,x
.01064d	22 58 06 01	jsl $010658	                JSL iprint_digit
.010651	ca		dex		                DEX
.010652	88		dey		                DEY
.010653	d0 e8		bne $01063d	                BNE iprinth1
.010655	28		plp		                PLP
.010656	68		pla		                PLA
.010657	6b		rtl		                RTL
.010658	da		phx		iprint_digit    PHX
.010659	c2 20		rep #$20	                REP #$20        ; set A long
.01065b	29 0f 00	and #$000f	                AND #$0F
.01065e	aa		tax		                TAX
.01065f	bf 16 0b 01	lda $010b16,x	                LDA hex_digits,X
.010663	22 58 05 01	jsl $010558	                JSL IPUTC       ; Print the digit
.010667	fa		plx		                PLX
.010668	6b		rtl		                RTL
.010669	0b		phd		ICLRSCREEN	PHD
.01066a	48		pha		                PHA
.01066b	5a		phy		                PHY
.01066c	08		php		                PHP
.01066d	e2 20		sep #$20	                SEP #$20        ; set A short
.01066f	c2 10		rep #$10	                REP #$10        ; set X long
.010671	a0 00 00	ldy #$0000	                LDY #$0000		; We'll use X to loop through screen memory
.010674	a9 20		lda #$20	                LDA #$20		; Fill the Entire Screen with Space
.010676	97 10		sta [$10],y	iclearloop0     STA [SCREENBEGIN],Y	;
.010678	c8		iny		                INY
.010679	c0 00 20	cpy #$2000	                CPY #TEXT_PAGE_SIZE
.01067c	d0 f8		bne $010676	                BNE iclearloop0
.01067e	a9 ed		lda #$ed	                LDA #$ED		; Fill the Color Memory with Foreground: 75% Purple, Background 12.5% White
.010680	97 10		sta [$10],y	iclearloop1   	STA [SCREENBEGIN],Y	;
.010682	c8		iny		                INY
.010683	c0 00 40	cpy #$4000	                CPY #TEXT_PAGE_SIZE*2
.010686	d0 f8		bne $010680	                BNE iclearloop1
.010688	28		plp		                PLP
.010689	7a		ply		                PLY
.01068a	68		pla		                PLA
.01068b	2b		pld		                PLD
.01068c	6b		rtl		                RTL
.01068d	48		pha		ICOLORFLAG      PHA
.01068e	da		phx		                PHX
.01068f	08		php		                PHP
.010690	e2 30		sep #$30	                SEP #$30        ; set A&X short
.010692	a2 00		ldx #$00	                LDX #$00
.010694	bf 94 09 01	lda $010994,x	iclearloop2	    LDA @lgreet_clr_line1,x
.010698	9f 00 20 80	sta $802000,x	                STA $802000,x
.01069c	bf a2 09 01	lda $0109a2,x	                LDA @lgreet_clr_line2,x
.0106a0	9f 80 20 80	sta $802080,x	                STA $802080,x
.0106a4	bf b0 09 01	lda $0109b0,x	                LDA @lgreet_clr_line3,x
.0106a8	9f 00 21 80	sta $802100,x	                STA $802100,x
.0106ac	bf be 09 01	lda $0109be,x	                LDA @lgreet_clr_line4,x
.0106b0	9f 80 21 80	sta $802180,x	                STA $802180,x
.0106b4	bf cc 09 01	lda $0109cc,x	                LDA @lgreet_clr_line5,x
.0106b8	9f 00 22 80	sta $802200,x	                STA $802200,x
.0106bc	e8		inx		                inx
.0106bd	e0 0e		cpx #$0e	                cpx #$0E
.0106bf	d0 d3		bne $010694	                bne iclearloop2
.0106c1	28		plp		                PLP
.0106c2	fa		plx		                PLX
.0106c3	68		pla		                PLA
.0106c4	6b		rtl		                RTL
.0106c5	0b		phd		IINITCHLUT		PHD
.0106c6	08		php		      				PHP
.0106c7	48		pha		      				PHA
.0106c8	da		phx		      				PHX
.0106c9	e2 20		sep #$20	                SEP #$20        ; set A short
.0106cb	e2 10		sep #$10	                SEP #$10        ; set X short
.0106cd	a2 00		ldx #$00	        			LDX	#$00
.0106cf	bf da 09 01	lda $0109da,x	lutinitloop0	LDA @lfg_color_lut,x		; get Local Data
.0106d3	9f 40 1f 7f	sta $7f1f40,x	      				STA FG_CHAR_LUT_PTR,x	; Write in LUT Memory
.0106d7	e8		inx		      				inx
.0106d8	e0 40		cpx #$40	      				cpx #$40
.0106da	d0 f3		bne $0106cf	      				bne lutinitloop0
.0106dc	a2 00		ldx #$00	      				LDX	#$00
.0106de	bf 1a 0a 01	lda $010a1a,x	lutinitloop1	LDA @lbg_color_lut,x		; get Local Data
.0106e2	9f 80 1f 7f	sta $7f1f80,x	      				STA BG_CHAR_LUT_PTR,x	; Write in LUT Memory
.0106e6	e8		inx		      				inx
.0106e7	e0 40		cpx #$40	      				cpx #$40
.0106e9	d0 f3		bne $0106de	      				bne lutinitloop1
.0106eb	c2 20		rep #$20	                REP #$20        ; set A long
.0106ed	c2 10		rep #$10	                REP #$10        ; set X long
.0106ef	fa		plx		              PLX
.0106f0	68		pla		              PLA
.0106f1	28		plp						      PLP
.0106f2	2b		pld		              PLD
.0106f3	6b		rtl		              RTL
.0106f4	0b		phd		IINITSUPERIO	PHD
.0106f5	08		php		      				PHP
.0106f6	48		pha		      				PHA
.0106f7	e2 20		sep #$20	                SEP #$20        ; set A short
.0106f9	a9 01		lda #$01	      				LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.0106fb	8f 23 11 7f	sta $7f1123	      				STA GP10_REG
.0106ff	a9 01		lda #$01	      				LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.010701	8f 24 11 7f	sta $7f1124	      				STA GP11_REG
.010705	a9 01		lda #$01	      				LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.010707	8f 25 11 7f	sta $7f1125	      				STA GP12_REG
.01070b	a9 01		lda #$01	      				LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.01070d	8f 26 11 7f	sta $7f1126	      				STA GP13_REG
.010711	a9 05		lda #$05	      				LDA #$05		;(C256 - POT A Analog BX) Bit[0] = 1, Bit[2] = 1
.010713	8f 27 11 7f	sta $7f1127	      				STA GP14_REG
.010717	a9 05		lda #$05	      				LDA #$05		;(C256 - POT A Analog BY) Bit[0] = 1, Bit[2] = 1
.010719	8f 28 11 7f	sta $7f1128	      				STA GP15_REG
.01071d	a9 05		lda #$05	      				LDA #$05		;(C256 - POT B Analog BX) Bit[0] = 1, Bit[2] = 1
.01071f	8f 29 11 7f	sta $7f1129	      				STA GP16_REG
.010723	a9 05		lda #$05	      				LDA #$05		;(C256 - POT B Analog BY) Bit[0] = 1, Bit[2] = 1
.010725	8f 2a 11 7f	sta $7f112a	      				STA GP17_REG
.010729	a9 00		lda #$00	      				LDA #$00		;(C256 - HEADPHONE MUTE) - Output GPIO - Push-Pull (1 - Headphone On, 0 - HeadPhone Off)
.01072b	8f 2b 11 7f	sta $7f112b	      				STA GP20_REG
.01072f	a9 01		lda #$01	              LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.010731	8f 2f 11 7f	sta $7f112f	              STA GP24_REG
.010735	a9 05		lda #$05	              LDA #$05		;(C256 - MIDI IN) Bit[0] = 1, Bit[2] = 1 (Page 132 Manual)
.010737	8f 30 11 7f	sta $7f1130	              STA GP25_REG
.01073b	a9 84		lda #$84	              LDA #$84		;(C256 - MIDI OUT) Bit[2] = 1, Bit[7] = 1 (Open Drain - To be Checked)
.01073d	8f 31 11 7f	sta $7f1131	              STA GP26_REG
.010741	a9 01		lda #$01	              LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.010743	8f 2f 11 7f	sta $7f112f	              STA GP24_REG
.010747	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 1) Setup as GPIO Input for now
.010749	8f 33 11 7f	sta $7f1133	              STA GP30_REG
.01074d	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 4) Setup as GPIO Input for now
.01074f	8f 34 11 7f	sta $7f1134	              STA GP31_REG
.010753	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 3) Setup as GPIO Input for now
.010755	8f 35 11 7f	sta $7f1135	              STA GP32_REG
.010759	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 6) Setup as GPIO Input for now
.01075b	8f 36 11 7f	sta $7f1136	              STA GP33_REG
.01075f	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 5) Setup as GPIO Input for now
.010761	8f 37 11 7f	sta $7f1137	              STA GP34_REG
.010765	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 8) Setup as GPIO Input for now
.010767	8f 38 11 7f	sta $7f1138	              STA GP35_REG
.01076b	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 7) Setup as GPIO Input for now
.01076d	8f 39 11 7f	sta $7f1139	              STA GP36_REG
.010771	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 10) Setup as GPIO Input for now
.010773	8f 3a 11 7f	sta $7f113a	              STA GP37_REG
.010777	a9 01		lda #$01	              LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.010779	8f 3d 11 7f	sta $7f113d	              STA GP42_REG
.01077d	a9 01		lda #$01	              LDA #$01		;(C256 - INPUT PLL CLK INTERRUPT) Default Value - Will keep it as an input for now, no real usage for now
.01077f	8f 3e 11 7f	sta $7f113e	              STA GP43_REG
.010783	a9 05		lda #$05	              LDA #$05		;(C256 - UART2 - RI2) - Input - Set Secondary Function
.010785	8f 3f 11 7f	sta $7f113f	              STA GP50_REG
.010789	a9 05		lda #$05	              LDA #$05		;(C256 - UART2 - DCD2) - Input - Set Secondary Function
.01078b	8f 40 11 7f	sta $7f1140	              STA GP51_REG
.01078f	a9 05		lda #$05	              LDA #$05		;(C256 - UART2 - RXD2) - Input - Set Secondary Function
.010791	8f 41 11 7f	sta $7f1141	              STA GP52_REG
.010795	a9 04		lda #$04	              LDA #$04		;(C256 - UART2 - TXD2) - Output - Set Secondary Function
.010797	8f 42 11 7f	sta $7f1142	              STA GP53_REG
.01079b	a9 05		lda #$05	              LDA #$05		;(C256 - UART2 - DSR2) - Input - Set Secondary Function
.01079d	8f 43 11 7f	sta $7f1143	              STA GP54_REG
.0107a1	a9 04		lda #$04	              LDA #$04		;(C256 - UART2 - RTS2) - Output - Set Secondary Function
.0107a3	8f 44 11 7f	sta $7f1144	              STA GP55_REG
.0107a7	a9 05		lda #$05	              LDA #$05		;(C256 - UART2 - CTS2) - Input - Set Secondary Function
.0107a9	8f 45 11 7f	sta $7f1145	              STA GP56_REG
.0107ad	a9 04		lda #$04	              LDA #$04		;(C256 - UART2 - DTR2) - Output - Set Secondary Function
.0107af	8f 46 11 7f	sta $7f1146	              STA GP57_REG
.0107b3	a9 84		lda #$84	              LDA #$84		;(C256 - LED1) - Open Drain - Output
.0107b5	8f 47 11 7f	sta $7f1147	              STA GP60_REG
.0107b9	a9 84		lda #$84	              LDA #$84		;(C256 - LED2) - Open Drain - Output
.0107bb	8f 48 11 7f	sta $7f1148	              STA GP61_REG
.0107bf	a9 00		lda #$00	              LDA #$00		;GPIO Data Register (GP10..GP17) - Not Used
.0107c1	8f 4b 11 7f	sta $7f114b	              STA GP1_REG
.0107c5	a9 01		lda #$01	              LDA #$01		;GPIO Data Register (GP20..GP27) - Bit[0] - Headphone Mute (Enabling it)
.0107c7	8f 4c 11 7f	sta $7f114c	              STA GP2_REG
.0107cb	a9 00		lda #$00	              LDA #$00		;GPIO Data Register (GP30..GP37) - Since it is in Output mode, nothing to write here.
.0107cd	8f 4d 11 7f	sta $7f114d	              STA GP3_REG
.0107d1	a9 00		lda #$00	              LDA #$00		;GPIO Data Register (GP40..GP47)  - Not Used
.0107d3	8f 4e 11 7f	sta $7f114e	              STA GP4_REG
.0107d7	a9 00		lda #$00	              LDA #$00		;GPIO Data Register (GP50..GP57)  - Not Used
.0107d9	8f 4f 11 7f	sta $7f114f	              STA GP5_REG
.0107dd	a9 00		lda #$00	              LDA #$00		;GPIO Data Register (GP60..GP61)  - Not Used
.0107df	8f 50 11 7f	sta $7f1150	              STA GP6_REG
.0107e3	a9 01		lda #$01	              LDA #$01		;LED1 Output - Already setup by Vicky Init Phase, for now, I will leave it alone
.0107e5	8f 5d 11 7f	sta $7f115d	              STA LED1_REG
.0107e9	a9 02		lda #$02	              LDA #$02		;LED2 Output - However, I will setup this one, to make sure the Code works (Full On, when Code was ran)
.0107eb	8f 5e 11 7f	sta $7f115e	              STA LED2_REG
.0107ef	c2 20		rep #$20	                REP #$20        ; set A long
.0107f1	68		pla		              PLA
.0107f2	28		plp		              PLP
.0107f3	2b		pld		              PLD
.0107f4	6b		rtl		              RTL
.0107f5	0b		phd		IINITKEYBOARD	PHD
.0107f6	48		pha		                PHA
.0107f7	08		php		                PHP
.0107f8	e2 20		sep #$20	                SEP #$20        ; set A short
.0107fa	af 64 10 7f	lda $7f1064	initkb_loop1	LDA STATUS_PORT		; Load Status Byte
.0107fe	29 02		and #$02	                AND	#INPT_BUF_FULL	; Test bit $02 (if 0, Empty)
.010800	c9 02		cmp #$02	                CMP #INPT_BUF_FULL
.010802	f0 f6		beq $0107fa	                BEQ initkb_loop1
.010804	a9 aa		lda #$aa	                LDA #$0AA			;Send self test command
.010806	8f 64 10 7f	sta $7f1064	                STA KBD_CMD_BUF
.01080a	af 64 10 7f	lda $7f1064	initkb_loop2	LDA STATUS_PORT		; Wait for test to complete
.01080e	29 01		and #$01	                AND	#OUT_BUF_FULL	; Test bit $01 (if 0, Empty)
.010810	c9 01		cmp #$01	                CMP #OUT_BUF_FULL
.010812	f0 f6		beq $01080a	                BEQ initkb_loop2
.010814	af 60 10 7f	lda $7f1060	                LDA KBD_OUT_BUF		;Check self test result
.010818	c9 55		cmp #$55	                CMP #$55
.01081a	d0 74		bne $010890	                BNE	initkb_loop_out
.01081c	a9 ab		lda #$ab	                LDA #$AB			;Send test Interface command
.01081e	8f 60 10 7f	sta $7f1060	                STA KBD_DATA_BUF
.010822	af 64 10 7f	lda $7f1064	initkb_loop3	LDA STATUS_PORT		; Wait for test to complete
.010826	29 01		and #$01	                AND	#OUT_BUF_FULL	; Test bit $01 (if 0, Empty)
.010828	c9 01		cmp #$01	                CMP #OUT_BUF_FULL
.01082a	f0 f6		beq $010822	                BEQ initkb_loop3
.01082c	af 60 10 7f	lda $7f1060	                LDA KBD_OUT_BUF		;Display Interface test results
.010830	c9 00		cmp #$00	                CMP #$00			;Should be 00
.010832	d0 5c		bne $010890	                BNE	initkb_loop_out
.010834	a9 60		lda #$60	                LDA #$60			;Send command byte
.010836	8f 64 10 7f	sta $7f1064	                STA KBD_CMD_BUF
.01083a	af 64 10 7f	lda $7f1064	initkb_loop4	LDA STATUS_PORT		; Load Status Byte
.01083e	29 02		and #$02	                AND	#INPT_BUF_FULL	; Test bit $02 (if 0, Empty)
.010840	c9 02		cmp #$02	                CMP #INPT_BUF_FULL
.010842	f0 f6		beq $01083a	                BEQ initkb_loop4
.010844	a9 69		lda #$69	                LDA #$69		;Send command byte
.010846	8f 60 10 7f	sta $7f1060	                STA KBD_DATA_BUF
.01084a	af 64 10 7f	lda $7f1064	initkb_loop5	LDA STATUS_PORT		; Load Status Byte
.01084e	29 02		and #$02	                AND	#INPT_BUF_FULL	; Test bit $02 (if 0, Empty)
.010850	c9 02		cmp #$02	                CMP #INPT_BUF_FULL
.010852	f0 f6		beq $01084a	                BEQ initkb_loop5
.010854	a9 ff		lda #$ff	                LDA #$FF			; Send Keyboard Reset command
.010856	8f 60 10 7f	sta $7f1060	                STA KBD_DATA_BUF
.01085a	af 64 10 7f	lda $7f1064	initkb_loop6	LDA STATUS_PORT		; Wait for test to complete
.01085e	29 01		and #$01	                AND	#OUT_BUF_FULL	; Test bit $01 (if 0, Empty)
.010860	c9 01		cmp #$01	                CMP #OUT_BUF_FULL
.010862	f0 f6		beq $01085a	                BEQ initkb_loop6
.010864	af 60 10 7f	lda $7f1060	                LDA KBD_OUT_BUF
.010868	a9 ee		lda #$ee	                LDA #$EE			; Send Echo EE Command
.01086a	8f 60 10 7f	sta $7f1060	                STA KBD_DATA_BUF
.01086e	af 64 10 7f	lda $7f1064	initkb_loop7	LDA STATUS_PORT		; Wait for test to complete
.010872	29 01		and #$01	                AND	#OUT_BUF_FULL	; Test bit $01 (if 0, Empty)
.010874	c9 01		cmp #$01	                CMP #OUT_BUF_FULL
.010876	f0 f6		beq $01086e	                BEQ initkb_loop7
.010878	af 60 10 7f	lda $7f1060	                LDA KBD_OUT_BUF		; Read Echo from Keyboard
.01087c	c9 ee		cmp #$ee	                CMP #$EE
.01087e	d0 10		bne $010890	                BNE initkb_loop_out
.010880	a9 f4		lda #$f4	                LDA #$F4			; Enable the Keyboard
.010882	8f 60 10 7f	sta $7f1060	                STA KBD_DATA_BUF
.010886	af 64 10 7f	lda $7f1064	initkb_loop8	LDA STATUS_PORT		; Wait for test to complete
.01088a	29 01		and #$01	                AND	#OUT_BUF_FULL	; Test bit $01 (if 0, Empty)
.01088c	c9 01		cmp #$01	                CMP #OUT_BUF_FULL
.01088e	f0 f6		beq $010886	                BEQ initkb_loop8
.010890	af 60 10 7f	lda $7f1060	initkb_loop_out	LDA KBD_OUT_BUF		; Clear the Output buffer
.010894	c2 20		rep #$20	                REP #$20        ; set A long
.010896	28		plp		                PLP
.010897	68		pla		                PLA
.010898	2b		pld		                PLD
.010899	6b		rtl		                RTL
.01089a	00		brk #		IRESTORE        BRK ; Warm boot routine
.01089b	00		brk #		ISCINIT         BRK ;
.01089c	00		brk #		IIOINIT         BRK ;
.01089d	00		brk #		IPUTBLOCK       BRK ; Ouput a binary block to the currently selected channel
.01089e	00		brk #		ISETLFS         BRK ; Obsolete (done in OPEN)
.01089f	00		brk #		ISETNAM         BRK ; Obsolete (done in OPEN)
.0108a0	00		brk #		IOPEN           BRK ; Open a channel for reading and/or writing. Use SETLFS and SETNAM to set the channels and filename first.
.0108a1	00		brk #		ICLOSE          BRK ; Close a channel
.0108a2	00		brk #		ISETIN          BRK ; Set the current input channel
.0108a3	00		brk #		ISETOUT         BRK ; Set the current output channel
.0108a4	00		brk #		IGETB           BRK ; Get a byte from input channel. Return 0 if no input. Carry is set if no input.
.0108a5	00		brk #		IGETBLOCK       BRK ; Get a X byes from input channel. If Carry is set, wait. If Carry is clear, do not wait.
.0108a6	00		brk #		IGETCH          BRK ; Get a character from the input channel. A=0 and Carry=1 if no data is wating
.0108a7	00		brk #		IGETS           BRK ; Get a string from the input channel. NULL terminates
.0108a8	00		brk #		IGETLINE        BRK ; Get a line of text from input channel. CR or NULL terminates.
.0108a9	00		brk #		IGETFIELD       BRK ; Get a field from the input channel. Value in A, CR, or NULL terminates
.0108aa	00		brk #		ITRIM           BRK ; Removes spaces at beginning and end of string.
.0108ab	00		brk #		IPRINTC         BRK ; Print character to screen. Handles terminal commands
.0108ac	00		brk #		IPRINTS         BRK ; Print string to screen. Handles terminal commands
.0108ad	00		brk #		IPRINTF         BRK ; Print a float value
.0108ae	00		brk #		IPRINTI         BRK ; Prints integer value in TEMP
.0108af	00		brk #		IPRINTAI        BRK ; Prints integer value in A
.0108b0	00		brk #		IPRINTAH        BRK ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
.0108b1	00		brk #		IPUSHKEYS       BRK ;
.0108b2	00		brk #		ICSRLEFT        BRK ;
.0108b3	00		brk #		ICSRHOME        BRK ;
.0108b4	00		brk #		ISCRREADLINE    BRK ; Loads the MCMDADDR/BCMDADDR variable with the address of the current line on the screen. This is called when the RETURN key is pressed and is the first step in processing an immediate mode command.
.0108b5	00		brk #		ISCRGETWORD     BRK ; Read a current word on the screen. A word ends with a space, punctuation (except _), or any control character (value < 32). Loads the address into CMPTEXT_VAL and length into CMPTEXT_LEN variables.
.0108b6					KERNEL_DATA
>0108b6	20 20 20 20 ec a9 ec a9		greet_msg       .text $20, $20, $20, $20, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, "C256 FOENIX DEVELOPMENT SYSTEM",$0D
>0108be	ec a9 ec a9 ec a9 43 32 35 36 20 46 4f 45 4e 49
>0108ce	58 20 44 45 56 45 4c 4f 50 4d 45 4e 54 20 53 59
>0108de	53 54 45 4d 0d
>0108e3	20 20 20 ec a9 ec a9 ec		                .text $20, $20, $20, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $20, "OPEN SOURCE COMPUTER",$0D
>0108eb	a9 ec a9 ec a9 20 4f 50 45 4e 20 53 4f 55 52 43
>0108fb	45 20 43 4f 4d 50 55 54 45 52 0d
>010906	20 20 ec a9 ec a9 ec a9		                .text $20, $20, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $20, $20, "HARDWARE DESIGNER: STEFANY ALLAIRE",$0D
>01090e	ec a9 ec a9 20 20 48 41 52 44 57 41 52 45 20 44
>01091e	45 53 49 47 4e 45 52 3a 20 53 54 45 46 41 4e 59
>01092e	20 41 4c 4c 41 49 52 45 0d
>010937	20 ec a9 ec a9 ec a9 ec		                .text $20, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $20, $20, $20, "SOFTWARE DESIGNER: TOM WILSON",$0D
>01093f	a9 ec a9 20 20 20 53 4f 46 54 57 41 52 45 20 44
>01094f	45 53 49 47 4e 45 52 3a 20 54 4f 4d 20 57 49 4c
>01095f	53 4f 4e 0d
>010963	ec a9 ec a9 ec a9 ec a9		                .text $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $20, $20, $20, $20, "1024KB BASIC RAM  8192K MEDIA RAM",$0D,$00
>01096b	ec a9 20 20 20 20 31 30 32 34 4b 42 20 42 41 53
>01097b	49 43 20 52 41 4d 20 20 38 31 39 32 4b 20 4d 45
>01098b	44 49 41 20 52 41 4d 0d 00
>010994	1d 1d 1d 1d 1d 1d 8d 8d		greet_clr_line1 .byte $1D, $1D, $1D, $1D, $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D
>01099c	4d 4d 2d 2d 5d 5d
>0109a2	1d 1d 1d 1d 1d 8d 8d 4d		greet_clr_line2 .byte $1D, $1D, $1D, $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D, $5D
>0109aa	4d 2d 2d 5d 5d 5d
>0109b0	1d 1d 1d 1d 8d 8d 4d 4d		greet_clr_line3 .byte $1D, $1D, $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D, $5D, $5D
>0109b8	2d 2d 5d 5d 5d 5d
>0109be	1d 1d 1d 8d 8d 4d 4d 2d		greet_clr_line4 .byte $1D, $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D, $5D, $5D, $5D
>0109c6	2d 5d 5d 5d 5d 5d
>0109cc	1d 1d 8d 8d 4d 4d 2d 2d		greet_clr_line5 .byte $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D, $5D, $5D, $5D, $5D
>0109d4	5d 5d 5d 5d 5d 5d
>0109da	00 00 00 ff			fg_color_lut	.byte $00, $00, $00, $FF
>0109de	00 00 c0 ff			                .byte $00, $00, $C0, $FF
>0109e2	00 c0 00 ff			                .byte $00, $C0, $00, $FF
>0109e6	c0 00 00 ff			                .byte $C0, $00, $00, $FF
>0109ea	00 c0 c0 ff			                .byte $00, $C0, $C0, $FF
>0109ee	c0 c0 00 ff			                .byte $C0, $C0, $00, $FF
>0109f2	c0 00 c0 ff			                .byte $C0, $00, $C0, $FF
>0109f6	c0 c0 c0 ff			                .byte $C0, $C0, $C0, $FF
>0109fa	00 7f ff ff			                .byte $00, $7F, $FF, $FF
>0109fe	13 45 8b ff			                .byte $13, $45, $8B, $FF
>010a02	00 00 40 ff			                .byte $00, $00, $40, $FF
>010a06	00 40 00 ff			                .byte $00, $40, $00, $FF
>010a0a	40 00 00 ff			                .byte $40, $00, $00, $FF
>010a0e	40 40 40 ff			                .byte $40, $40, $40, $FF
>010a12	80 80 80 ff			                .byte $80, $80, $80, $FF
>010a16	ff ff ff ff			                .byte $FF, $FF, $FF, $FF
>010a1a	00 00 00 ff			bg_color_lut	.byte $00, $00, $00, $FF
>010a1e	00 00 c0 ff			                .byte $00, $00, $C0, $FF
>010a22	00 c0 00 ff			                .byte $00, $C0, $00, $FF
>010a26	c0 00 00 ff			                .byte $C0, $00, $00, $FF
>010a2a	00 40 40 ff			                .byte $00, $40, $40, $FF
>010a2e	40 40 00 ff			                .byte $40, $40, $00, $FF
>010a32	40 00 40 ff			                .byte $40, $00, $40, $FF
>010a36	40 40 40 ff			                .byte $40, $40, $40, $FF
>010a3a	1e 69 d2 ff			                .byte $1E, $69, $D2, $FF
>010a3e	13 45 8b ff			                .byte $13, $45, $8B, $FF
>010a42	00 00 40 ff			                .byte $00, $00, $40, $FF
>010a46	00 40 00 ff			                .byte $00, $40, $00, $FF
>010a4a	40 00 00 ff			                .byte $40, $00, $00, $FF
>010a4e	20 20 20 ff			                .byte $20, $20, $20, $FF
>010a52	80 80 80 ff			                .byte $80, $80, $80, $FF
>010a56	ff ff ff ff			                .byte $FF, $FF, $FF, $FF
>010a5a	0d 52 45 41 44 59 2e 00		ready_msg       .null $0D,"READY."
>010a62	31 30 20 50 52 49 4e 54		hello_basic     .null "10 PRINT ""Hello World""",$0D
>010a6a	20 22 48 65 6c 6c 6f 20 57 6f 72 6c 64 22 0d 00
>010a7a	52 55 4e 0d 00			                .null "RUN",$0D
>010a7f	48 65 6c 6c 6f 20 57 6f		                .null "Hello World",$0D
>010a87	72 6c 64 0d 00
>010a8c	0d 52 45 41 44 59 2e 00		                .null $0D,"READY."
>010a94	47 20 30 32 30 30 30 30		hello_ml        .null "G 020000",$0D
>010a9c	0d 00
>010a9e	48 45 4c 4c 4f 20 57 4f		                .null "HELLO WORLD",$0D
>010aa6	52 4c 44 0d 00
>010aab	0d 00				                .null $0D
>010aad	20 50 43 20 20 20 20 20		                .null " PC     A    X    Y    SP   DBR DP   NVMXDIZC",$0D
>010ab5	41 20 20 20 20 58 20 20 20 20 59 20 20 20 20 53
>010ac5	50 20 20 20 44 42 52 20 44 50 20 20 20 4e 56 4d
>010ad5	58 44 49 5a 43 0d 00
>010adc	3b 30 30 32 31 31 32 20		                .null ";002112 0019 F0AA 0000 D6FF F8  0000 --M-----"
>010ae4	30 30 31 39 20 46 30 41 41 20 30 30 30 30 20 44
>010af4	36 46 46 20 46 38 20 20 30 30 30 30 20 2d 2d 4d
>010b04	2d 2d 2d 2d 2d 00
>010b0a	41 42 4f 52 54 20 45 52		error_01        .null "ABORT ERROR"
>010b12	52 4f 52 00
>010b16	30 31 32 33 34 35 36 37		hex_digits      .text "0123456789ABCDEF",0
>010b1e	38 39 41 42 43 44 45 46 00

;******  End of listing
