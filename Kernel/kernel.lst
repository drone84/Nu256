
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass --long-address --intel-hex -o kernel.hex --list kernel.lst kernel.asm
; Fri Aug 17 12:32:25 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm


;******  Processing file: macros_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: directpage_inc.asm

=$0000					RESET          = $0000 ;4 Bytes Jumps to the beginning of kernel ROM. ($F8:0000).
=$0004					RETURN         = $0004 ;4 Bytes Called when the RETURN key is pressed in the immediate mode screen. This will process a command in MONITOR, execute a BASIC command, or add a BASIC program line.
=$0008					KEYDOWN        = $0008 ;4 Bytes Custom keyboard handler. This defaults to the kernel keypress handler, but you can redirect this to your own routines. Make sure to JML to the original address at the end of your custom routine. Use this to make F-Key macros or custom keyboard commands.
=$000c					KEYWP          = $000C ;2 Bytes Keyboard buffer next write position.
=$000e					KEYRP          = $000E ;2 Bytes Keyboard buffer next read position. When KEYRP = KEYWP, the buffer is empty. When KEYWP = KEYRP-1, buffer is full.
=$0010					SCREENBEGIN    = $0010 ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$0013					SCRWIDTH       = $0013 ;2 Bytes Width of screen
=$0015					SCRHEIGHT      = $0015 ;2 Bytes Height of screen
=$0017					CURSORPOS      = $0017 ;3 Bytes The next character written to the screen will be written in this location.
=$001a					CURSORX        = $001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$001c					CURSORY        = $001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$001e					CURCOLOR       = $001E ;2 Bytes Color of next character to be printed to the screen.
=$0020					CURATTR        = $0020 ;2 Bytes Attribute of next character to be printed to the screen.
=$0022					STACKBOT       = $0022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$0024					STACKTOP       = $0024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$00f0					SYSPC          = $00F0 ;2 Bytes CPU Program Counter. Stored by BRK. Stores CPU state after ML routine is finished running. These values are also loaded back into the CPU on a BASIC SYS command or MONITOR GO command.
=$00f2					CPUPBR         = $00F2 ;1 Byte  Program Bank
=$00f3					CPUPC          = $00F3 ;2 Bytes Program Counter
=$00f5					CPUFLAGS       = $00F5 ;1 Byte  Flags
=$00f6					CPUA           = $00F6 ;2 Bytes Accumulator
=$00f8					CPUX           = $00F8 ;2 Bytes X Index
=$00fa					CPUY           = $00FA ;2 Bytes Y Index
=$00fc					CPUDBR         = $00FC ;1 Byte  Data Bank
=$00fd					CPUSTACK       = $00FD ;2 Bytes Stack Pointer
=$0100					MCMDADDR       = $0100 ;3 Bytes Address of the current line of text being processed by the MONITOR command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$0103					MCMDLEN        = $0103 ;2 Bytes Length of string being read by the parser. This should be the screen width when in screen memory. Otherwise should be as long as the buffer used to hold the text to parse.
=$0105					MCMDPOS        = $0105 ;3 Bytes Next character being read by the command parser.
=$0108					MCMD           = $0108 ;3 Bytes Address of the command text. The first character is used to decide which function to execute
=$010b					MARG1          = $010B ;3 Bytes Address of the command arguments.
=$010e					MARG2          = $010E ;3 Bytes Address of the command arguments.
=$0111					MARG3          = $0111 ;3 Bytes Address of the command arguments.
=$0114					MARG4          = $0114 ;3 Bytes Address of the command arguments.
=$0117					MARG5          = $0117 ;3 Bytes Address of the command arguments.
=$011a					MARG6          = $011A ;3 Bytes Address of the command arguments.
=$011d					MARG7          = $011D ;3 Bytes Address of the command arguments.
=$100					BCMDADDR       = $100 ;3 Bytes Pointer to current BASIC line on screen
=$1000					SCREEN_PAGE0   = $1000 ;6400 Bytes First page of display RAM. This is used at boot time to display the welcome screen and the BASIC or MONITOR command screens.
=$2900					SCREEN_PAGE1   = $2900 ;6400 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$4200					SCREEN_PAGE2   = $4200 ;6400 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$5b00					SCREEN_PAGE3   = $5B00 ;6400 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$7400					USER_VARIABLES = $7400 ;0 Byte  This space is avaialble for user code and variables, up to the beginning of the stack. Make sure not to write past STACKBOT without adjusting that value.
=$009700				STACK_BEGIN    = $009700 ;16384 Bytes The default beginning of stack space
=$00d6ff				STACK_END      = $00D6FF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ffe4				VECTOR_COP     = $00FFE4 ;2 Bytes
=$00ffe6				VECTOR_BRK     = $00FFE6 ;2 Bytes
=$00ffe8				VECTOR_ABORT   = $00FFE8 ;2 Bytes
=$00ffea				VECTOR_NMI     = $00FFEA ;2 Bytes
=$00fffc				VECTOR_RESET   = $00FFFC ;2 Bytes
=$00ffee				VECTOR_IRQ     = $00FFEE ;2 Bytes
=$00fff4				VECTOR_ECOP    = $00FFF4 ;2 Bytes
=$00fff6				VECTOR_EBRK    = $00FFF6 ;2 Bytes
=$00fff8				VECTOR_EABORT  = $00FFF8 ;2 Bytes
=$00fffa				VECTOR_ENMI    = $00FFFA ;2 Bytes
=$00fffc				VECTOR_ERESET  = $00FFFC ;2 Bytes
=$00fffe				VECTOR_EIRQ    = $00FFFE ;2 Bytes

;******  Return to file: kernel.asm


;******  Processing file: monitor_inc.asm

=$f10000				MONITOR     = $F10000
=$f10004				MBREAK      = $F10004
=$f10008				MSTATUS     = $F10008
=$f1000b				MREADY      = $F1000B
=$f10010				MRETURN		= $F10010
=$f10014				MPARSE      = $F10014

;******  Return to file: kernel.asm

.f80000	5c 03 10 f8	jmp $f81003	BOOT        JML IBOOT
.f81000	4c 03 10	jmp $f81003	IRESET          JMP IBOOT
.f81003					IBOOT
.f81003	18		clc		                CLC           ; clear the carry flag
.f81004	fb		xce		                XCE           ; move carry to emulation flag.
.f81005	c2 10		rep #$10	                REP #$10
.f81007	c2 20		rep #$20	                REP #$20
.f81009	a9 00 00	lda #$0000	                LDA #$0000      ; init direct page
.f8100c	5b		tcd		                TCD
.f8100d	c2 20		rep #$20	                REP #$20
.f8100f	a9 00 10	lda #$1000	                LDA #$1000      ; store the initial screen buffer location
.f81012	85 10		sta $10		                STA SCREENBEGIN
.f81014	e2 20		sep #$20	                SEP #$20
.f81016	a9 00		lda #$00	                LDA #$00
.f81018	85 12		sta $12		                STA SCREENBEGIN+2
.f8101a	c2 20		rep #$20	                REP #$20
.f8101c	a9 00 10	lda #$1000	                LDA #$1000      ; store the initial cursor position
.f8101f	85 17		sta $17		                STA CURSORPOS
.f81021	e2 20		sep #$20	                SEP #$20
.f81023	a9 00		lda #$00	                LDA #$00
.f81025	85 19		sta $19		                STA CURSORPOS+2
.f81027	e2 20		sep #$20	                SEP #$20
.f81029	a9 50		lda #$50	                LDA #80         ; Set screen dimensions
.f8102b	85 13		sta $13		                STA SCRWIDTH
.f8102d	a9 19		lda #$19	                LDA #25
.f8102f	85 15		sta $15		                STA SCRHEIGHT
.f81031					greet
.f81031	08		php		                PHP
.f81032	c2 20		rep #$20	                REP #$20
.f81034	48		pha		                PHA
.f81035	a9 f8 00	lda #$00f8	                LDA #$F8
.f81038	48		pha		                PHA
.f81039	ab		plb		                PLB
.f8103a	68		pla		                PLA
.f8103b	28		plp		                PLP
.f8103c	a2 d8 10	ldx #$10d8	                LDX #<>greet_msg
.f8103f	22 bf 10 f8	jsl $f810bf	                JSL IPUTS       ; print the string
.f81043	a2 f9 10	ldx #$10f9	                LDX #<>greet_msg1
.f81046	22 bf 10 f8	jsl $f810bf	                JSL IPUTS       ; print the string
.f8104a	a2 1f 11	ldx #$111f	                LDX #<>greet_msg2
.f8104d	22 bf 10 f8	jsl $f810bf	                JSL IPUTS       ; print the string
.f81051	e2 20		sep #$20	                SEP #$20
.f81053	a9 01		lda #$01	                LDA #$01        ;set data bank to 1 (Kernel Variables)
.f81055	48		pha		                PHA
.f81056	ab		plb		                PLB
.f81057	ea		nop		waitloop	NOP
.f81058	4c 57 10	jmp $f81057			JMP waitloop
.f8105b	db		stp		                STP
.f8105c	00		brk #		greet_done      BRK             ;halt the CPU
.f8105d	00		brk #		IKEYDOWN        BRK             ; Keyboard key pressed
.f8105e	00		brk #		IRETURN         BRK
.f8105f					IPUTC
.f8105f	08		php		                PHP             ; stash the flags (we'll be changing M)
.f81060	0b		phd		                PHD
.f81061	c2 20		rep #$20	                REP #$20
.f81063	48		pha		                PHA
.f81064	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.f81067	5b		tcd		                TCD             ; and get character back
.f81068	68		pla		                PLA
.f81069	e2 20		sep #$20	                SEP #$20
.f8106b	87 17		sta [$17]	                STA [CURSORPOS] ; Save the character on the screen
.f8106d	22 74 10 f8	jsl $f81074	                JSL ICSRRIGHT
.f81071	2b		pld		                PLD
.f81072	28		plp		                PLP
.f81073	6b		rtl		                RTL
.f81074					ICSRRIGHT
.f81074	8b		phb		                PHB
.f81075	c2 20		rep #$20	                REP #$20
.f81077	c2 10		rep #$10	                REP #$10
.f81079	da		phx		                PHX
.f8107a	c2 20		rep #$20	                REP #$20
.f8107c	48		pha		                PHA
.f8107d	a9 00 00	lda #$0000	                LDA #$0         ; set DP to page 0
.f81080	5b		tcd		                TCD             ; and get character back
.f81081	68		pla		                PLA
.f81082	e6 17		inc $17		                INC CURSORPOS
.f81084	a6 1a		ldx $1a		                LDX CURSORX
.f81086	e8		inx		                INX
.f81087	e4 13		cpx $13		                CPX SCRWIDTH
.f81089	90 0c		bcc $f81097	                BCC icsr_nowrap  ; wrap if the cursor is at or past column 80
.f8108b	a2 00 00	ldx #$0000	                LDX #0
.f8108e	5a		phy		                PHY
.f8108f	a4 1c		ldy $1c		                LDY CURSORY
.f81091	c8		iny		                INY
.f81092	22 9f 10 f8	jsl $f8109f	                JSL ILOCATE
.f81096	7a		ply		                PLY
.f81097	86 1a		stx $1a		icsr_nowrap     STX CURSORX
.f81099	fa		plx		                PLX
.f8109a	ab		plb		                PLB
.f8109b	6b		rtl		                RTL
.f8109c	6b		rtl		ISRLEFT		RTL
.f8109d	6b		rtl		ICSRUP		RTL
.f8109e	6b		rtl		ICSRDOWN	RTL
.f8109f					ILOCATE
.f8109f	8b		phb		                PHB
.f810a0	c2 20		rep #$20	                REP #$20
.f810a2	c2 10		rep #$10	                REP #$10
.f810a4	48		pha		                PHA
.f810a5	5a		phy		                PHY
.f810a6	a5 10		lda $10		                LDA SCREENBEGIN
.f810a8	84 1c		sty $1c		                STY CURSORY
.f810aa	86 1a		stx $1a		                STX CURSORX
.f810ac	c4 13		cpy $13		ilocate_down    CPY SCRWIDTH            ; move the cursor down Y rows
.f810ae	90 07		bcc $f810b7	                BCC ilocate_right
.f810b0	18		clc		                CLC
.f810b1	65 13		adc $13		                ADC SCRWIDTH
.f810b3	88		dey		                DEY
.f810b4	4c ac 10	jmp $f810ac	                JMP ilocate_down
.f810b7	65 1a		adc $1a		ilocate_right   ADC CURSORX             ; move the cursor right X columns
.f810b9	85 17		sta $17		                STA CURSORPOS
.f810bb	7a		ply		ilocate_done    PLY
.f810bc	68		pla		                PLA
.f810bd	ab		plb		                PLB
.f810be	6b		rtl		                RTL
.f810bf					IPUTS
.f810bf	08		php		                PHP
.f810c0	48		pha		                PHA
.f810c1	e2 20		sep #$20	                SEP #$20
.f810c3	c2 10		rep #$10	                REP #$10
.f810c5	bd 00 00	lda $f80000,x	iputs1          LDA $0,b,x ; read from the string
.f810c8	f0 0b		beq $f810d5	                BEQ iputs_done
.f810ca	22 5f 10 f8	jsl $f8105f	                JSL IPUTC
.f810ce	e8		inx		                INX
.f810cf	88		dey		                DEY
.f810d0	f0 03		beq $f810d5	                BEQ iputs_done
.f810d2	4c c5 10	jmp $f810c5	                jmp iputs1
.f810d5	68		pla		iputs_done      PLA
.f810d6	28		plp		                PLP
.f810d7	6b		rtl		                RTL
>f810d8	2a 2a 2f 2f 2f 2f 2f 20		greet_msg       .text "**///// NU64 DEVELOPMENT SYSTEM",$0d,$00
>f810e0	4e 55 36 34 20 44 45 56 45 4c 4f 50 4d 45 4e 54
>f810f0	20 53 59 53 54 45 4d 0d 00
>f810f9	2a 2f 2f 2f 2f 2f 2a 20		greet_msg1      .text "*/////* NU64 BASIC (Not Implemented)",$0d,$00
>f81101	4e 55 36 34 20 42 41 53 49 43 20 28 4e 6f 74 20
>f81111	49 6d 70 6c 65 6d 65 6e 74 65 64 29 0d 00
>f8111f	2f 2f 2f 2f 2f 2a 2a 20		greet_msg2      .text "/////** Machine Monitor v0.1 (dev)",$0d,$00
>f81127	4d 61 63 68 69 6e 65 20 4d 6f 6e 69 74 6f 72 20
>f81137	76 30 2e 31 20 28 64 65 76 29 0d 00

;******  End of listing
