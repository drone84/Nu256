
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass --long-address --intel-hex -o kernel.hex --list kernel.lst kernel.asm
; Wed Oct 03 11:22:00 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm


;******  Processing file: macros_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: simulator_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: page_00_inc.asm

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;2 Bytes Color of next character to be printed to the screen.
=$000020				CURATTR          = $000020 ;2 Bytes Attribute of next character to be printed to the screen.
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$0000d0				KERNEL_TEMP      = $0000D0 ;32 Bytes Temp space for kernel
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000108				DIVIDER_0        = $000108 ;0 Byte  Unsigned divider
=$000108				D0_OPERAND_A     = $000108 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$00010a				D0_OPERAND_B     = $00010A ;2 Bytes Divider 0 Divisor ex B in A/B
=$00010c				D0_RESULT        = $00010C ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$00010e				D0_REMAINDER     = $00010E ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000110				DIVIDER_1        = $000110 ;0 Byte  Signed divider
=$000110				D1_OPERAND_A     = $000110 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$000112				D1_OPERAND_B     = $000112 ;2 Bytes Divider 1 Divisor ex B in A/B
=$000114				D1_RESULT        = $000114 ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D1_REMAINDER     = $000116 ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$0001ff				VECTOR_STATE     = $0001FF ;1 Byte  Interrupt Vector State. See VECTOR_STATE_ENUM
=$000200				CPU_REGISTERS    = $000200 ; Byte
=$000200				CPUPC            = $000200 ;2 Bytes Program Counter (PC)
=$000202				CPUPBR           = $000202 ;2 Bytes Program Bank Register (K)
=$000204				CPUA             = $000204 ;2 Bytes Accumulator (A)
=$000206				CPUX             = $000206 ;2 Bytes X Register (X)
=$000208				CPUY             = $000208 ;2 Bytes Y Register (Y)
=$00020a				CPUSTACK         = $00020A ;2 Bytes Stack Pointer (S)
=$00020c				CPUDP            = $00020C ;2 Bytes Direct Page Register (D)
=$00020e				CPUDBR           = $00020E ;1 Byte  Data Bank Register (B)
=$00020f				CPUFLAGS         = $00020F ;1 Byte  Flags (P)
=$000210				MONITOR_VARS     = $000210 ; Byte  MONITOR Variables. BASIC variables may overlap this space
=$000210				MCMDADDR         = $000210 ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$000213				MCMP_TEXT        = $000213 ;3 Bytes Address of symbol being evaluated for COMPARE routine
=$000216				MCMP_LEN         = $000216 ;2 Bytes Length of symbol being evaluated for COMPARE routine
=$000218				MCMD             = $000218 ;3 Bytes Address of the current command/function string
=$00021b				MCMD_LEN         = $00021B ;2 Bytes Length of the current command/function string
=$00021d				MARG1            = $00021D ;4 Bytes First command argument. May be data or address, depending on command
=$000221				MARG2            = $000221 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000225				MARG3            = $000225 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000229				MARG4            = $000229 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$00022d				MARG5            = $00022D ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000231				MARG6            = $000231 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000235				MARG7            = $000235 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000239				MARG8            = $000239 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000f00				KEY_BUFFER       = $000F00 ;64 Bytes keyboard buffer
=$40					KEY_BUFFER_SIZE  = $40 ;64 Bytes (constant) keyboard buffer length
=$000f3f				KEY_BUFFER_END   = $000F3F ;1 Byte  Last byte of keyboard buffer
=$000f40				KEY_BUFFER_RPOS  = $000F40 ;2 Bytes keyboard buffer read position
=$000f42				KEY_BUFFER_WPOS  = $000F42 ;2 Bytes keyboard buffer write position
=$001000				TEST_BEGIN       = $001000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ff00				ISR_BEGIN        = $00FF00 ; Byte  Beginning of CPU vectors in Direct page
=$00ff00				HRESET           = $00FF00 ;16 Bytes Handle RESET asserted. Reboot computer and re-initialize the kernel.
=$00ff10				HCOP             = $00FF10 ;16 Bytes Handle the COP instruction. Program use; not used by OS
=$00ff20				HBRK             = $00FF20 ;16 Bytes Handle the BRK instruction. Returns to BASIC Ready prompt.
=$00ff30				HABORT           = $00FF30 ;16 Bytes Handle ABORT asserted. Return to Ready prompt with an error message.
=$00ff40				HNMI             = $00FF40 ;32 Bytes Handle NMI
=$00ff60				HIRQ             = $00FF60 ;32 Bytes Handle IRQ
=$00ff80				Unused_FF80      = $00FF80 ;End of direct page Interrrupt handlers
=$00ffe0				VECTORS_BEGIN    = $00FFE0 ;0 Byte  Interrupt vectors
=$00ffe0				JMP_READY        = $00FFE0 ;4 Bytes Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$00ffe4				VECTOR_COP       = $00FFE4 ;2 Bytes Native COP Interrupt vector
=$00ffe6				VECTOR_BRK       = $00FFE6 ;2 Bytes Native BRK Interrupt vector
=$00ffe8				VECTOR_ABORT     = $00FFE8 ;2 Bytes Native ABORT Interrupt vector
=$00ffea				VECTOR_NMI       = $00FFEA ;2 Bytes Native NMI Interrupt vector
=$00ffec				VECTOR_RESET     = $00FFEC ;2 Bytes Unused (Native RESET vector)
=$00ffee				VECTOR_IRQ       = $00FFEE ;2 Bytes Native IRQ Vector
=$00fff0				RETURN           = $00FFF0 ;4 Bytes RETURN key handler. Points to BASIC or MONITOR subroutine to execute when RETURN is pressed.
=$00fff4				VECTOR_ECOP      = $00FFF4 ;2 Bytes Emulation mode interrupt handler
=$00fff6				VECTOR_EBRK      = $00FFF6 ;2 Bytes Emulation mode interrupt handler
=$00fff8				VECTOR_EABORT    = $00FFF8 ;2 Bytes Emulation mode interrupt handler
=$00fffa				VECTOR_ENMI      = $00FFFA ;2 Bytes Emulation mode interrupt handler
=$00fffc				VECTOR_ERESET    = $00FFFC ;2 Bytes Emulation mode interrupt handler
=$00fffe				VECTOR_EIRQ      = $00FFFE ;2 Bytes Emulation mode interrupt handler
=$010000				VECTORS_END      = $010000 ;*End of vector space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: kernel.asm


;******  Processing file: page_00_data.asm

>0000	00 00 00 00 00 00 00 00		                .fill 12,0          ; unused_0000, 12 bytes, unused
>0008	00 00 00 00
>000c	00 00 80			                .long $800000       ; SCREENBEGIN, 3 bytes, Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
>000f	50 00				                .word 80            ; COLS_VISIBLE, 2 bytes, Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
>0011	80 00				                .word 128           ; COLS_PER_LINE, 2 bytes, Columns in memory per screen line. A virtual line can be this long. Default=128
>0013	3c 00				                .word 60            ; LINES_VISIBLE, 2 bytes, The number of rows visible on the screen. Default=25
>0015	40 00				                .word 64            ; LINES_MAX, 2 bytes, The number of rows in memory for the screen. Default=64
>0017	00 00 80			                .long $800000       ; CURSORPOS, 3 bytes, The next character written to the screen will be written in this location.
>001a	00 00				                .word 0             ; CURSORX, 2 bytes, This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
>001c	00 00				                .word 0             ; CURSORY, 2 bytes, This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
>001e	0f				                .byte $0F           ; CURCOLOR, 2 bytes, Color of next character to be printed to the screen.
>001f	00				                .byte $00           ; CURATTR, 2 bytes, Attribute of next character to be printed to the screen.
>0020	00 80				                .word STACK_BEGIN   ; STACKBOT, 2 bytes, Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
>0022	ff fe				                .word STACK_END     ; STACKTOP, 2 bytes, Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.

;******  Return to file: kernel.asm


;******  Processing file: page_00_code.asm

.ff00	18		clc		RHRESET         CLC
.ff01	fb		xce		                XCE
.ff02	5c 00 00 01	jmp $010000	                JML BOOT
.ff10					RHCOP
.ff10	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff12	8b		phb		                PHB
.ff13	0b		phd		                PHD
.ff14	48		pha		                PHA
.ff15	da		phx		                PHX
.ff16	5a		phy		                PHY
.ff17	5c 08 00 01	jmp $010008	                JML BREAK
.ff20					RHBRK
.ff20	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff22	8b		phb		                PHB
.ff23	0b		phd		                PHD
.ff24	48		pha		                PHA
.ff25	da		phx		                PHX
.ff26	5a		phy		                PHY
.ff27	5c 08 00 01	jmp $010008	                JML BREAK
.ff30					RHABORT
.ff30	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff32	8b		phb		                PHB
.ff33	0b		phd		                PHD
.ff34	48		pha		                PHA
.ff35	da		phx		                PHX
.ff36	5a		phy		                PHY
.ff37	5c 08 00 01	jmp $010008	                JML BREAK
.ff40					 RHNMI
.ff40	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff42	8b		phb		                PHB
.ff43	0b		phd		                PHD
.ff44	48		pha		                PHA
.ff45	da		phx		                PHX
.ff46	5a		phy		                PHY
.ff47	7a		ply		                PLY
.ff48	fa		plx		                PLX
.ff49	68		pla		                PLA
.ff4a	2b		pld		                PLD
.ff4b	ab		plb		                PLB
.ff4c	40		rti		                RTI
.ff60					RHIRQ
.ff60	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff62	8b		phb		                PHB
.ff63	0b		phd		                PHD
.ff64	48		pha		                PHA
.ff65	da		phx		                PHX
.ff66	5a		phy		                PHY
.ff67	7a		ply		                PLY
.ff68	fa		plx		                PLX
.ff69	68		pla		                PLA
.ff6a	2b		pld		                PLD
.ff6b	ab		plb		                PLB
.ff6c	40		rti		                RTI
.ffe0	5c 66 80 01	jmp $018066	JUMP_READY      JML IMREADY     ; Kernel READY routine. Rewrite this address to jump to a custom kernel.
>ffe4	10 ff				RVECTOR_COP     .word HCOP     ; FFE4
>ffe6	20 ff				RVECTOR_BRK     .word HBRK     ; FFE6
>ffe8	30 ff				RVECTOR_ABORT   .word HABORT   ; FFE8
>ffea	40 ff				RVECTOR_NMI     .word HNMI     ; FFEA
>ffec	00 00				                .word $0000    ; FFEC
>ffee	60 ff				RVECTOR_IRQ     .word HIRQ     ; FFEE
.fff0	5c d1 04 01	jmp $0104d1	RRETURN         JML IRETURN
>fff4	10 ff				RVECTOR_ECOP    .word HCOP     ; FFF4
>fff6	20 ff				RVECTOR_EBRK    .word HBRK     ; FFF6
>fff8	30 ff				RVECTOR_EABORT  .word HABORT   ; FFF8
>fffa	40 ff				RVECTOR_ENMI    .word HNMI     ; FFFA
>fffc	00 ff				RVECTOR_ERESET  .word HRESET   ; FFFC
>fffe	60 ff				RVECTOR_EIRQ    .word HIRQ     ; FFFE

;******  Return to file: kernel.asm


;******  Processing file: dram_inc.asm

=$800000				SCREEN_PAGE0     = $800000 ;8192 Bytes First page of display RAM. This is used at boot time to display the welcome screen and the BASIC or MONITOR command screens.
=$802000				SCREEN_PAGE1     = $802000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$804000				SCREEN_PAGE2     = $804000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$806000				SCREEN_PAGE3     = $806000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$808000				SCREEN_END       = $808000 ;End of display memory

;******  Return to file: kernel.asm


;******  Processing file: monitor.asm

.018000	5c 5c 80 01	jmp $01805c	MONITOR         JML IMONITOR
.018004	5c 88 80 01	jmp $018088	MSTATUS         JML IMSTATUS
.018008	5c 66 80 01	jmp $018066	MREADY          JML IMREADY
.01800c	5c 33 81 01	jmp $018133	MRETURN         JML IMRETURN
.018010	5c 34 81 01	jmp $018134	MPARSE          JML IMPARSE
.018014	5c 35 81 01	jmp $018135	MPARSE1         JML IMPARSE1
.018018	5c 36 81 01	jmp $018136	MEXECUTE        JML IMEXECUTE
.01801c	5c 37 81 01	jmp $018137	MASSEMBLE       JML IMASSEMBLE
.018020	5c 38 81 01	jmp $018138	MASSEMBLEA      JML IMASSEMBLEA
.018024	5c 39 81 01	jmp $018139	MCOMPARE        JML IMCOMPARE
.018028	5c 3a 81 01	jmp $01813a	MDISASSEMBLE    JML IMDISASSEMBLE
.01802c	5c 3b 81 01	jmp $01813b	MFILL           JML IMFILL
.018030	5c 3d 81 01	jmp $01813d	MJUMP           JML IMJUMP
.018034	5c 3e 81 01	jmp $01813e	MHUNT           JML IMHUNT
.018038	5c 3f 81 01	jmp $01813f	MLOAD           JML IMLOAD
.01803c	5c 40 81 01	jmp $018140	MMEMORY         JML IMMEMORY
.018040	5c 41 81 01	jmp $018141	MREGISTERS      JML IMREGISTERS
.018044	5c 42 81 01	jmp $018142	MSAVE           JML IMSAVE
.018048	5c 43 81 01	jmp $018143	MTRANSFER       JML IMTRANSFER
.01804c	5c 44 81 01	jmp $018144	MVERIFY         JML IMVERIFY
.018050	5c 45 81 01	jmp $018145	MEXIT           JML IMEXIT
.018054	5c 46 81 01	jmp $018146	MMODIFY         JML IMMODIFY
.018058	5c 47 81 01	jmp $018147	MDOS            JML IMDOS
.01805c	18		clc		IMONITOR        CLC           ; clear the carry flag
.01805d	fb		xce		                XCE           ; move carry to emulation flag.
.01805e	a9 ff fe	lda #$feff	                LDA #STACK_END ; Reset the stack
.018061	1b		tcs		                TAS
.018062	5c 66 80 01	jmp $018066	                JML IMREADY
.018066					IMREADY
.018066	c2 30		rep #$30	                REP #$30        ; set A&X long
.018068	a9 66 80	lda #$8066	                LDA #<>IMREADY
.01806b	8d e1 ff	sta $ffe1	                STA JMP_READY+1
.01806e	e2 20		sep #$20	                SEP #$20        ; set A short
.018070	a9 01		lda #$01	                LDA #`IMREADY
.018072	8d e3 ff	sta $ffe3	                STA JMP_READY+3
.018075	c2 20		rep #$20	                REP #$20        ; set A long
.018077	a9 33 81	lda #$8133	                LDA #<>IMRETURN
.01807a	8d f1 ff	sta $fff1	                STA RETURN+1
.01807d	e2 20		sep #$20	                SEP #$20        ; set A short
.01807f	a9 01		lda #$01	                LDA #`IMRETURN
.018081	8d f3 ff	sta $fff3	                STA RETURN+3
.018084	5c 88 80 01	jmp $018088	                JML IMSTATUS
.018088					IMSTATUS
.018088	48		pha		                PHA             ; begin setdbr macro
.018089	08		php		                PHP
.01808a	e2 20		sep #$20	                SEP #$20        ; set A short
.01808c	a9 01		lda #$01		LDA #`mregisters_msg
.01808e	48		pha		                PHA
.01808f	ab		plb		                PLB
.018090	28		plp		                PLP
.018091	68		pla		                PLA             ; end setdbr macro
.018092	a2 48 81	ldx #$8148	                LDX #<>mregisters_msg
.018095	22 0c 05 01	jsl $01050c	                JSL IPRINT
.018099	e2 20		sep #$20	                SEP #$20        ; set A short
.01809b	a9 3b		lda #$3b	                LDA #';'
.01809d	22 2c 05 01	jsl $01052c	                JSL IPUTC
.0180a1	c2 30		rep #$30	                REP #$30        ; set A&X long
.0180a3	48		pha		                PHA             ; begin setdbr macro
.0180a4	08		php		                PHP
.0180a5	e2 20		sep #$20	                SEP #$20        ; set A short
.0180a7	a9 00		lda #$00		LDA #$0
.0180a9	48		pha		                PHA
.0180aa	ab		plb		                PLB
.0180ab	28		plp		                PLP
.0180ac	68		pla		                PLA             ; end setdbr macro
.0180ad	a0 03 00	ldy #$0003	                LDY #3
.0180b0	a2 02 02	ldx #$0202	                LDX #CPUPC+2
.0180b3	22 ee 05 01	jsl $0105ee	                JSL IPRINTH
.0180b7	a5 20		lda $20		                LDA ' '
.0180b9	22 2c 05 01	jsl $01052c	                JSL IPUTC
.0180bd	a0 02 00	ldy #$0002	                LDY #2
.0180c0	a2 05 02	ldx #$0205	                LDX #CPUA+1
.0180c3	22 ee 05 01	jsl $0105ee	                JSL IPRINTH
.0180c7	a5 20		lda $20		                LDA ' '
.0180c9	22 2c 05 01	jsl $01052c	                JSL IPUTC
.0180cd	a0 02 00	ldy #$0002	                LDY #2
.0180d0	a2 07 02	ldx #$0207	                LDX #CPUX+1
.0180d3	22 ee 05 01	jsl $0105ee	                JSL IPRINTH
.0180d7	a5 20		lda $20		                LDA ' '
.0180d9	22 2c 05 01	jsl $01052c	                JSL IPUTC
.0180dd	a0 02 00	ldy #$0002	                LDY #2
.0180e0	a2 09 02	ldx #$0209	                LDX #CPUY+1
.0180e3	22 ee 05 01	jsl $0105ee	                JSL IPRINTH
.0180e7	a5 20		lda $20		                LDA ' '
.0180e9	22 2c 05 01	jsl $01052c	                JSL IPUTC
.0180ed	a0 02 00	ldy #$0002	                LDY #2
.0180f0	a2 0b 02	ldx #$020b	                LDX #CPUSTACK+1
.0180f3	22 ee 05 01	jsl $0105ee	                JSL IPRINTH
.0180f7	a5 20		lda $20		                LDA ' '
.0180f9	22 2c 05 01	jsl $01052c	                JSL IPUTC
.0180fd	a0 01 00	ldy #$0001	                LDY #1
.018100	a2 0e 02	ldx #$020e	                LDX #CPUDBR
.018103	22 ee 05 01	jsl $0105ee	                JSL IPRINTH
.018107	a5 20		lda $20		                LDA ' '
.018109	22 2c 05 01	jsl $01052c	                JSL IPUTC
.01810d	22 2c 05 01	jsl $01052c	                JSL IPUTC
.018111	a0 02 00	ldy #$0002	                LDY #2
.018114	a2 0d 02	ldx #$020d	                LDX #CPUDP+1
.018117	22 ee 05 01	jsl $0105ee	                JSL IPRINTH
.01811b	a5 20		lda $20		                LDA ' '
.01811d	22 2c 05 01	jsl $01052c	                JSL IPUTC
.018121	a0 01 00	ldy #$0001	                LDY #1
.018124	a2 0f 02	ldx #$020f	                LDX #CPUFLAGS
.018127	22 ee 05 01	jsl $0105ee	                JSL IPRINTH
.01812b	22 5a 05 01	jsl $01055a	                JSL IPRINTCR
.01812f	5c ca 04 01	jmp $0104ca	                JML IREADYWAIT
.018133	6b		rtl		IMRETURN        RTL ; Handle RETURN key (ie: execute command)
.018134	00		brk #		IMPARSE         BRK ; Parse the current command line
.018135	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.018136	00		brk #		IMEXECUTE       BRK ; Execute the current command line (requires MCMD and MARG1-MARG8 to be populated)
.018137	00		brk #		IMASSEMBLE      BRK ; Assemble a line of text.
.018138	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.018139	00		brk #		IMCOMPARE       BRK ; Compare memory. len=1
.01813a	00		brk #		IMDISASSEMBLE   BRK ; Disassemble memory. end=1 instruction
.01813b	00		brk #		IMFILL          BRK ; Fill memory with specified value. Start and end must be in the same bank.
.01813c	00		brk #		IMGO            BRK ; Execute from specified address
.01813d	00		brk #		IMJUMP          BRK ; Execute from spefified address
.01813e	00		brk #		IMHUNT          BRK ; Hunt (find) value in memory
.01813f	00		brk #		IMLOAD          BRK ; Load data from disk. Device=1 (internal floppy) Start=Address in file
.018140	00		brk #		IMMEMORY        BRK ; View memory
.018141	00		brk #		IMREGISTERS     BRK ; View/edit registers
.018142	00		brk #		IMSAVE          BRK ; Save memory to disk
.018143	00		brk #		IMTRANSFER      BRK ; Transfer (copy) data in memory
.018144	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.018145	00		brk #		IMEXIT          BRK ; Exit monitor and return to BASIC command prompt
.018146	00		brk #		IMMODIFY        BRK ; Modify memory
.018147	00		brk #		IMDOS           BRK ; Execute DOS command
.018148					MMESSAGES
>018148					MMERROR         .text
>018148	0d 20 50 43 20 20 20 20		mregisters_msg  .null $0D," PC     A    X    Y    SP   DBR DP   NVMXDIZC"
>018150	20 41 20 20 20 20 58 20 20 20 20 59 20 20 20 20
>018160	53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e 56
>018170	4d 58 44 49 5a 43 00

;******  Return to file: kernel.asm


;******  Processing file: kernel_jumptable.asm

.010000	5c 00 04 01	jmp $010400	BOOT            JML IBOOT
.010004	5c 1c 06 01	jmp $01061c	RESTORE         JML IRESTORE
.010008	5c 70 04 01	jmp $010470	BREAK           JML IBREAK
.01000c	5c b7 04 01	jmp $0104b7	READY           JML IREADY
.010010	5c 1d 06 01	jmp $01061d	SCINIT          JML ISCINIT
.010014	5c 1e 06 01	jmp $01061e	IOINIT          JML IIOINIT
.010018	5c 2c 05 01	jmp $01052c	PUTC            JML IPUTC
.01001c	5c 15 05 01	jmp $010515	PUTS            JML IPUTS
.010020	5c 59 05 01	jmp $010559	PUTB            JML IPUTB
.010024	5c 1f 06 01	jmp $01061f	PUTBLOCK        JML IPUTBLOCK
.010028	5c 20 06 01	jmp $010620	SETLFS          JML ISETLFS
.01002c	5c 21 06 01	jmp $010621	SETNAM          JML ISETNAM
.010030	5c 22 06 01	jmp $010622	OPEN            JML IOPEN
.010034	5c 23 06 01	jmp $010623	CLOSE           JML ICLOSE
.010038	5c 24 06 01	jmp $010624	SETIN           JML ISETIN
.01003c	5c 25 06 01	jmp $010625	SETOUT          JML ISETOUT
.010040	5c 26 06 01	jmp $010626	GETB            JML IGETB
.010044	5c 27 06 01	jmp $010627	GETBLOCK        JML IGETBLOCK
.010048	5c 28 06 01	jmp $010628	GETCH           JML IGETCH
.01004c	5c db 04 01	jmp $0104db	GETCHW          JML IGETCHW
.010050	5c d2 04 01	jmp $0104d2	GETCHE          JML IGETCHE
.010054	5c 29 06 01	jmp $010629	GETS            JML IGETS
.010058	5c 2a 06 01	jmp $01062a	GETLINE         JML IGETLINE
.01005c	5c 2b 06 01	jmp $01062b	GETFIELD        JML IGETFIELD
.010060	5c 2c 06 01	jmp $01062c	TRIM            JML ITRIM
.010064	5c 2d 06 01	jmp $01062d	PRINTC          JML IPRINTC
.010068	5c 2e 06 01	jmp $01062e	PRINTS          JML IPRINTS
.01006c	5c 5a 05 01	jmp $01055a	PRINTCR         JML IPRINTCR
.010070	5c 2f 06 01	jmp $01062f	PRINTF          JML IPRINTF
.010074	5c 30 06 01	jmp $010630	PRINTI          JML IPRINTI
.010078	5c ee 05 01	jmp $0105ee	PRINTH          JML IPRINTH
.01007c	5c 31 06 01	jmp $010631	PRINTAI         JML IPRINTAI
.010080	5c 32 06 01	jmp $010632	PRINTAH         JML IPRINTAH
.010084	5c a8 05 01	jmp $0105a8	LOCATE          JML ILOCATE
.010088	5c 33 06 01	jmp $010633	PUSHKEY         JML IPUSHKEY
.01008c	5c 34 06 01	jmp $010634	PUSHKEYS        JML IPUSHKEYS
.010090	5c 7b 05 01	jmp $01057b	CSRRIGHT        JML ICSRRIGHT
.010094	5c 35 06 01	jmp $010635	CSRLEFT         JML ICSRLEFT
.010098	5c a6 05 01	jmp $0105a6	CSRUP           JML ICSRUP
.01009c	5c a7 05 01	jmp $0105a7	CSRDOWN         JML ICSRDOWN
.0100a0	5c 36 06 01	jmp $010636	CSRHOME         JML ICSRHOME
.0100a4	5c d4 05 01	jmp $0105d4	SCROLLUP        JML ISCROLLUP

;******  Return to file: kernel.asm

.010400					IBOOT
.010400	18		clc		                CLC           ; clear the carry flag
.010401	fb		xce		                XCE           ; move carry to emulation flag.
.010402	c2 30		rep #$30	                REP #$30        ; set A&X long
.010404	a9 ff fe	lda #$feff	                LDA #STACK_END   ; initialize stack pointer
.010407	1b		tcs		                TAS
.010408	48		pha		                PHA             ; begin setdp macro
.010409	08		php			PHP
.01040a	c2 20		rep #$20	                REP #$20        ; set A long
.01040c	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.01040f	5b		tcd		                TCD
.010410	28		plp			PLP
.010411	68		pla		                PLA             ; end setdp macro
.010412	a9 00 00	lda #$0000	                LDA #<>SCREEN_PAGE0      ; store the initial screen buffer location
.010415	85 0c		sta $0c		                STA SCREENBEGIN
.010417	e2 20		sep #$20	                SEP #$20        ; set A short
.010419	a9 80		lda #$80	                LDA #`SCREEN_PAGE0
.01041b	85 0e		sta $0e		                STA SCREENBEGIN+2
.01041d	c2 30		rep #$30	                REP #$30        ; set A&X long
.01041f	a9 00 00	lda #$0000	                LDA #<>SCREEN_PAGE0      ; store the initial screen buffer location
.010422	85 17		sta $17		                STA CURSORPOS
.010424	e2 20		sep #$20	                SEP #$20        ; set A short
.010426	a9 80		lda #$80	                LDA #`SCREEN_PAGE0
.010428	85 19		sta $19		                STA CURSORPOS+2
.01042a	c2 30		rep #$30	                REP #$30        ; set A&X long
.01042c	a2 50 00	ldx #$0050	                LDX #80
.01042f	86 0f		stx $0f		                STX COLS_VISIBLE
.010431	a0 3c 00	ldy #$003c	                LDY #60
.010434	84 13		sty $13		                STY LINES_VISIBLE
.010436	a2 80 00	ldx #$0080	                LDX #128
.010439	86 11		stx $11		                STX COLS_PER_LINE
.01043b	a0 40 00	ldy #$0040	                LDY #64
.01043e	84 15		sty $15		                STY LINES_MAX
.010440	c2 20		rep #$20	                REP #$20        ; set A long
.010442	a2 00 00	ldx #$0000	                LDX #$0
.010445	a0 00 00	ldy #$0000	                LDY #$0
.010448	22 a8 05 01	jsl $0105a8	                JSL ILOCATE
.01044c	9c 40 0f	stz $0f40	                STZ KEY_BUFFER_RPOS
.01044f	9c 42 0f	stz $0f42	                STZ KEY_BUFFER_WPOS
.010452					greet
.010452	48		pha		                PHA             ; begin setdbr macro
.010453	08		php		                PHP
.010454	e2 20		sep #$20	                SEP #$20        ; set A short
.010456	a9 01		lda #$01		LDA #`greet_msg
.010458	48		pha		                PHA
.010459	ab		plb		                PLB
.01045a	28		plp		                PLP
.01045b	68		pla		                PLA             ; end setdbr macro
.01045c	a2 39 06	ldx #$0639	                LDX #<>greet_msg
.01045f	22 0c 05 01	jsl $01050c	                JSL IPRINT       ; print the first line
.010463	e2 20		sep #$20	                SEP #$20        ; set A short
.010465	48		pha		                PHA             ; begin setdbr macro
.010466	08		php		                PHP
.010467	e2 20		sep #$20	                SEP #$20        ; set A short
.010469	a9 01		lda #$01		LDA #$01
.01046b	48		pha		                PHA
.01046c	ab		plb		                PLB
.01046d	28		plp		                PLP
.01046e	68		pla		                PLA             ; end setdbr macro
.01046f	00		brk #		greet_done      BRK             ;Terminate boot routine and go to Ready handler.
.010470					IBREAK
.010470	48		pha		                PHA             ; begin setdp macro
.010471	08		php			PHP
.010472	c2 20		rep #$20	                REP #$20        ; set A long
.010474	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.010477	5b		tcd		                TCD
.010478	28		plp			PLP
.010479	68		pla		                PLA             ; end setdp macro
.01047a	68		pla		                PLA             ; Pull .Y and stuff it in the CPUY variable
.01047b	8f 08 02 00	sta $000208	                STA CPUY
.01047f	68		pla		                PLA             ; Pull .X and stuff it in the CPUY variable
.010480	8f 06 02 00	sta $000206	                STA CPUX
.010484	68		pla		                PLA             ; Pull .A and stuff it in the CPUY variable
.010485	8f 04 02 00	sta $000204	                STA CPUA
.010489	68		pla		                PLA
.01048a	8f 0c 02 00	sta $00020c	                STA CPUDP       ; Pull Direct page
.01048e	e2 20		sep #$20	                SEP #$20        ; set A short
.010490	68		pla		                PLA             ; Pull Data Bank (8 bits)
.010491	8f 0e 02 00	sta $00020e	                STA CPUDBR
.010495	68		pla		                PLA             ; Pull Flags (8 bits)
.010496	8f 0f 02 00	sta $00020f	                STA CPUFLAGS
.01049a	c2 20		rep #$20	                REP #$20        ; set A long
.01049c	68		pla		                PLA             ; Pull Program Counter (16 bits)
.01049d	8f 00 02 00	sta $000200	                STA CPUPC
.0104a1	e2 20		sep #$20	                SEP #$20        ; set A short
.0104a3	68		pla		                PLA             ; Pull Program Bank (8 bits)
.0104a4	8f 02 02 00	sta $000202	                STA CPUPBR
.0104a8	c2 20		rep #$20	                REP #$20        ; set A long
.0104aa	3b		tsc		                TSA             ; Get the stack
.0104ab	8f 0a 02 00	sta $00020a	                STA CPUSTACK    ; Store the stack at immediately before the interrupt was asserted
.0104af	a9 ff fe	lda #$feff	                LDA #<>STACK_END   ; initialize stack pointer back to the bootup value
.0104b2	1b		tcs		                TAS
.0104b3	5c e0 ff 00	jmp $00ffe0	                JML JMP_READY   ; Run READY routine (usually BASIC or MONITOR)
.0104b7					IREADY
.0104b7	48		pha		                PHA             ; begin setdbr macro
.0104b8	08		php		                PHP
.0104b9	e2 20		sep #$20	                SEP #$20        ; set A short
.0104bb	a9 01		lda #$01		LDA #`ready_msg
.0104bd	48		pha		                PHA
.0104be	ab		plb		                PLB
.0104bf	28		plp		                PLP
.0104c0	68		pla		                PLA             ; end setdbr macro
.0104c1	e2 20		sep #$20	                SEP #$20        ; set A short
.0104c3	a2 db 06	ldx #$06db	                LDX #<>ready_msg
.0104c6	22 0c 05 01	jsl $01050c	                JSL IPRINT
.0104ca					IREADYWAIT
.0104ca	22 d2 04 01	jsl $0104d2	                JSL IGETCHE
.0104ce	80 fa		bra $0104ca	                BRA IREADYWAIT
.0104d0	db		stp		IKEYDOWN        STP             ; Keyboard key pressed
.0104d1	db		stp		IRETURN         STP
.0104d2	22 db 04 01	jsl $0104db	IGETCHE         JSL IGETCHW
.0104d6	22 2c 05 01	jsl $01052c	                JSL IPUTC
.0104da	6b		rtl		                RTL
.0104db	0b		phd		IGETCHW         PHD
.0104dc	da		phx		                PHX
.0104dd	08		php		                PHP
.0104de	48		pha		                PHA             ; begin setdp macro
.0104df	08		php			PHP
.0104e0	c2 20		rep #$20	                REP #$20        ; set A long
.0104e2	a9 00 0f	lda #$0f00	                LDA #$0F00         ; set DP to page 0
.0104e5	5b		tcd		                TCD
.0104e6	28		plp			PLP
.0104e7	68		pla		                PLA             ; end setdp macro
.0104e8	c2 30		rep #$30	                REP #$30        ; set A&X long
.0104ea	a6 40		ldx $0f40	igetchw1        LDX KEY_BUFFER_RPOS
.0104ec	e4 42		cpx $0f42	                CPX KEY_BUFFER_WPOS
.0104ee	d0 05		bne $0104f5	                BNE igetchw2
>0104f0	42 00				                .byte $42, $00
.0104f2	4c ea 04	jmp $0104ea	                JMP igetchw1
.0104f5	b5 00		lda $0f00,x	igetchw2        LDA $0,D,X  ; Read the value in the keyboard buffer
.0104f7	48		pha		                PHA
.0104f8	8a		txa		                TXA
.0104f9	18		clc		                CLC
.0104fa	69 02 00	adc #$0002	                ADC #$02
.0104fd	c9 40 00	cmp #$0040	                CMP #KEY_BUFFER_SIZE
.010500	90 03		bcc $010505	                BCC igetchw3
.010502	a9 00 00	lda #$0000	                LDA #$0
.010505	85 40		sta $0f40	igetchw3        STA KEY_BUFFER_RPOS
.010507	68		pla		                PLA
.010508	28		plp		igetchw_done    PLP
.010509	fa		plx		                PLX             ; Restore the saved registers and return
.01050a	2b		pld		                PLD
.01050b	6b		rtl		                RTL
.01050c	22 15 05 01	jsl $010515	IPRINT          JSL IPUTS
.010510	22 5a 05 01	jsl $01055a	                JSL IPRINTCR
.010514	6b		rtl		                RTL
.010515	48		pha		IPUTS           PHA
.010516	08		php		                PHP
.010517	e2 20		sep #$20	                SEP #$20        ; set A short
.010519	c2 10		rep #$10	                REP #$10        ; set X long
.01051b	bd 00 00	lda $010000,x	iputs1          LDA $0,b,x      ; read from the string
.01051e	f0 08		beq $010528	                BEQ iputs_done
.010520	22 2c 05 01	jsl $01052c	iputs2          JSL IPUTC
.010524	e8		inx		iputs3          INX
.010525	4c 1b 05	jmp $01051b	                JMP iputs1
.010528	e8		inx		iputs_done      INX
.010529	28		plp		                PLP
.01052a	68		pla		                PLA
.01052b	6b		rtl		                RTL
.01052c	0b		phd		IPUTC           PHD
.01052d	08		php		                PHP             ; stash the flags (we'll be changing M)
.01052e	48		pha		                PHA             ; begin setdp macro
.01052f	08		php			PHP
.010530	c2 20		rep #$20	                REP #$20        ; set A long
.010532	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.010535	5b		tcd		                TCD
.010536	28		plp			PLP
.010537	68		pla		                PLA             ; end setdp macro
.010538	e2 20		sep #$20	                SEP #$20        ; set A short
.01053a	c9 0d		cmp #$0d	                CMP #$0D        ; handle CR
.01053c	d0 06		bne $010544	                BNE iputc_bs
.01053e	22 5a 05 01	jsl $01055a	                JSL IPRINTCR
.010542	80 10		bra $010554	                bra iputc_done
.010544	c9 08		cmp #$08	iputc_bs        CMP #$08        ; backspace
.010546	d0 06		bne $01054e	                BNE iputc_print
.010548	22 6b 05 01	jsl $01056b	                JSL IPRINTBS
.01054c	80 06		bra $010554	                BRA iputc_done
.01054e	87 17		sta [$17]	iputc_print     STA [CURSORPOS] ; Save the character on the screen
.010550	22 7b 05 01	jsl $01057b	                JSL ICSRRIGHT
.010554					iputc_done
>010554	42 01				                .byte $42, $01
.010556	28		plp		                PLP
.010557	2b		pld		                PLD
.010558	6b		rtl		                RTL
.010559					IPUTB
.010559	6b		rtl		                RTL
.01055a	da		phx		IPRINTCR	PHX
.01055b	5a		phy		                PHY
.01055c	08		php		                PHP
.01055d	a2 00 00	ldx #$0000	                LDX #0
.010560	a4 1c		ldy $1c		                LDY CURSORY
.010562	c8		iny		                INY
.010563	22 a8 05 01	jsl $0105a8	                JSL ILOCATE
.010567	28		plp		                PLP
.010568	7a		ply		                PLY
.010569	fa		plx		                PLX
.01056a	6b		rtl		                RTL
.01056b	da		phx		IPRINTBS	PHX
.01056c	5a		phy		                PHY
.01056d	08		php		                PHP
.01056e	a6 1a		ldx $1a		                LDX CURSORX
.010570	a4 1c		ldy $1c		                LDY CURSORY
.010572	ca		dex		                DEX
.010573	22 a8 05 01	jsl $0105a8	                JSL ILOCATE
.010577	28		plp		                PLP
.010578	7a		ply		                PLY
.010579	fa		plx		                PLX
.01057a	6b		rtl		                RTL
.01057b					ICSRRIGHT
.01057b	da		phx		                PHX
.01057c	8b		phb		                PHB
.01057d	c2 20		rep #$20	                REP #$20        ; set A long
.01057f	c2 10		rep #$10	                REP #$10        ; set X long
.010581	48		pha		                PHA             ; begin setdp macro
.010582	08		php			PHP
.010583	c2 20		rep #$20	                REP #$20        ; set A long
.010585	a9 00 00	lda #$0000	                LDA #$0         ; set DP to page 0
.010588	5b		tcd		                TCD
.010589	28		plp			PLP
.01058a	68		pla		                PLA             ; end setdp macro
.01058b	e6 17		inc $17		                INC CURSORPOS
.01058d	a6 1a		ldx $1a		                LDX CURSORX
.01058f	e8		inx		                INX
.010590	e4 0f		cpx $0f		                CPX COLS_VISIBLE
.010592	90 0c		bcc $0105a0	                BCC icsr_nowrap  ; wrap if the cursor is at or past column 80
.010594	a2 00 00	ldx #$0000	                LDX #0
.010597	5a		phy		                PHY
.010598	a4 1c		ldy $1c		                LDY CURSORY
.01059a	c8		iny		                INY
.01059b	22 a8 05 01	jsl $0105a8	                JSL ILOCATE
.01059f	7a		ply		                PLY
.0105a0	86 1a		stx $1a		icsr_nowrap     STX CURSORX
.0105a2	ab		plb		                PLB
.0105a3	fa		plx		                PLX
.0105a4	6b		rtl		                RTL
.0105a5	6b		rtl		ISRLEFT	RTL
.0105a6	6b		rtl		ICSRUP	RTL
.0105a7	6b		rtl		ICSRDOWN	RTL
.0105a8	48		pha		ILOCATE         PHA
.0105a9	08		php		                PHP
.0105aa	c2 30		rep #$30	                REP #$30        ; set A&X long
.0105ac					ilocate_scroll
.0105ac	c4 13		cpy $13		                CPY LINES_VISIBLE
.0105ae	90 07		bcc $0105b7	                BCC ilocate_scrolldone
.0105b0	22 d4 05 01	jsl $0105d4	                JSL ISCROLLUP
.0105b4	88		dey		                DEY
.0105b5	80 f5		bra $0105ac	                BRA ilocate_scroll
.0105b7					ilocate_scrolldone
.0105b7	86 1a		stx $1a		                STX CURSORX
.0105b9	84 1c		sty $1c		                STY CURSORY
.0105bb	a5 0c		lda $0c		                LDA SCREENBEGIN
.0105bd					ilocate_row
.0105bd	c0 00 00	cpy #$0000	                CPY #$0
.0105c0	f0 08		beq $0105ca	                BEQ ilocate_right
.0105c2	18		clc		ilocate_down    CLC
.0105c3	65 11		adc $11		                ADC COLS_PER_LINE
.0105c5	88		dey		                DEY
.0105c6	f0 02		beq $0105ca	                BEQ ilocate_right
.0105c8	80 f8		bra $0105c2	                BRA ilocate_down
.0105ca	18		clc		ilocate_right   CLC
.0105cb	65 1a		adc $1a		                ADC CURSORX             ; move the cursor right X columns
.0105cd	85 17		sta $17		                STA CURSORPOS
.0105cf	a4 1c		ldy $1c		                LDY CURSORY
.0105d1	28		plp		ilocate_done    PLP
.0105d2	68		pla		                PLA
.0105d3	6b		rtl		                RTL
.0105d4					ISCROLLUP
.0105d4	48		pha		                PHA
.0105d5	da		phx		                PHX
.0105d6	5a		phy		                PHY
.0105d7	8b		phb		                PHB
.0105d8	08		php		                PHP
.0105d9	c2 30		rep #$30	                REP #$30        ; set A&X long
.0105db	18		clc		                CLC
.0105dc	a5 0c		lda $0c		                LDA SCREENBEGIN
.0105de	a8		tay		                TAY             ; Destination is first row
.0105df	65 11		adc $11		                ADC COLS_PER_LINE
.0105e1	aa		tax		                TAX             ; Source is second row
.0105e2	a9 ef 1f	lda #$1fef	                LDA #SCREEN_PAGE1-SCREEN_PAGE0-COLS_PER_LINE
.0105e5	44 00 00	mvp $00,$00	                MVP $00,$00
.0105e8	28		plp		                PLP
.0105e9	ab		plb		                PLB
.0105ea	7a		ply		                PLY
.0105eb	fa		plx		                PLX
.0105ec	68		pla		                PLA
.0105ed	6b		rtl		                RTL
.0105ee	08		php		IPRINTH         PHP
.0105ef	48		pha		                PHA
.0105f0					iprinth1
.0105f0	e2 20		sep #$20	                SEP #$20        ; set A short
.0105f2	bd 00 00	lda $010000,x	                LDA #0,b,x      ; Read the value to be printed
.0105f5	4a		lsr a		                LSR
.0105f6	4a		lsr a		                LSR
.0105f7	4a		lsr a		                LSR
.0105f8	4a		lsr a		                LSR
.0105f9	22 0b 06 01	jsl $01060b	                JSL iprint_digit
.0105fd	bd 00 00	lda $010000,x	                LDA #0,b,x
.010600	22 0b 06 01	jsl $01060b	                JSL iprint_digit
.010604	ca		dex		                DEX
.010605	88		dey		                DEY
.010606	d0 e8		bne $0105f0	                BNE iprinth1
.010608	68		pla		                PLA
.010609	28		plp		                PLP
.01060a	6b		rtl		                RTL
.01060b	da		phx		iprint_digit    PHX
.01060c	c2 20		rep #$20	                REP #$20        ; set A long
.01060e	29 0f 00	and #$000f	                AND #$0F
.010611	aa		tax		                TAX
.010612	bf 97 07 01	lda $010797,x	                LDA hex_digits,X
.010616	22 2c 05 01	jsl $01052c	                JSL IPUTC       ; Print the digit
.01061a	fa		plx		                PLX
.01061b	6b		rtl		                RTL
.01061c	00		brk #		IRESTORE        BRK ; Warm boot routine
.01061d	00		brk #		ISCINIT         BRK ;
.01061e	00		brk #		IIOINIT         BRK ;
.01061f	00		brk #		IPUTBLOCK       BRK ; Ouput a binary block to the currently selected channel
.010620	00		brk #		ISETLFS         BRK ; Obsolete (done in OPEN)
.010621	00		brk #		ISETNAM         BRK ; Obsolete (done in OPEN)
.010622	00		brk #		IOPEN           BRK ; Open a channel for reading and/or writing. Use SETLFS and SETNAM to set the channels and filename first.
.010623	00		brk #		ICLOSE          BRK ; Close a channel
.010624	00		brk #		ISETIN          BRK ; Set the current input channel
.010625	00		brk #		ISETOUT         BRK ; Set the current output channel
.010626	00		brk #		IGETB           BRK ; Get a byte from input channel. Return 0 if no input. Carry is set if no input.
.010627	00		brk #		IGETBLOCK       BRK ; Get a X byes from input channel. If Carry is set, wait. If Carry is clear, do not wait.
.010628	00		brk #		IGETCH          BRK ; Get a character from the input channel. A=0 and Carry=1 if no data is wating
.010629	00		brk #		IGETS           BRK ; Get a string from the input channel. NULL terminates
.01062a	00		brk #		IGETLINE        BRK ; Get a line of text from input channel. CR or NULL terminates.
.01062b	00		brk #		IGETFIELD       BRK ; Get a field from the input channel. Value in A, CR, or NULL terminates
.01062c	00		brk #		ITRIM           BRK ; Removes spaces at beginning and end of string.
.01062d	00		brk #		IPRINTC         BRK ; Print character to screen. Handles terminal commands
.01062e	00		brk #		IPRINTS         BRK ; Print string to screen. Handles terminal commands
.01062f	00		brk #		IPRINTF         BRK ; Print a float value
.010630	00		brk #		IPRINTI         BRK ; Prints integer value in TEMP
.010631	00		brk #		IPRINTAI        BRK ; Prints integer value in A
.010632	00		brk #		IPRINTAH        BRK ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
.010633	00		brk #		IPUSHKEY        BRK ;
.010634	00		brk #		IPUSHKEYS       BRK ;
.010635	00		brk #		ICSRLEFT        BRK ;
.010636	00		brk #		ICSRHOME        BRK ;
.010637	00		brk #		ISCRREADLINE    BRK ; Loads the MCMDADDR/BCMDADDR variable with the address of the current line on the screen. This is called when the RETURN key is pressed and is the first step in processing an immediate mode command.
.010638	00		brk #		ISCRGETWORD     BRK ; Read a current word on the screen. A word ends with a space, punctuation (except _), or any control character (value < 32). Loads the address into CMPTEXT_VAL and length into CMPTEXT_LEN variables.
.010639					KERNEL_DATA
>010639	20 20 20 20 ec a9 ec a9		greet_msg       .text "    ", $EC,$A9,$EC,$A9,$EC,$A9,$EC,$A9,$EC,$A9,     " FOENIX 256 DEVELOPMENT SYSTEM",$0D
>010641	ec a9 ec a9 ec a9 20 46 4f 45 4e 49 58 20 32 35
>010651	36 20 44 45 56 45 4c 4f 50 4d 45 4e 54 20 53 59
>010661	53 54 45 4d 0d
>010666	20 20 20 ec a9 ec a9 ec		                .text "   " , $EC,$A9,$EC,$A9,$EC,$A9,$EC,$A9,$EC,$A9,    "  OPEN SOURCE COMPUTER",$0D
>01066e	a9 ec a9 ec a9 20 20 4f 50 45 4e 20 53 4f 55 52
>01067e	43 45 20 43 4f 4d 50 55 54 45 52 0d
>01068a	20 20 ec a9 ec a9 ec a9		                .text "  ", $EC,$A9,$EC,$A9,$EC,$A9,$EC,$A9,$EC,$A9,     "   ",$0D
>010692	ec a9 ec a9 20 20 20 0d
>01069a	20 ec a9 ec a9 ec a9 ec		                .text " ",  $EC,$A9,$EC,$A9,$EC,$A9,$EC,$A9,$EC,$A9,    "    1024KB BASIC RAM  8192K MEDIA RAM",$0D
>0106a2	a9 ec a9 20 20 20 20 31 30 32 34 4b 42 20 42 41
>0106b2	53 49 43 20 52 41 4d 20 20 38 31 39 32 4b 20 4d
>0106c2	45 44 49 41 20 52 41 4d 0d
>0106cb	ec a9 ec a9 ec a9 ec a9		                .text $EC,$A9,$EC,$A9,$EC,$A9,$EC,$A9,$EC,$A9,         "     ",$00
>0106d3	ec a9 20 20 20 20 20 00
>0106db	0d 52 45 41 44 59 2e 00		ready_msg       .null $0D,"READY."
>0106e3	31 30 20 50 52 49 4e 54		hello_basic     .null "10 PRINT ""Hello World""",$0D
>0106eb	20 22 48 65 6c 6c 6f 20 57 6f 72 6c 64 22 0d 00
>0106fb	52 55 4e 0d 00			                .null "RUN",$0D
>010700	48 65 6c 6c 6f 20 57 6f		                .null "Hello World",$0D
>010708	72 6c 64 0d 00
>01070d	0d 52 45 41 44 59 2e 00		                .null $0D,"READY."
>010715	47 20 30 32 30 30 30 30		hello_ml        .null "G 020000",$0D
>01071d	0d 00
>01071f	48 45 4c 4c 4f 20 57 4f		                .null "HELLO WORLD",$0D
>010727	52 4c 44 0d 00
>01072c	0d 00				                .null $0D
>01072e	20 50 43 20 20 20 20 20		                .null " PC     A    X    Y    SP   DBR DP   NVMXDIZC",$0D
>010736	41 20 20 20 20 58 20 20 20 20 59 20 20 20 20 53
>010746	50 20 20 20 44 42 52 20 44 50 20 20 20 4e 56 4d
>010756	58 44 49 5a 43 0d 00
>01075d	3b 30 30 32 31 31 32 20		                .null ";002112 0019 F0AA 0000 D6FF F8  0000 --M-----"
>010765	30 30 31 39 20 46 30 41 41 20 30 30 30 30 20 44
>010775	36 46 46 20 46 38 20 20 30 30 30 30 20 2d 2d 4d
>010785	2d 2d 2d 2d 2d 00
>01078b	41 42 4f 52 54 20 45 52		error_01        .null "ABORT ERROR"
>010793	52 4f 52 00
>010797	30 31 32 33 34 35 36 37		hex_digits      .text "0123456789ABCDEF",0
>01079f	38 39 41 42 43 44 45 46 00

;******  End of listing
