
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass --long-address --intel-hex -o kernel.hex --list kernel.lst kernel.asm
; Wed Oct 10 17:10:58 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm


;******  Processing file: macros_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: simulator_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: bank_00_inc.asm

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what VICKY is displaying, especiall if you are using mirror mode.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORROW        = $00001A ;3 Bytes Address of the beginning of the current text row
=$00001d				MIRROR_MODE      = $00001D ;1 Byte  1=Mirror Mode enabled. Reserve 32K (somewhere) in SRAM for a display mirror. 0=Disable Mirror Mode and write directly to VICKY.
=$00001e				CURSOR_X         = $00001E ;2 Bytes Address of the beginning of the current text row
=$000020				CURSOR_Y         = $000020 ;2 Bytes 1=Mirror Mode enabled. Reserve 32K (somewhere) in SRAM for a display mirror. 0=Disable Mirror Mode and write directly to VICKY.
=$000022				CURCOLOR         = $000022 ;2 Bytes Color of next character to be printed to the screen.
=$000024				CURATTR          = $000024 ;2 Bytes Attribute of next character to be printed to the screen.
=$000026				STACKBOT         = $000026 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000028				STACKTOP         = $000028 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$0000d0				KERNEL_TEMP      = $0000D0 ;32 Bytes Temp space for kernel
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Unsigned divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 0 Divisor ex B in A/B
=$000114				D0_RESULT        = $000114 ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Signed divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 1 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				GAVIN_MISC       = $000120 ;224 Bytes GAVIN vector controller (TBD)
=$0001ff				VECTOR_STATE     = $0001FF ;1 Byte  Interrupt Vector State. See VECTOR_STATE_ENUM
=$000200				CPU_REGISTERS    = $000200 ; Byte
=$000200				CPUPC            = $000200 ;2 Bytes Program Counter (PC)
=$000202				CPUPBR           = $000202 ;1 Byte  Program Bank Register (K)
=$000203				CPUA             = $000203 ;2 Bytes Accumulator (A)
=$000205				CPUX             = $000205 ;2 Bytes X Register (X)
=$000207				CPUY             = $000207 ;2 Bytes Y Register (Y)
=$000209				CPUSTACK         = $000209 ;2 Bytes Stack Pointer (S)
=$00020b				CPUDP            = $00020B ;2 Bytes Direct Page Register (D)
=$00020d				CPUDBR           = $00020D ;1 Byte  Data Bank Register (B)
=$00020e				CPUFLAGS         = $00020E ;1 Byte  Flags (P)
=$000210				MONITOR_VARS     = $000210 ; Byte  MONITOR Variables. BASIC variables may overlap this space
=$000210				MCMDADDR         = $000210 ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$000213				MCMP_TEXT        = $000213 ;3 Bytes Address of symbol being evaluated for COMPARE routine
=$000216				MCMP_LEN         = $000216 ;2 Bytes Length of symbol being evaluated for COMPARE routine
=$000218				MCMD             = $000218 ;3 Bytes Address of the current command/function string
=$00021b				MCMD_LEN         = $00021B ;2 Bytes Length of the current command/function string
=$00021d				MARG1            = $00021D ;4 Bytes First command argument. May be data or address, depending on command
=$000221				MARG2            = $000221 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000225				MARG3            = $000225 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000229				MARG4            = $000229 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$00022d				MARG5            = $00022D ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000231				MARG6            = $000231 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000235				MARG7            = $000235 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000239				MARG8            = $000239 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000f00				KEY_BUFFER       = $000F00 ;64 Bytes keyboard buffer
=$40					KEY_BUFFER_SIZE  = $40 ;64 Bytes (constant) keyboard buffer length
=$000f40				KEY_BUFFER_END   = $000F40 ;1 Byte  Last byte of keyboard buffer
=$000f41				KEY_BUFFER_RPOS  = $000F41 ;2 Bytes keyboard buffer read position
=$000f43				KEY_BUFFER_WPOS  = $000F43 ;2 Bytes keyboard buffer write position
=$001000				TEST_BEGIN       = $001000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ff00				ISR_BEGIN        = $00FF00 ; Byte  Beginning of CPU vectors in Direct page
=$00ff00				HRESET           = $00FF00 ;16 Bytes Handle RESET asserted. Reboot computer and re-initialize the kernel.
=$00ff10				HCOP             = $00FF10 ;16 Bytes Handle the COP instruction. Program use; not used by OS
=$00ff20				HBRK             = $00FF20 ;16 Bytes Handle the BRK instruction. Returns to BASIC Ready prompt.
=$00ff30				HABORT           = $00FF30 ;16 Bytes Handle ABORT asserted. Return to Ready prompt with an error message.
=$00ff40				HNMI             = $00FF40 ;32 Bytes Handle NMI
=$00ff60				HIRQ             = $00FF60 ;32 Bytes Handle IRQ
=$00ff80				Unused_FF80      = $00FF80 ;End of direct page Interrrupt handlers
=$00ffe0				VECTORS_BEGIN    = $00FFE0 ;0 Byte  Interrupt vectors
=$00ffe0				JMP_READY        = $00FFE0 ;4 Bytes Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$00ffe4				VECTOR_COP       = $00FFE4 ;2 Bytes Native COP Interrupt vector
=$00ffe6				VECTOR_BRK       = $00FFE6 ;2 Bytes Native BRK Interrupt vector
=$00ffe8				VECTOR_ABORT     = $00FFE8 ;2 Bytes Native ABORT Interrupt vector
=$00ffea				VECTOR_NMI       = $00FFEA ;2 Bytes Native NMI Interrupt vector
=$00ffec				VECTOR_RESET     = $00FFEC ;2 Bytes Unused (Native RESET vector)
=$00ffee				VECTOR_IRQ       = $00FFEE ;2 Bytes Native IRQ Vector
=$00fff0				RETURN           = $00FFF0 ;4 Bytes RETURN key handler. Points to BASIC or MONITOR subroutine to execute when RETURN is pressed.
=$00fff4				VECTOR_ECOP      = $00FFF4 ;2 Bytes Emulation mode interrupt handler
=$00fff6				VECTOR_EBRK      = $00FFF6 ;2 Bytes Emulation mode interrupt handler
=$00fff8				VECTOR_EABORT    = $00FFF8 ;2 Bytes Emulation mode interrupt handler
=$00fffa				VECTOR_ENMI      = $00FFFA ;2 Bytes Emulation mode interrupt handler
=$00fffc				VECTOR_ERESET    = $00FFFC ;2 Bytes Emulation mode interrupt handler
=$00fffe				VECTOR_EIRQ      = $00FFFE ;2 Bytes Emulation mode interrupt handler
=$010000				VECTORS_CHECK    = $010000 ;*End of vector space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: kernel.asm


;******  Processing file: bank_00_data.asm

>0000	00 00 00 00 00 00 00 00		                .fill 12, 0         ; unused_0000, 000000, 12 B, unused
>0008	00 00 00 00
>000c	00 80 02			                .long TEXT_PAGE0    ; SCREENBEGIN, 00000C, 3 B, Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what VICKY is displaying, especiall if you are using mirror mode.
>000f	50 00				                .word 80            ; COLS_VISIBLE, 00000F, 2 B, Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
>0011	80 00				                .word 128           ; COLS_PER_LINE, 000011, 2 B, Columns in memory per screen line. A virtual line can be this long. Default=128
>0013	3c 00				                .word 60            ; LINES_VISIBLE, 000013, 2 B, The number of rows visible on the screen. Default=25
>0015	40 00				                .word 64            ; LINES_MAX, 000015, 2 B, The number of rows in memory for the screen. Default=64
>0017	00 80 02			                .long TEXT_PAGE0    ; CURSORPOS, 000017, 3 B, The next character written to the screen will be written in this location.
>001a	00 80 02			                .long TEXT_PAGE0    ; CURSORROW, 00001A, 3 B, Address of the beginning of the current text row
>001d	01				                .byte 1             ; MIRROR_MODE, 00001D, 1 B, 1=Mirror Mode enabled. Reserve 32K (somewhere) in SRAM for a display mirror. 0=Disable Mirror Mode and write directly to VICKY.
>001e	00 00				                .word 0             ; CURSOR_X, 00001E, 2 B, Address of the beginning of the current text row
>0020	00 00				                .word 0             ; CURSOR_Y, 000020, 2 B, 1=Mirror Mode enabled. Reserve 32K (somewhere) in SRAM for a display mirror. 0=Disable Mirror Mode and write directly to VICKY.
>0022	0f 00				                .word $0F           ; CURCOLOR, 000022, 2 B, Color of next character to be printed to the screen.
>0024	00 00				                .word $00           ; CURATTR, 000024, 2 B, Attribute of next character to be printed to the screen.
>0026	ff fe				                .word STACK_END     ; STACKBOT, 000026, 2 B, Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
>0028	00 80				                .word STACK_BEGIN   ; STACKTOP, 000028, 2 B, Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
>002a	00 00 00 00 00 00 00 00		                .fill 32, 0         ; KERNEL_TEMP, 0000D0, 32 B, Temp space for kernel
>0032	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>0042	00 00 00 00 00 00 00 00
>004a	00 00 00 00 00 00 00 00		                .fill 32, 0         ; USER_TEMP, 0000F0, 32 B, Temp space for user programs
>0052	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>0062	00 00 00 00 00 00 00 00

;******  Return to file: kernel.asm


;******  Processing file: bank_00_code.asm

.ff00	18		clc		RHRESET         CLC
.ff01	fb		xce		                XCE
.ff02	5c 00 00 01	jmp $010000	                JML BOOT
.ff10					RHCOP
.ff10	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff12	8b		phb		                PHB
.ff13	0b		phd		                PHD
.ff14	48		pha		                PHA
.ff15	da		phx		                PHX
.ff16	5a		phy		                PHY
.ff17	5c 08 00 01	jmp $010008	                JML BREAK
.ff20					RHBRK
.ff20	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff22	8b		phb		                PHB
.ff23	0b		phd		                PHD
.ff24	48		pha		                PHA
.ff25	da		phx		                PHX
.ff26	5a		phy		                PHY
.ff27	5c 08 00 01	jmp $010008	                JML BREAK
.ff30					RHABORT
.ff30	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff32	8b		phb		                PHB
.ff33	0b		phd		                PHD
.ff34	48		pha		                PHA
.ff35	da		phx		                PHX
.ff36	5a		phy		                PHY
.ff37	5c 08 00 01	jmp $010008	                JML BREAK
.ff40					 RHNMI
.ff40	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff42	8b		phb		                PHB
.ff43	0b		phd		                PHD
.ff44	48		pha		                PHA
.ff45	da		phx		                PHX
.ff46	5a		phy		                PHY
.ff47	7a		ply		                PLY
.ff48	fa		plx		                PLX
.ff49	68		pla		                PLA
.ff4a	2b		pld		                PLD
.ff4b	ab		plb		                PLB
.ff4c	40		rti		                RTI
.ff60					RHIRQ
.ff60	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff62	8b		phb		                PHB
.ff63	0b		phd		                PHD
.ff64	48		pha		                PHA
.ff65	da		phx		                PHX
.ff66	5a		phy		                PHY
.ff67	7a		ply		                PLY
.ff68	fa		plx		                PLX
.ff69	68		pla		                PLA
.ff6a	2b		pld		                PLD
.ff6b	ab		plb		                PLB
.ff6c	40		rti		                RTI
.ffe0	5c 66 80 01	jmp $018066	JUMP_READY      JML IMREADY     ; Kernel READY routine. Rewrite this address to jump to a custom kernel.
>ffe4	10 ff				RVECTOR_COP     .word HCOP     ; FFE4
>ffe6	20 ff				RVECTOR_BRK     .word HBRK     ; FFE6
>ffe8	30 ff				RVECTOR_ABORT   .word HABORT   ; FFE8
>ffea	40 ff				RVECTOR_NMI     .word HNMI     ; FFEA
>ffec	00 00				                .word $0000    ; FFEC
>ffee	60 ff				RVECTOR_IRQ     .word HIRQ     ; FFEE
.fff0	5c d5 04 01	jmp $0104d5	RRETURN         JML IRETURN
>fff4	10 ff				RVECTOR_ECOP    .word HCOP     ; FFF4
>fff6	20 ff				RVECTOR_EBRK    .word HBRK     ; FFF6
>fff8	30 ff				RVECTOR_EABORT  .word HABORT   ; FFF8
>fffa	40 ff				RVECTOR_ENMI    .word HNMI     ; FFFA
>fffc	00 ff				RVECTOR_ERESET  .word HRESET   ; FFFC
>fffe	60 ff				RVECTOR_EIRQ    .word HIRQ     ; FFFE

;******  Return to file: kernel.asm


;******  Processing file: bank_02_inc.asm

=$020000				BANK2_BEGIN      = $020000 ;Start of Bank 2 (Buffers and VRAM)
=$2000					TEXT_PAGE_SIZE   = $2000 ;Constant: Number of bytes in one page of video RAM
=$028000				TEXT_PAGE0       = $028000 ;8192 Bytes Video RAM Character data
=$02a000				TEXT_PAGE1       = $02A000 ;8192 Bytes Video RAM Color Data
=$02c000				TEXT_PAGE2       = $02C000 ;8192 Bytes Video RAM Attribute data
=$02e000				TEXT_PAGE3       = $02E000 ;8192 Bytes Video RAM Additional data

;******  Return to file: kernel.asm


;******  Processing file: bank_7f_inc.asm

=$7fd800				IO_BEGIN             = $7FD800 ; Byte  Beginning of IO space
=$7f0000				MASTER_CTRL_REG_L    = $7F0000 ;1 Byte
=$7f0001				MASTER_CTRL_REG_H    = $7F0001 ;1 Byte
=$7f0008				TXT_CTRL_REG         = $7F0008 ;2 Bytes
=$7f0008				TXT_CTRL_REG_L       = $7F0008 ;1 Byte
=$7f0009				TXT_CTRL_REG_H       = $7F0009 ;1 Byte
=$7f000a				TXT_CURSOR_CTRL      = $7F000A ;1 Byte
=$01					TXT_CURSOR_ENABLE    = $01 ; Byte  Bit 0: Flash Enabled
=$00					TXT_CURSOR_FLASH_0   = $00 ; Byte  Bits 1-2: Cursor Flash: 0-Transparent
=$02					TXT_CURSOR_FLASH_1   = $02 ; Byte  Bits 1-2: Cursor Flash: 1-Full On
=$04					TXT_CURSOR_FLASH_2   = $04 ; Byte  Bits 1-2: Cursor Flash: 2-1Hz
=$06					TXT_CURSOR_FLASH_3   = $06 ; Byte  Bits 1-2: Cursor Flash: 3-2Hz
=$7f000b				TXT_CURSOR_COLOR     = $7F000B ;1 Byte
=$7f000c				TXT_CURSOR_X_REG_L   = $7F000C ;1 Byte
=$7f000d				TXT_CURSOR_X_REG_H   = $7F000D ;1 Byte
=$7f000e				TXT_CURSOR_Y_REG_L   = $7F000E ;1 Byte
=$7f000f				TXT_CURSOR_Y_REG_H   = $7F000F ;1 Byte
=$7f1100				PME_STS_REG          = $7F1100 ;1 Byte
=$7f1102				PME_EN_REG           = $7F1102 ;1 Byte
=$7f1104				PME_STS1_REG         = $7F1104 ;1 Byte
=$7f1105				PME_STS2_REG         = $7F1105 ;1 Byte
=$7f1106				PME_STS3_REG         = $7F1106 ;1 Byte
=$7f1107				PME_STS4_REG         = $7F1107 ;1 Byte
=$7f1108				PME_STS5_REG         = $7F1108 ;1 Byte
=$7f110a				PME_EN1_REG          = $7F110A ;1 Byte
=$7f110b				PME_EN2_REG          = $7F110B ;1 Byte
=$7f110c				PME_EN3_REG          = $7F110C ;1 Byte
=$7f110d				PME_EN4_REG          = $7F110D ;1 Byte
=$7f110e				PME_EN5_REG          = $7F110E ;1 Byte
=$7f1110				SMI_STS1_REG         = $7F1110 ;1 Byte
=$7f1111				SMI_STS2_REG         = $7F1111 ;1 Byte
=$7f1112				SMI_STS3_REG         = $7F1112 ;1 Byte
=$7f1113				SMI_STS4_REG         = $7F1113 ;1 Byte
=$7f1114				SMI_STS5_REG         = $7F1114 ;1 Byte
=$7f1116				SMI_EN1_REG          = $7F1116 ;1 Byte
=$7f1117				SMI_EN2_REG          = $7F1117 ;1 Byte
=$7f1118				SMI_EN3_REG          = $7F1118 ;1 Byte
=$7f1119				SMI_EN4_REG          = $7F1119 ;1 Byte
=$7f111a				SMI_EN5_REG          = $7F111A ;1 Byte
=$7f111c				MSC_ST_REG           = $7F111C ;1 Byte
=$7f111e				FORCE_DISK_CHANGE    = $7F111E ;1 Byte
=$7f111f				FLOPPY_DATA_RATE     = $7F111F ;1 Byte
=$7f1120				UART1_FIFO_CTRL_SHDW = $7F1120 ;1 Byte
=$7f1121				UART2_FIFO_CTRL_SHDW = $7F1121 ;1 Byte
=$7f1122				DEV_DISABLE_REG      = $7F1122 ;1 Byte
=$7f1123				GP10_REG             = $7F1123 ;1 Byte
=$7f1124				GP11_REG             = $7F1124 ;1 Byte
=$7f1125				GP12_REG             = $7F1125 ;1 Byte
=$7f1126				GP13_REG             = $7F1126 ;1 Byte
=$7f1127				GP14_REG             = $7F1127 ;1 Byte
=$7f1128				GP15_REG             = $7F1128 ;1 Byte
=$7f1129				GP16_REG             = $7F1129 ;1 Byte
=$7f112a				GP17_REG             = $7F112A ;1 Byte
=$7f112b				GP20_REG             = $7F112B ;1 Byte
=$7f112c				GP21_REG             = $7F112C ;1 Byte
=$7f112d				GP22_REG             = $7F112D ;1 Byte
=$7f112f				GP24_REG             = $7F112F ;1 Byte
=$7f1130				GP25_REG             = $7F1130 ;1 Byte
=$7f1131				GP26_REG             = $7F1131 ;1 Byte
=$7f1132				GP27_REG             = $7F1132 ;1 Byte
=$7f1133				GP30_REG             = $7F1133 ;1 Byte
=$7f1134				GP31_REG             = $7F1134 ;1 Byte
=$7f1135				GP32_REG             = $7F1135 ;1 Byte
=$7f1136				GP33_REG             = $7F1136 ;1 Byte
=$7f1137				GP34_REG             = $7F1137 ;1 Byte
=$7f1138				GP35_REG             = $7F1138 ;1 Byte
=$7f1139				GP36_REG             = $7F1139 ;1 Byte
=$7f113a				GP37_REG             = $7F113A ;1 Byte
=$7f113b				GP40_REG             = $7F113B ;1 Byte
=$7f113c				GP41_REG             = $7F113C ;1 Byte
=$7f113d				GP42_REG             = $7F113D ;1 Byte
=$7f113e				GP43_REG             = $7F113E ;1 Byte
=$7f113f				GP50_REG             = $7F113F ;1 Byte
=$7f1140				GP51_REG             = $7F1140 ;1 Byte
=$7f1141				GP52_REG             = $7F1141 ;1 Byte
=$7f1142				GP53_REG             = $7F1142 ;1 Byte
=$7f1143				GP54_REG             = $7F1143 ;1 Byte
=$7f1144				GP55_REG             = $7F1144 ;1 Byte
=$7f1145				GP56_REG             = $7F1145 ;1 Byte
=$7f1146				GP57_REG             = $7F1146 ;1 Byte
=$7f1147				GP60_REG             = $7F1147 ;1 Byte
=$7f1148				GP61_REG             = $7F1148 ;1 Byte
=$7f114b				GP1_REG              = $7F114B ;1 Byte
=$7f114c				GP2_REG              = $7F114C ;1 Byte
=$7f114d				GP3_REG              = $7F114D ;1 Byte
=$7f114e				GP4_REG              = $7F114E ;1 Byte
=$7f114f				GP5_REG              = $7F114F ;1 Byte
=$7f1150				GP6_REG              = $7F1150 ;1 Byte
=$7f1156				FAN1_REG             = $7F1156 ;1 Byte
=$7f1157				FAN2_REG             = $7F1157 ;1 Byte
=$7f1158				FAN_CTRL_REG         = $7F1158 ;1 Byte
=$7f1159				FAN1_TACH_REG        = $7F1159 ;1 Byte
=$7f115a				FAN2_TACH_REG        = $7F115A ;1 Byte
=$7f115b				FAN1_PRELOAD_REG     = $7F115B ;1 Byte
=$7f115c				FAN2_PRELOAD_REG     = $7F115C ;1 Byte
=$7f115d				LED1_REG             = $7F115D ;1 Byte
=$7f115e				LED2_REG             = $7F115E ;1 Byte
=$7f115f				KEYBOARD_SCAN_CODE   = $7F115F ;1 Byte
=$7f1f40				FG_CHAR_LUT_PTR      = $7F1F40 ;64 Bytes
=$7f1f80				BG_CHAR_LUT_PTR      = $7F1F80 ;64 Bytes
=$7f2000				GRPH_LUT0_PTR        = $7F2000 ;1024 Bytes
=$7f2400				GRPH_LUT1_PTR        = $7F2400 ;1024 Bytes
=$7f2800				GRPH_LUT2_PTR        = $7F2800 ;1024 Bytes
=$7f2c00				GRPH_LUT3_PTR        = $7F2C00 ;1024 Bytes
=$7f3000				GRPH_LUT4_PTR        = $7F3000 ;1024 Bytes
=$7f3400				GRPH_LUT5_PTR        = $7F3400 ;1024 Bytes
=$7f3800				GRPH_LUT6_PTR        = $7F3800 ;1024 Bytes
=$7f3c00				GAMMA_LUT_PTR        = $7F3C00 ;1024 Bytes
=$7fd800				IO_GAVIN             = $7FD800 ;1024 Bytes GAVIN I/O space
=$7fdc00				IO_SUPERIO           = $7FDC00 ;1024 Bytes SuperIO I/O space
=$7fe000				IO_VICKY             = $7FE000 ;1024 Bytes VICKY I/O space
=$7fe400				IO_BEATRIX           = $7FE400 ;1024 Bytes BEATRIX I/O space
=$7fe800				IO_RTC               = $7FE800 ;1024 Bytes RTC I/O space
=$7fec00				IO_CIA               = $7FEC00 ;4864 Bytes CIA I/O space
=$7fffff				IO_END               = $7FFFFF ; Byte  *End of I/O space

;******  Return to file: kernel.asm


;******  Processing file: dram_inc.asm

=$800000				SCREEN_PAGE0     = $800000 ;8192 Bytes First page of display RAM. This is used at boot time to display the welcome screen and the BASIC or MONITOR command screens.
=$802000				SCREEN_PAGE1     = $802000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$804000				SCREEN_PAGE2     = $804000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$806000				SCREEN_PAGE3     = $806000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$808000				SCREEN_END       = $808000 ;End of display memory

;******  Return to file: kernel.asm


;******  Processing file: keyboard_def.asm

=$7f1064				STATUS_PORT 	        =	$7F1064
=$7f1060				KBD_OUT_BUF 	        =	$7F1060
=$7f1060				KBD_INPT_BUF	        = 	$7F1060
=$7f1064				KBD_CMD_BUF		= 	$7F1064
=$7f1060				KBD_DATA_BUF	        = 	$7F1060
=$7f1060				PORT_A			= 	$7F1060
=$7f1061				PORT_B			= 	$7F1061
=$01					OUT_BUF_FULL	        = 	$01
=$02					INPT_BUF_FULL	        = 	$02
=$04					SYS_FLAG		= 	$04
=$08					CMD_DATA		=	$08
=$10					KEYBD_INH		=	$10
=$20					TRANS_TMOUT		=	$20
=$40					RCV_TMOUT		=	$40
=$80					PARITY_EVEN		=	$80
=$10					INH_KEYBOARD	        =	$10
=$ae					KBD_ENA			=	$AE
=$ad					KBD_DIS			=	$AD
=$f1					KB_MENU			=	$F1
=$f4					KB_ENABLE		=	$F4
=$f7					KB_MAKEBREAK	        =	$F7
=$fe					KB_ECHO			=	$FE
=$ff					KB_RESET		=	$FF
=$ed					KB_LED_CMD		=	$ED
=$aa					KB_OK			=	$AA
=$fa					KB_ACK			=	$FA
=$ff					KB_OVERRUN		=	$FF
=$fe					KB_RESEND		=	$FE
=$f0					KB_BREAK		=	$F0
=$10					KB_FA			=	$10
=$20					KB_FE			=	$20
=$40					KB_PR_LED		=	$40

;******  Return to file: kernel.asm


;******  Processing file: monitor.asm

.018000	5c 5c 80 01	jmp $01805c	MONITOR         JML IMONITOR
.018004	5c 88 80 01	jmp $018088	MSTATUS         JML IMSTATUS
.018008	5c 66 80 01	jmp $018066	MREADY          JML IMREADY
.01800c	5c 41 81 01	jmp $018141	MRETURN         JML IMRETURN
.018010	5c 45 81 01	jmp $018145	MPARSE          JML IMPARSE
.018014	5c 46 81 01	jmp $018146	MPARSE1         JML IMPARSE1
.018018	5c 47 81 01	jmp $018147	MEXECUTE        JML IMEXECUTE
.01801c	5c 48 81 01	jmp $018148	MASSEMBLE       JML IMASSEMBLE
.018020	5c 49 81 01	jmp $018149	MASSEMBLEA      JML IMASSEMBLEA
.018024	5c 4a 81 01	jmp $01814a	MCOMPARE        JML IMCOMPARE
.018028	5c 4b 81 01	jmp $01814b	MDISASSEMBLE    JML IMDISASSEMBLE
.01802c	5c 4c 81 01	jmp $01814c	MFILL           JML IMFILL
.018030	5c 4e 81 01	jmp $01814e	MJUMP           JML IMJUMP
.018034	5c 4f 81 01	jmp $01814f	MHUNT           JML IMHUNT
.018038	5c 50 81 01	jmp $018150	MLOAD           JML IMLOAD
.01803c	5c 51 81 01	jmp $018151	MMEMORY         JML IMMEMORY
.018040	5c 52 81 01	jmp $018152	MREGISTERS      JML IMREGISTERS
.018044	5c 53 81 01	jmp $018153	MSAVE           JML IMSAVE
.018048	5c 54 81 01	jmp $018154	MTRANSFER       JML IMTRANSFER
.01804c	5c 55 81 01	jmp $018155	MVERIFY         JML IMVERIFY
.018050	5c 56 81 01	jmp $018156	MEXIT           JML IMEXIT
.018054	5c 57 81 01	jmp $018157	MMODIFY         JML IMMODIFY
.018058	5c 58 81 01	jmp $018158	MDOS            JML IMDOS
.01805c	18		clc		IMONITOR        CLC           ; clear the carry flag
.01805d	fb		xce		                XCE           ; move carry to emulation flag.
.01805e	a9 ff fe	lda #$feff	                LDA #STACK_END ; Reset the stack
.018061	1b		tcs		                TAS
.018062	5c 66 80 01	jmp $018066	                JML IMREADY
.018066					IMREADY
.018066	c2 30		rep #$30	                REP #$30        ; set A&X long
.018068	a9 66 80	lda #$8066	                LDA #<>IMREADY
.01806b	8d e1 ff	sta $ffe1	                STA JMP_READY+1
.01806e	e2 20		sep #$20	                SEP #$20        ; set A short
.018070	a9 01		lda #$01	                LDA #`IMREADY
.018072	8d e3 ff	sta $ffe3	                STA JMP_READY+3
.018075	c2 20		rep #$20	                REP #$20        ; set A long
.018077	a9 41 81	lda #$8141	                LDA #<>IMRETURN
.01807a	8d f1 ff	sta $fff1	                STA RETURN+1
.01807d	e2 20		sep #$20	                SEP #$20        ; set A short
.01807f	a9 01		lda #$01	                LDA #`IMRETURN
.018081	8d f3 ff	sta $fff3	                STA RETURN+3
.018084	5c 88 80 01	jmp $018088	                JML IMSTATUS
.018088					IMSTATUS
.018088	48		pha		                PHA             ; begin setdbr macro
.018089	08		php		                PHP
.01808a	e2 20		sep #$20	                SEP #$20        ; set A short
.01808c	a9 01		lda #$01	                LDA #`MONITOR_DATA
.01808e	48		pha		                PHA
.01808f	ab		plb		                PLB
.018090	28		plp		                PLP
.018091	68		pla		                PLA             ; end setdbr macro
.018092	a2 5f 81	ldx #$815f	                LDX #<>mregisters_msg
.018095	22 10 05 01	jsl $010510	                JSL IPRINT
.018099	c2 10		rep #$10	                REP #$10        ; set X long
.01809b	e2 20		sep #$20	                SEP #$20        ; set A short
.01809d	48		pha		                PHA             ; begin setdbr macro
.01809e	08		php		                PHP
.01809f	e2 20		sep #$20	                SEP #$20        ; set A short
.0180a1	a9 00		lda #$00	                LDA #$0
.0180a3	48		pha		                PHA
.0180a4	ab		plb		                PLB
.0180a5	28		plp		                PLP
.0180a6	68		pla		                PLA             ; end setdbr macro
.0180a7	a9 3b		lda #$3b	                LDA #';'
.0180a9	22 30 05 01	jsl $010530	                JSL IPUTC
.0180ad	a0 03 00	ldy #$0003	                LDY #3
.0180b0	a2 02 02	ldx #$0202	                LDX #CPUPC+2
.0180b3	22 13 06 01	jsl $010613	                JSL IPRINTH
.0180b7	e2 20		sep #$20	                SEP #$20        ; set A short
.0180b9	a9 20		lda #$20	                LDA #' '
.0180bb	22 30 05 01	jsl $010530	                JSL IPUTC
.0180bf	a0 02 00	ldy #$0002	                LDY #2
.0180c2	a2 04 02	ldx #$0204	                LDX #CPUA+1
.0180c5	22 13 06 01	jsl $010613	                JSL IPRINTH
.0180c9	e2 20		sep #$20	                SEP #$20        ; set A short
.0180cb	a9 20		lda #$20	                LDA #' '
.0180cd	22 30 05 01	jsl $010530	                JSL IPUTC
.0180d1	a0 02 00	ldy #$0002	                LDY #2
.0180d4	a2 06 02	ldx #$0206	                LDX #CPUX+1
.0180d7	22 13 06 01	jsl $010613	                JSL IPRINTH
.0180db	e2 20		sep #$20	                SEP #$20        ; set A short
.0180dd	a9 20		lda #$20	                LDA #' '
.0180df	22 30 05 01	jsl $010530	                JSL IPUTC
.0180e3	a0 02 00	ldy #$0002	                LDY #2
.0180e6	a2 08 02	ldx #$0208	                LDX #CPUY+1
.0180e9	22 13 06 01	jsl $010613	                JSL IPRINTH
.0180ed	e2 20		sep #$20	                SEP #$20        ; set A short
.0180ef	a9 20		lda #$20	                LDA #' '
.0180f1	22 30 05 01	jsl $010530	                JSL IPUTC
.0180f5	a0 02 00	ldy #$0002	                LDY #2
.0180f8	a2 0a 02	ldx #$020a	                LDX #CPUSTACK+1
.0180fb	22 13 06 01	jsl $010613	                JSL IPRINTH
.0180ff	e2 20		sep #$20	                SEP #$20        ; set A short
.018101	a9 20		lda #$20	                LDA #' '
.018103	22 30 05 01	jsl $010530	                JSL IPUTC
.018107	a0 01 00	ldy #$0001	                LDY #1
.01810a	a2 0d 02	ldx #$020d	                LDX #CPUDBR
.01810d	22 13 06 01	jsl $010613	                JSL IPRINTH
.018111	e2 20		sep #$20	                SEP #$20        ; set A short
.018113	a9 20		lda #$20	                LDA #' '
.018115	22 30 05 01	jsl $010530	                JSL IPUTC
.018119	22 30 05 01	jsl $010530	                JSL IPUTC
.01811d	a0 02 00	ldy #$0002	                LDY #2
.018120	a2 0c 02	ldx #$020c	                LDX #CPUDP+1
.018123	22 13 06 01	jsl $010613	                JSL IPRINTH
.018127	e2 20		sep #$20	                SEP #$20        ; set A short
.018129	a9 20		lda #$20	                LDA #' '
.01812b	22 30 05 01	jsl $010530	                JSL IPUTC
.01812f	a0 01 00	ldy #$0001	                LDY #1
.018132	a2 0e 02	ldx #$020e	                LDX #CPUFLAGS
.018135	22 13 06 01	jsl $010613	                JSL IPRINTH
.018139	22 4e 05 01	jsl $01054e	                JSL IPRINTCR
.01813d	5c ce 04 01	jmp $0104ce	                JML IREADYWAIT
.018141	48		pha		IMRETURN        PHA     ; Store the registers
.018142	da		phx		                PHX
.018143	5a		phy		                PHY
.018144	08		php		                PHP
.018145	00		brk #		IMPARSE         BRK ; Parse the current command line
.018146	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.018147	00		brk #		IMEXECUTE       BRK ; Execute the current command line (requires MCMD and MARG1-MARG8 to be populated)
.018148	00		brk #		IMASSEMBLE      BRK ; Assemble a line of text.
.018149	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.01814a	00		brk #		IMCOMPARE       BRK ; Compare memory. len=1
.01814b	00		brk #		IMDISASSEMBLE   BRK ; Disassemble memory. end=1 instruction
.01814c	00		brk #		IMFILL          BRK ; Fill memory with specified value. Start and end must be in the same bank.
.01814d	00		brk #		IMGO            BRK ; Execute from specified address
.01814e	00		brk #		IMJUMP          BRK ; Execute from spefified address
.01814f	00		brk #		IMHUNT          BRK ; Hunt (find) value in memory
.018150	00		brk #		IMLOAD          BRK ; Load data from disk. Device=1 (internal floppy) Start=Address in file
.018151	00		brk #		IMMEMORY        BRK ; View memory
.018152	00		brk #		IMREGISTERS     BRK ; View/edit registers
.018153	00		brk #		IMSAVE          BRK ; Save memory to disk
.018154	00		brk #		IMTRANSFER      BRK ; Transfer (copy) data in memory
.018155	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.018156	00		brk #		IMEXIT          BRK ; Exit monitor and return to BASIC command prompt
.018157	00		brk #		IMMODIFY        BRK ; Modify memory
.018158	00		brk #		IMDOS           BRK ; Execute DOS command
.018159					MONITOR_DATA
>018159	45 52 52 4f 52 00		MMERROR         .null "ERROR"
>01815f	0d 20 50 43 20 20 20 20		mregisters_msg  .null $0D," PC     A    X    Y    SP   DBR DP   NVMXDIZC"
>018167	20 41 20 20 20 20 58 20 20 20 20 59 20 20 20 20
>018177	53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e 56
>018187	4d 58 44 49 5a 43 00

;******  Return to file: kernel.asm


;******  Processing file: kernel_jumptable.asm

.010000	5c 00 04 01	jmp $010400	BOOT            JML IBOOT
.010004	5c 72 08 01	jmp $010872	RESTORE         JML IRESTORE
.010008	5c 74 04 01	jmp $010474	BREAK           JML IBREAK
.01000c	5c bb 04 01	jmp $0104bb	READY           JML IREADY
.010010	5c 73 08 01	jmp $010873	SCINIT          JML ISCINIT
.010014	5c 74 08 01	jmp $010874	IOINIT          JML IIOINIT
.010018	5c 30 05 01	jmp $010530	PUTC            JML IPUTC
.01001c	5c 19 05 01	jmp $010519	PUTS            JML IPUTS
.010020	5c 4d 05 01	jmp $01054d	PUTB            JML IPUTB
.010024	5c 75 08 01	jmp $010875	PUTBLOCK        JML IPUTBLOCK
.010028	5c 76 08 01	jmp $010876	SETLFS          JML ISETLFS
.01002c	5c 77 08 01	jmp $010877	SETNAM          JML ISETNAM
.010030	5c 78 08 01	jmp $010878	OPEN            JML IOPEN
.010034	5c 79 08 01	jmp $010879	CLOSE           JML ICLOSE
.010038	5c 7a 08 01	jmp $01087a	SETIN           JML ISETIN
.01003c	5c 7b 08 01	jmp $01087b	SETOUT          JML ISETOUT
.010040	5c 7c 08 01	jmp $01087c	GETB            JML IGETB
.010044	5c 7d 08 01	jmp $01087d	GETBLOCK        JML IGETBLOCK
.010048	5c 7e 08 01	jmp $01087e	GETCH           JML IGETCH
.01004c	5c df 04 01	jmp $0104df	GETCHW          JML IGETCHW
.010050	5c d6 04 01	jmp $0104d6	GETCHE          JML IGETCHE
.010054	5c 7f 08 01	jmp $01087f	GETS            JML IGETS
.010058	5c 80 08 01	jmp $010880	GETLINE         JML IGETLINE
.01005c	5c 81 08 01	jmp $010881	GETFIELD        JML IGETFIELD
.010060	5c 82 08 01	jmp $010882	TRIM            JML ITRIM
.010064	5c 83 08 01	jmp $010883	PRINTC          JML IPRINTC
.010068	5c 84 08 01	jmp $010884	PRINTS          JML IPRINTS
.01006c	5c 4e 05 01	jmp $01054e	PRINTCR         JML IPRINTCR
.010070	5c 85 08 01	jmp $010885	PRINTF          JML IPRINTF
.010074	5c 86 08 01	jmp $010886	PRINTI          JML IPRINTI
.010078	5c 13 06 01	jmp $010613	PRINTH          JML IPRINTH
.01007c	5c 87 08 01	jmp $010887	PRINTAI         JML IPRINTAI
.010080	5c 88 08 01	jmp $010888	PRINTAH         JML IPRINTAH
.010084	5c a0 05 01	jmp $0105a0	LOCATE          JML ILOCATE
.010088	5c 89 08 01	jmp $010889	PUSHKEY         JML IPUSHKEY
.01008c	5c 8a 08 01	jmp $01088a	PUSHKEYS        JML IPUSHKEYS
.010090	5c 71 05 01	jmp $010571	CSRRIGHT        JML ICSRRIGHT
.010094	5c 8b 08 01	jmp $01088b	CSRLEFT         JML ICSRLEFT
.010098	5c 9e 05 01	jmp $01059e	CSRUP           JML ICSRUP
.01009c	5c 9f 05 01	jmp $01059f	CSRDOWN         JML ICSRDOWN
.0100a0	5c 8c 08 01	jmp $01088c	CSRHOME         JML ICSRHOME
.0100a4	5c d6 05 01	jmp $0105d6	SCROLLUP        JML ISCROLLUP
.0100a8	5c 41 06 01	jmp $010641	CLRSCREEN       JML ICLRSCREEN
.0100ac	5c 9d 06 01	jmp $01069d	INITCHLUT	JML IINITCHLUT
.0100b0	5c cc 06 01	jmp $0106cc	INITSUPERIO	JML IINITSUPERIO
.0100b4	5c cd 07 01	jmp $0107cd	INITKEYBOARD	JML IINITKEYBOARD

;******  Return to file: kernel.asm

.010400					IBOOT
.010400	18		clc		                CLC                 ; clear the carry flag
.010401	fb		xce		                XCE                 ; move carry to emulation flag.
.010402	c2 30		rep #$30	                REP #$30        ; set A&X long
.010404	a9 ff fe	lda #$feff	                LDA #STACK_END      ; initialize stack pointer
.010407	1b		tcs		                TAS
.010408	48		pha		                PHA             ; begin setdp macro
.010409	08		php		                PHP
.01040a	c2 20		rep #$20	                REP #$20        ; set A long
.01040c	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.01040f	5b		tcd		                TCD
.010410	28		plp		                PLP
.010411	68		pla		                PLA             ; end setdp macro
.010412	a9 00 80	lda #$8000	                LDA #<>TEXT_PAGE0 ; store initial screen buffer location
.010415	85 0c		sta $0c		                STA SCREENBEGIN
.010417	e2 20		sep #$20	                SEP #$20        ; set A short
.010419	a9 02		lda #$02	                LDA #`TEXT_PAGE0
.01041b	85 0e		sta $0e		                STA SCREENBEGIN+2
.01041d	c2 30		rep #$30	                REP #$30        ; set A&X long
.01041f	a9 00 80	lda #$8000	                LDA #<>TEXT_PAGE0 ; store initial screen buffer location
.010422	85 17		sta $17		                STA CURSORPOS
.010424	e2 20		sep #$20	                SEP #$20        ; set A short
.010426	a9 02		lda #$02	                LDA #`TEXT_PAGE0
.010428	85 19		sta $19		                STA CURSORPOS+2
.01042a	c2 30		rep #$30	                REP #$30        ; set A&X long
.01042c	a2 50 00	ldx #$0050	                LDX #80
.01042f	86 0f		stx $0f		                STX COLS_VISIBLE
.010431	a0 3c 00	ldy #$003c	                LDY #60
.010434	84 13		sty $13		                STY LINES_VISIBLE
.010436	a2 80 00	ldx #$0080	                LDX #128
.010439	86 11		stx $11		                STX COLS_PER_LINE
.01043b	a0 40 00	ldy #$0040	                LDY #64
.01043e	84 15		sty $15		                STY LINES_MAX
.010440	22 41 06 01	jsl $010641	                JSL ICLRSCREEN
.010444	c2 20		rep #$20	                REP #$20        ; set A long
.010446	a2 00 00	ldx #$0000	                LDX #$0
.010449	a0 00 00	ldy #$0000	                LDY #$0
.01044c	22 a0 05 01	jsl $0105a0	                JSL ILOCATE
.010450	9c 41 0f	stz $0f41	                STZ KEY_BUFFER_RPOS
.010453	9c 43 0f	stz $0f43	                STZ KEY_BUFFER_WPOS
.010456					greet
.010456	48		pha		                PHA             ; begin setdbr macro
.010457	08		php		                PHP
.010458	e2 20		sep #$20	                SEP #$20        ; set A short
.01045a	a9 01		lda #$01	                LDA #`greet_msg
.01045c	48		pha		                PHA
.01045d	ab		plb		                PLB
.01045e	28		plp		                PLP
.01045f	68		pla		                PLA             ; end setdbr macro
.010460	a2 8f 08	ldx #$088f	                LDX #<>greet_msg
.010463	22 10 05 01	jsl $010510	                JSL IPRINT       ; print the first line
.010467	e2 20		sep #$20	                SEP #$20        ; set A short
.010469	48		pha		                PHA             ; begin setdbr macro
.01046a	08		php		                PHP
.01046b	e2 20		sep #$20	                SEP #$20        ; set A short
.01046d	a9 01		lda #$01	                LDA #$01
.01046f	48		pha		                PHA
.010470	ab		plb		                PLB
.010471	28		plp		                PLP
.010472	68		pla		                PLA             ; end setdbr macro
.010473	00		brk #		greet_done      BRK             ;Terminate boot routine and go to Ready handler.
.010474					IBREAK
.010474	48		pha		                PHA             ; begin setdp macro
.010475	08		php		                PHP
.010476	c2 20		rep #$20	                REP #$20        ; set A long
.010478	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.01047b	5b		tcd		                TCD
.01047c	28		plp		                PLP
.01047d	68		pla		                PLA             ; end setdp macro
.01047e	68		pla		                PLA             ; Pull .Y and stuff it in the CPUY variable
.01047f	8f 07 02 00	sta $000207	                STA CPUY
.010483	68		pla		                PLA             ; Pull .X and stuff it in the CPUY variable
.010484	8f 05 02 00	sta $000205	                STA CPUX
.010488	68		pla		                PLA             ; Pull .A and stuff it in the CPUY variable
.010489	8f 03 02 00	sta $000203	                STA CPUA
.01048d	68		pla		                PLA
.01048e	8f 0b 02 00	sta $00020b	                STA CPUDP       ; Pull Direct page
.010492	e2 20		sep #$20	                SEP #$20        ; set A short
.010494	68		pla		                PLA             ; Pull Data Bank (8 bits)
.010495	8f 0d 02 00	sta $00020d	                STA CPUDBR
.010499	68		pla		                PLA             ; Pull Flags (8 bits)
.01049a	8f 0e 02 00	sta $00020e	                STA CPUFLAGS
.01049e	c2 20		rep #$20	                REP #$20        ; set A long
.0104a0	68		pla		                PLA             ; Pull Program Counter (16 bits)
.0104a1	8f 00 02 00	sta $000200	                STA CPUPC
.0104a5	e2 20		sep #$20	                SEP #$20        ; set A short
.0104a7	68		pla		                PLA             ; Pull Program Bank (8 bits)
.0104a8	8f 02 02 00	sta $000202	                STA CPUPBR
.0104ac	c2 20		rep #$20	                REP #$20        ; set A long
.0104ae	3b		tsc		                TSA             ; Get the stack
.0104af	8f 09 02 00	sta $000209	                STA CPUSTACK    ; Store the stack at immediately before the interrupt was asserted
.0104b3	a9 ff fe	lda #$feff	                LDA #<>STACK_END   ; initialize stack pointer back to the bootup value
.0104b6	1b		tcs		                TAS
.0104b7	5c e0 ff 00	jmp $00ffe0	                JML JMP_READY   ; Run READY routine (usually BASIC or MONITOR)
.0104bb					IREADY
.0104bb	48		pha		                PHA             ; begin setdbr macro
.0104bc	08		php		                PHP
.0104bd	e2 20		sep #$20	                SEP #$20        ; set A short
.0104bf	a9 01		lda #$01	                LDA #`ready_msg
.0104c1	48		pha		                PHA
.0104c2	ab		plb		                PLB
.0104c3	28		plp		                PLP
.0104c4	68		pla		                PLA             ; end setdbr macro
.0104c5	e2 20		sep #$20	                SEP #$20        ; set A short
.0104c7	a2 33 0a	ldx #$0a33	                LDX #<>ready_msg
.0104ca	22 10 05 01	jsl $010510	                JSL IPRINT
.0104ce					IREADYWAIT
.0104ce	22 d6 04 01	jsl $0104d6	                JSL IGETCHE
.0104d2	80 fa		bra $0104ce	                BRA IREADYWAIT
.0104d4	db		stp		IKEYDOWN        STP             ; Keyboard key pressed
.0104d5	db		stp		IRETURN         STP
.0104d6	22 df 04 01	jsl $0104df	IGETCHE         JSL IGETCHW
.0104da	22 30 05 01	jsl $010530	                JSL IPUTC
.0104de	6b		rtl		                RTL
.0104df	0b		phd		IGETCHW         PHD
.0104e0	da		phx		                PHX
.0104e1	08		php		                PHP
.0104e2	48		pha		                PHA             ; begin setdp macro
.0104e3	08		php		                PHP
.0104e4	c2 20		rep #$20	                REP #$20        ; set A long
.0104e6	a9 00 0f	lda #$0f00	                LDA #$0F00         ; set DP to page 0
.0104e9	5b		tcd		                TCD
.0104ea	28		plp		                PLP
.0104eb	68		pla		                PLA             ; end setdp macro
.0104ec	c2 30		rep #$30	                REP #$30        ; set A&X long
.0104ee	a6 41		ldx $0f41	igetchw1        LDX KEY_BUFFER_RPOS
.0104f0	e4 43		cpx $0f43	                CPX KEY_BUFFER_WPOS
.0104f2	d0 05		bne $0104f9	                BNE igetchw2
>0104f4	42 00				                .byte $42, $00
.0104f6	4c ee 04	jmp $0104ee	                JMP igetchw1
.0104f9	b5 00		lda $0f00,x	igetchw2        LDA $0,D,X  ; Read the value in the keyboard buffer
.0104fb	48		pha		                PHA
.0104fc	8a		txa		                TXA
.0104fd	18		clc		                CLC
.0104fe	69 02 00	adc #$0002	                ADC #$02
.010501	c9 40 00	cmp #$0040	                CMP #KEY_BUFFER_SIZE
.010504	90 03		bcc $010509	                BCC igetchw3
.010506	a9 00 00	lda #$0000	                LDA #$0
.010509	85 41		sta $0f41	igetchw3        STA KEY_BUFFER_RPOS
.01050b	68		pla		                PLA
.01050c	28		plp		igetchw_done    PLP
.01050d	fa		plx		                PLX             ; Restore the saved registers and return
.01050e	2b		pld		                PLD
.01050f	6b		rtl		                RTL
.010510	22 19 05 01	jsl $010519	IPRINT          JSL IPUTS
.010514	22 4e 05 01	jsl $01054e	                JSL IPRINTCR
.010518	6b		rtl		                RTL
.010519	48		pha		IPUTS           PHA
.01051a	08		php		                PHP
.01051b	e2 20		sep #$20	                SEP #$20        ; set A short
.01051d	c2 10		rep #$10	                REP #$10        ; set X long
.01051f	bd 00 00	lda $010000,x	iputs1          LDA $0,b,x      ; read from the string
.010522	f0 08		beq $01052c	                BEQ iputs_done
.010524	22 30 05 01	jsl $010530	iputs2          JSL IPUTC
.010528	e8		inx		iputs3          INX
.010529	4c 1f 05	jmp $01051f	                JMP iputs1
.01052c	e8		inx		iputs_done      INX
.01052d	28		plp		                PLP
.01052e	68		pla		                PLA
.01052f	6b		rtl		                RTL
.010530					IPUTC
.010530	e2 20		sep #$20	                SEP #$20        ; set A short
.010532	c9 0d		cmp #$0d	                CMP #$0D        ; handle CR
.010534	d0 06		bne $01053c	                BNE iputc_bs
.010536	22 4e 05 01	jsl $01054e	                JSL IPRINTCR
.01053a	80 10		bra $01054c	                BRA iputc_done
.01053c	c9 08		cmp #$08	iputc_bs        CMP #$08        ; backspace
.01053e	d0 06		bne $010546	                BNE iputc_print
.010540	22 61 05 01	jsl $010561	                JSL IPRINTBS
.010544	80 06		bra $01054c	                BRA iputc_done
.010546	87 17		sta [$17]	iputc_print     STA [CURSORPOS] ; Save the character on the screen
.010548	22 71 05 01	jsl $010571	                JSL ICSRRIGHT
.01054c	6b		rtl		iputc_done	RTL
.01054d					IPUTB
.01054d	6b		rtl		                RTL
.01054e	48		pha		IPRINTCR	PHA
.01054f	da		phx		                PHX
.010550	5a		phy		                PHY
.010551	08		php		                PHP
.010552	a2 00 00	ldx #$0000	                LDX #0
.010555	a4 20		ldy $20		                LDY CURSOR_Y
.010557	c8		iny		                INY
.010558	22 a0 05 01	jsl $0105a0	                JSL ILOCATE
.01055c	28		plp		                PLP
.01055d	7a		ply		                PLY
.01055e	fa		plx		                PLX
.01055f	68		pla		                PLA
.010560	6b		rtl		                RTL
.010561	da		phx		IPRINTBS	PHX
.010562	5a		phy		                PHY
.010563	08		php		                PHP
.010564	a6 1e		ldx $1e		                LDX CURSOR_X
.010566	a4 20		ldy $20		                LDY CURSOR_Y
.010568	ca		dex		                DEX
.010569	22 a0 05 01	jsl $0105a0	                JSL ILOCATE
.01056d	28		plp		                PLP
.01056e	7a		ply		                PLY
.01056f	fa		plx		                PLX
.010570	6b		rtl		                RTL
.010571					ICSRRIGHT
.010571	da		phx		                PHX
.010572	8b		phb		                PHB
.010573	08		php		                PHP
.010574	c2 20		rep #$20	                REP #$20        ; set A long
.010576	c2 10		rep #$10	                REP #$10        ; set X long
.010578	48		pha		                PHA             ; begin setdp macro
.010579	08		php		                PHP
.01057a	c2 20		rep #$20	                REP #$20        ; set A long
.01057c	a9 00 00	lda #$0000	                LDA #$0         ; set DP to page 0
.01057f	5b		tcd		                TCD
.010580	28		plp		                PLP
.010581	68		pla		                PLA             ; end setdp macro
.010582	e6 17		inc $17		                INC CURSORPOS
.010584	a6 1e		ldx $1e		                LDX CURSOR_X
.010586	e8		inx		                INX
.010587	e4 0f		cpx $0f		                CPX COLS_VISIBLE
.010589	90 0c		bcc $010597	                BCC icsr_nowrap  ; wrap if the cursor is at or past column 80
.01058b	a2 00 00	ldx #$0000	                LDX #0
.01058e	5a		phy		                PHY
.01058f	a4 20		ldy $20		                LDY CURSOR_Y
.010591	c8		iny		                INY
.010592	22 a0 05 01	jsl $0105a0	                JSL ILOCATE
.010596	7a		ply		                PLY
.010597	86 1e		stx $1e		icsr_nowrap     STX CURSOR_X
.010599	28		plp		                PLP
.01059a	ab		plb		                PLB
.01059b	fa		plx		                PLX
.01059c	6b		rtl		                RTL
.01059d	6b		rtl		ISRLEFT	        RTL
.01059e	6b		rtl		ICSRUP	        RTL
.01059f	6b		rtl		ICSRDOWN	RTL
.0105a0	48		pha		ILOCATE         PHA
.0105a1	08		php		                PHP
.0105a2	c2 30		rep #$30	                REP #$30        ; set A&X long
.0105a4					ilocate_scroll
.0105a4	c4 13		cpy $13		                CPY LINES_VISIBLE
.0105a6	90 07		bcc $0105af	                BCC ilocate_scrolldone
.0105a8	22 d6 05 01	jsl $0105d6	                JSL ISCROLLUP
.0105ac	88		dey		                DEY
.0105ad	80 f5		bra $0105a4	                BRA ilocate_scroll
.0105af					ilocate_scrolldone
.0105af	86 1e		stx $1e		                STX CURSOR_X
.0105b1	84 20		sty $20		                STY CURSOR_Y
.0105b3	a5 0c		lda $0c		                LDA SCREENBEGIN
.0105b5					ilocate_row
.0105b5	c0 00 00	cpy #$0000	                CPY #$0
.0105b8	f0 08		beq $0105c2	                BEQ ilocate_right
.0105ba	18		clc		ilocate_down    CLC
.0105bb	65 11		adc $11		                ADC COLS_PER_LINE
.0105bd	88		dey		                DEY
.0105be	f0 02		beq $0105c2	                BEQ ilocate_right
.0105c0	80 f8		bra $0105ba	                BRA ilocate_down
.0105c2	18		clc		ilocate_right   CLC
.0105c3	65 1e		adc $1e		                ADC CURSOR_X             ; move the cursor right X columns
.0105c5	85 17		sta $17		                STA CURSORPOS
.0105c7	a4 20		ldy $20		                LDY CURSOR_Y
.0105c9					ilocate_done
.0105c9	8a		txa		                TXA
.0105ca	8f 0c 00 7f	sta $7f000c	                STA TXT_CURSOR_X_REG_L
.0105ce	98		tya		                TYA
.0105cf	8f 0e 00 7f	sta $7f000e	                STA TXT_CURSOR_Y_REG_L
.0105d3	28		plp		                PLP
.0105d4	68		pla		                PLA
.0105d5	6b		rtl		                RTL
.0105d6					ISCROLLUP
.0105d6	48		pha		                PHA
.0105d7	da		phx		                PHX
.0105d8	5a		phy		                PHY
.0105d9	8b		phb		                PHB
.0105da	08		php		                PHP
.0105db	c2 30		rep #$30	                REP #$30        ; set A&X long
.0105dd	a2 80 80	ldx #$8080	                LDX #<>TEXT_PAGE0+128
.0105e0	a0 00 80	ldy #$8000	                LDY #<>TEXT_PAGE0
.0105e3	a9 7f 1f	lda #$1f7f	                LDA #8063
.0105e6	44 02 02	mvp $02,$02	                MVP `TEXT_PAGE0,`TEXT_PAGE0
.0105e9	a2 80 a0	ldx #$a080	                LDX #<>TEXT_PAGE1+128
.0105ec	a0 00 a0	ldy #$a000	                LDY #<>TEXT_PAGE1
.0105ef	a9 7f 1f	lda #$1f7f	                LDA #8063
.0105f2	44 02 02	mvp $02,$02	                MVP `TEXT_PAGE0,`TEXT_PAGE0
.0105f5	a2 80 c0	ldx #$c080	                LDX #<>TEXT_PAGE2+128
.0105f8	a0 00 c0	ldy #$c000	                LDY #<>TEXT_PAGE2
.0105fb	a9 7f 1f	lda #$1f7f	                LDA #8063
.0105fe	44 02 02	mvp $02,$02	                MVP `TEXT_PAGE0,`TEXT_PAGE0
.010601	a2 80 e0	ldx #$e080	                LDX #<>TEXT_PAGE3+128
.010604	a0 00 e0	ldy #$e000	                LDY #<>TEXT_PAGE3
.010607	a9 7f 1f	lda #$1f7f	                LDA #8063
.01060a	44 02 02	mvp $02,$02	                MVP `TEXT_PAGE0,`TEXT_PAGE0
.01060d					iscrollup_done
.01060d	28		plp		                PLP
.01060e	ab		plb		                PLB
.01060f	7a		ply		                PLY
.010610	fa		plx		                PLX
.010611	68		pla		                PLA
.010612	6b		rtl		                RTL
.010613	48		pha		IPRINTH         PHA
.010614	08		php		                PHP
.010615					iprinth1
.010615	e2 20		sep #$20	                SEP #$20        ; set A short
.010617	bd 00 00	lda $010000,x	                LDA #0,b,x      ; Read the value to be printed
.01061a	4a		lsr a		                LSR
.01061b	4a		lsr a		                LSR
.01061c	4a		lsr a		                LSR
.01061d	4a		lsr a		                LSR
.01061e	22 30 06 01	jsl $010630	                JSL iprint_digit
.010622	bd 00 00	lda $010000,x	                LDA #0,b,x
.010625	22 30 06 01	jsl $010630	                JSL iprint_digit
.010629	ca		dex		                DEX
.01062a	88		dey		                DEY
.01062b	d0 e8		bne $010615	                BNE iprinth1
.01062d	28		plp		                PLP
.01062e	68		pla		                PLA
.01062f	6b		rtl		                RTL
.010630	da		phx		iprint_digit    PHX
.010631	c2 20		rep #$20	                REP #$20        ; set A long
.010633	29 0f 00	and #$000f	                AND #$0F
.010636	aa		tax		                TAX
.010637	bf ef 0a 01	lda $010aef,x	                LDA hex_digits,X
.01063b	22 30 05 01	jsl $010530	                JSL IPUTC       ; Print the digit
.01063f	fa		plx		                PLX
.010640	6b		rtl		                RTL
.010641	0b		phd		ICLRSCREEN	PHD
.010642	48		pha		                PHA
.010643	5a		phy		                PHY
.010644	08		php		                PHP
.010645	e2 20		sep #$20	                SEP #$20        ; set A short
.010647	c2 10		rep #$10	                REP #$10        ; set X long
.010649	a0 00 00	ldy #$0000	                LDY #$0000		; We'll use X to loop through screen memory
.01064c	a9 20		lda #$20	                LDA #$20		; Fill the Entire Screen with Space
.01064e	97 0c		sta [$0c],y	iclearloop0     STA [SCREENBEGIN],Y	;
.010650	c8		iny		                INY
.010651	c0 00 20	cpy #$2000	                CPY #TEXT_PAGE_SIZE
.010654	d0 f8		bne $01064e	                BNE iclearloop0
.010656	a9 ed		lda #$ed	                LDA #$ED		; Fill the Color Memory with Foreground: 75% Purple, Background 12.5% White
.010658	97 0c		sta [$0c],y	iclearloop1   	STA [SCREENBEGIN],Y	;
.01065a	c8		iny		                INY
.01065b	c0 00 40	cpy #$4000	                CPY #TEXT_PAGE_SIZE*2
.01065e	d0 f8		bne $010658	                BNE iclearloop1
.010660	28		plp		                PLP
.010661	7a		ply		                PLY
.010662	68		pla		                PLA
.010663	2b		pld		                PLD
.010664	6b		rtl		                RTL
.010665	48		pha		ICOLORFLAG      PHA
.010666	da		phx		                PHX
.010667	08		php		                PHP
.010668	e2 30		sep #$30	                SEP #$30        ; set A&X short
.01066a	a2 00		ldx #$00	                LDX #$00
.01066c	bf 6d 09 01	lda $01096d,x	iclearloop2	    LDA @lgreet_clr_line1,x
.010670	9f 00 20 80	sta $802000,x	                STA $802000,x
.010674	bf 7b 09 01	lda $01097b,x	                LDA @lgreet_clr_line2,x
.010678	9f 80 20 80	sta $802080,x	                STA $802080,x
.01067c	bf 89 09 01	lda $010989,x	                LDA @lgreet_clr_line3,x
.010680	9f 00 21 80	sta $802100,x	                STA $802100,x
.010684	bf 97 09 01	lda $010997,x	                LDA @lgreet_clr_line4,x
.010688	9f 80 21 80	sta $802180,x	                STA $802180,x
.01068c	bf a5 09 01	lda $0109a5,x	                LDA @lgreet_clr_line5,x
.010690	9f 00 22 80	sta $802200,x	                STA $802200,x
.010694	e8		inx		                inx
.010695	e0 0e		cpx #$0e	                cpx #$0E
.010697	d0 d3		bne $01066c	                bne iclearloop2
.010699	28		plp		                PLP
.01069a	fa		plx		                PLX
.01069b	68		pla		                PLA
.01069c	6b		rtl		                RTL
.01069d	0b		phd		IINITCHLUT		PHD
.01069e	08		php		      				PHP
.01069f	48		pha		      				PHA
.0106a0	da		phx		      				PHX
.0106a1	e2 20		sep #$20	                SEP #$20        ; set A short
.0106a3	e2 10		sep #$10	                SEP #$10        ; set X short
.0106a5	a2 00		ldx #$00	        			LDX	#$00
.0106a7	bf b3 09 01	lda $0109b3,x	lutinitloop0	LDA @lfg_color_lut,x		; get Local Data
.0106ab	9f 40 1f 7f	sta $7f1f40,x	      				STA FG_CHAR_LUT_PTR,x	; Write in LUT Memory
.0106af	e8		inx		      				inx
.0106b0	e0 40		cpx #$40	      				cpx #$40
.0106b2	d0 f3		bne $0106a7	      				bne lutinitloop0
.0106b4	a2 00		ldx #$00	      				LDX	#$00
.0106b6	bf f3 09 01	lda $0109f3,x	lutinitloop1	LDA @lbg_color_lut,x		; get Local Data
.0106ba	9f 80 1f 7f	sta $7f1f80,x	      				STA BG_CHAR_LUT_PTR,x	; Write in LUT Memory
.0106be	e8		inx		      				inx
.0106bf	e0 40		cpx #$40	      				cpx #$40
.0106c1	d0 f3		bne $0106b6	      				bne lutinitloop1
.0106c3	c2 20		rep #$20	                REP #$20        ; set A long
.0106c5	c2 10		rep #$10	                REP #$10        ; set X long
.0106c7	fa		plx		              PLX
.0106c8	68		pla		              PLA
.0106c9	28		plp						      PLP
.0106ca	2b		pld		              PLD
.0106cb	6b		rtl		              RTL
.0106cc	0b		phd		IINITSUPERIO	PHD
.0106cd	08		php		      				PHP
.0106ce	48		pha		      				PHA
.0106cf	e2 20		sep #$20	                SEP #$20        ; set A short
.0106d1	a9 01		lda #$01	      				LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.0106d3	8f 23 11 7f	sta $7f1123	      				STA GP10_REG
.0106d7	a9 01		lda #$01	      				LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.0106d9	8f 24 11 7f	sta $7f1124	      				STA GP11_REG
.0106dd	a9 01		lda #$01	      				LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.0106df	8f 25 11 7f	sta $7f1125	      				STA GP12_REG
.0106e3	a9 01		lda #$01	      				LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.0106e5	8f 26 11 7f	sta $7f1126	      				STA GP13_REG
.0106e9	a9 05		lda #$05	      				LDA #$05		;(C256 - POT A Analog BX) Bit[0] = 1, Bit[2] = 1
.0106eb	8f 27 11 7f	sta $7f1127	      				STA GP14_REG
.0106ef	a9 05		lda #$05	      				LDA #$05		;(C256 - POT A Analog BY) Bit[0] = 1, Bit[2] = 1
.0106f1	8f 28 11 7f	sta $7f1128	      				STA GP15_REG
.0106f5	a9 05		lda #$05	      				LDA #$05		;(C256 - POT B Analog BX) Bit[0] = 1, Bit[2] = 1
.0106f7	8f 29 11 7f	sta $7f1129	      				STA GP16_REG
.0106fb	a9 05		lda #$05	      				LDA #$05		;(C256 - POT B Analog BY) Bit[0] = 1, Bit[2] = 1
.0106fd	8f 2a 11 7f	sta $7f112a	      				STA GP17_REG
.010701	a9 00		lda #$00	      				LDA #$00		;(C256 - HEADPHONE MUTE) - Output GPIO - Push-Pull (1 - Headphone On, 0 - HeadPhone Off)
.010703	8f 2b 11 7f	sta $7f112b	      				STA GP20_REG
.010707	a9 01		lda #$01	              LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.010709	8f 2f 11 7f	sta $7f112f	              STA GP24_REG
.01070d	a9 05		lda #$05	              LDA #$05		;(C256 - MIDI IN) Bit[0] = 1, Bit[2] = 1 (Page 132 Manual)
.01070f	8f 30 11 7f	sta $7f1130	              STA GP25_REG
.010713	a9 84		lda #$84	              LDA #$84		;(C256 - MIDI OUT) Bit[2] = 1, Bit[7] = 1 (Open Drain - To be Checked)
.010715	8f 31 11 7f	sta $7f1131	              STA GP26_REG
.010719	a9 01		lda #$01	              LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.01071b	8f 2f 11 7f	sta $7f112f	              STA GP24_REG
.01071f	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 1) Setup as GPIO Input for now
.010721	8f 33 11 7f	sta $7f1133	              STA GP30_REG
.010725	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 4) Setup as GPIO Input for now
.010727	8f 34 11 7f	sta $7f1134	              STA GP31_REG
.01072b	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 3) Setup as GPIO Input for now
.01072d	8f 35 11 7f	sta $7f1135	              STA GP32_REG
.010731	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 6) Setup as GPIO Input for now
.010733	8f 36 11 7f	sta $7f1136	              STA GP33_REG
.010737	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 5) Setup as GPIO Input for now
.010739	8f 37 11 7f	sta $7f1137	              STA GP34_REG
.01073d	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 8) Setup as GPIO Input for now
.01073f	8f 38 11 7f	sta $7f1138	              STA GP35_REG
.010743	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 7) Setup as GPIO Input for now
.010745	8f 39 11 7f	sta $7f1139	              STA GP36_REG
.010749	a9 01		lda #$01	              LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 10) Setup as GPIO Input for now
.01074b	8f 3a 11 7f	sta $7f113a	              STA GP37_REG
.01074f	a9 01		lda #$01	              LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.010751	8f 3d 11 7f	sta $7f113d	              STA GP42_REG
.010755	a9 01		lda #$01	              LDA #$01		;(C256 - INPUT PLL CLK INTERRUPT) Default Value - Will keep it as an input for now, no real usage for now
.010757	8f 3e 11 7f	sta $7f113e	              STA GP43_REG
.01075b	a9 05		lda #$05	              LDA #$05		;(C256 - UART2 - RI2) - Input - Set Secondary Function
.01075d	8f 3f 11 7f	sta $7f113f	              STA GP50_REG
.010761	a9 05		lda #$05	              LDA #$05		;(C256 - UART2 - DCD2) - Input - Set Secondary Function
.010763	8f 40 11 7f	sta $7f1140	              STA GP51_REG
.010767	a9 05		lda #$05	              LDA #$05		;(C256 - UART2 - RXD2) - Input - Set Secondary Function
.010769	8f 41 11 7f	sta $7f1141	              STA GP52_REG
.01076d	a9 04		lda #$04	              LDA #$04		;(C256 - UART2 - TXD2) - Output - Set Secondary Function
.01076f	8f 42 11 7f	sta $7f1142	              STA GP53_REG
.010773	a9 05		lda #$05	              LDA #$05		;(C256 - UART2 - DSR2) - Input - Set Secondary Function
.010775	8f 43 11 7f	sta $7f1143	              STA GP54_REG
.010779	a9 04		lda #$04	              LDA #$04		;(C256 - UART2 - RTS2) - Output - Set Secondary Function
.01077b	8f 44 11 7f	sta $7f1144	              STA GP55_REG
.01077f	a9 05		lda #$05	              LDA #$05		;(C256 - UART2 - CTS2) - Input - Set Secondary Function
.010781	8f 45 11 7f	sta $7f1145	              STA GP56_REG
.010785	a9 04		lda #$04	              LDA #$04		;(C256 - UART2 - DTR2) - Output - Set Secondary Function
.010787	8f 46 11 7f	sta $7f1146	              STA GP57_REG
.01078b	a9 84		lda #$84	              LDA #$84		;(C256 - LED1) - Open Drain - Output
.01078d	8f 47 11 7f	sta $7f1147	              STA GP60_REG
.010791	a9 84		lda #$84	              LDA #$84		;(C256 - LED2) - Open Drain - Output
.010793	8f 48 11 7f	sta $7f1148	              STA GP61_REG
.010797	a9 00		lda #$00	              LDA #$00		;GPIO Data Register (GP10..GP17) - Not Used
.010799	8f 4b 11 7f	sta $7f114b	              STA GP1_REG
.01079d	a9 01		lda #$01	              LDA #$01		;GPIO Data Register (GP20..GP27) - Bit[0] - Headphone Mute (Enabling it)
.01079f	8f 4c 11 7f	sta $7f114c	              STA GP2_REG
.0107a3	a9 00		lda #$00	              LDA #$00		;GPIO Data Register (GP30..GP37) - Since it is in Output mode, nothing to write here.
.0107a5	8f 4d 11 7f	sta $7f114d	              STA GP3_REG
.0107a9	a9 00		lda #$00	              LDA #$00		;GPIO Data Register (GP40..GP47)  - Not Used
.0107ab	8f 4e 11 7f	sta $7f114e	              STA GP4_REG
.0107af	a9 00		lda #$00	              LDA #$00		;GPIO Data Register (GP50..GP57)  - Not Used
.0107b1	8f 4f 11 7f	sta $7f114f	              STA GP5_REG
.0107b5	a9 00		lda #$00	              LDA #$00		;GPIO Data Register (GP60..GP61)  - Not Used
.0107b7	8f 50 11 7f	sta $7f1150	              STA GP6_REG
.0107bb	a9 01		lda #$01	              LDA #$01		;LED1 Output - Already setup by Vicky Init Phase, for now, I will leave it alone
.0107bd	8f 5d 11 7f	sta $7f115d	              STA LED1_REG
.0107c1	a9 02		lda #$02	              LDA #$02		;LED2 Output - However, I will setup this one, to make sure the Code works (Full On, when Code was ran)
.0107c3	8f 5e 11 7f	sta $7f115e	              STA LED2_REG
.0107c7	c2 20		rep #$20	                REP #$20        ; set A long
.0107c9	68		pla		              PLA
.0107ca	28		plp		              PLP
.0107cb	2b		pld		              PLD
.0107cc	6b		rtl		              RTL
.0107cd	0b		phd		IINITKEYBOARD	PHD
.0107ce	08		php						PHP
.0107cf	48		pha						PHA
.0107d0	e2 20		sep #$20	                SEP #$20        ; set A short
.0107d2	af 64 10 7f	lda $7f1064	initkb_loop1	LDA STATUS_PORT		; Load Status Byte
.0107d6	29 02		and #$02					AND	#INPT_BUF_FULL	; Test bit $02 (if 0, Empty)
.0107d8	c9 02		cmp #$02					CMP #INPT_BUF_FULL
.0107da	f0 f6		beq $0107d2					BEQ initkb_loop1
.0107dc	a9 aa		lda #$aa					LDA #$0AA			;Send self test command
.0107de	8f 64 10 7f	sta $7f1064					STA KBD_CMD_BUF
.0107e2	af 64 10 7f	lda $7f1064	initkb_loop2	LDA STATUS_PORT		; Wait for test to complete
.0107e6	29 01		and #$01					AND	#OUT_BUF_FULL	; Test bit $01 (if 0, Empty)
.0107e8	c9 01		cmp #$01					CMP #OUT_BUF_FULL
.0107ea	f0 f6		beq $0107e2					BEQ initkb_loop2
.0107ec	af 60 10 7f	lda $7f1060					LDA KBD_OUT_BUF		;Check self test result
.0107f0	c9 55		cmp #$55					CMP #$55
.0107f2	d0 74		bne $010868					BNE	initkb_loop_out
.0107f4	a9 ab		lda #$ab					LDA #$AB			;Send test Interface command
.0107f6	8f 60 10 7f	sta $7f1060					STA KBD_DATA_BUF
.0107fa	af 64 10 7f	lda $7f1064	initkb_loop3	LDA STATUS_PORT		; Wait for test to complete
.0107fe	29 01		and #$01					AND	#OUT_BUF_FULL	; Test bit $01 (if 0, Empty)
.010800	c9 01		cmp #$01					CMP #OUT_BUF_FULL
.010802	f0 f6		beq $0107fa					BEQ initkb_loop3
.010804	af 60 10 7f	lda $7f1060					LDA KBD_OUT_BUF		;Display Interface test results
.010808	c9 00		cmp #$00					CMP #$00			;Should be 00
.01080a	d0 5c		bne $010868					BNE	initkb_loop_out
.01080c	a9 60		lda #$60					LDA #$60			;Send command byte
.01080e	8f 64 10 7f	sta $7f1064					STA KBD_CMD_BUF
.010812	af 64 10 7f	lda $7f1064	initkb_loop4	LDA STATUS_PORT		; Load Status Byte
.010816	29 02		and #$02					AND	#INPT_BUF_FULL	; Test bit $02 (if 0, Empty)
.010818	c9 02		cmp #$02					CMP #INPT_BUF_FULL
.01081a	f0 f6		beq $010812					BEQ initkb_loop4
.01081c	a9 69		lda #$69					LDA #$69		;Send command byte
.01081e	8f 60 10 7f	sta $7f1060					STA KBD_DATA_BUF
.010822	af 64 10 7f	lda $7f1064	initkb_loop5	LDA STATUS_PORT		; Load Status Byte
.010826	29 02		and #$02					AND	#INPT_BUF_FULL	; Test bit $02 (if 0, Empty)
.010828	c9 02		cmp #$02					CMP #INPT_BUF_FULL
.01082a	f0 f6		beq $010822					BEQ initkb_loop5
.01082c	a9 ff		lda #$ff					LDA #$FF			; Send Keyboard Reset command
.01082e	8f 60 10 7f	sta $7f1060					STA KBD_DATA_BUF
.010832	af 64 10 7f	lda $7f1064	initkb_loop6	LDA STATUS_PORT		; Wait for test to complete
.010836	29 01		and #$01					AND	#OUT_BUF_FULL	; Test bit $01 (if 0, Empty)
.010838	c9 01		cmp #$01					CMP #OUT_BUF_FULL
.01083a	f0 f6		beq $010832					BEQ initkb_loop6
.01083c	af 60 10 7f	lda $7f1060					LDA KBD_OUT_BUF
.010840	a9 ee		lda #$ee					LDA #$EE			; Send Echo EE Command
.010842	8f 60 10 7f	sta $7f1060					STA KBD_DATA_BUF
.010846	af 64 10 7f	lda $7f1064	initkb_loop7	LDA STATUS_PORT		; Wait for test to complete
.01084a	29 01		and #$01					AND	#OUT_BUF_FULL	; Test bit $01 (if 0, Empty)
.01084c	c9 01		cmp #$01					CMP #OUT_BUF_FULL
.01084e	f0 f6		beq $010846					BEQ initkb_loop7
.010850	af 60 10 7f	lda $7f1060					LDA KBD_OUT_BUF		; Read Echo from Keyboard
.010854	c9 ee		cmp #$ee					CMP #$EE
.010856	d0 10		bne $010868					BNE initkb_loop_out
.010858	a9 f4		lda #$f4					LDA #$F4			; Enable the Keyboard
.01085a	8f 60 10 7f	sta $7f1060					STA KBD_DATA_BUF
.01085e	af 64 10 7f	lda $7f1064	initkb_loop8	LDA STATUS_PORT		; Wait for test to complete
.010862	29 01		and #$01					AND	#OUT_BUF_FULL	; Test bit $01 (if 0, Empty)
.010864	c9 01		cmp #$01					CMP #OUT_BUF_FULL
.010866	f0 f6		beq $01085e					BEQ initkb_loop8
.010868	af 60 10 7f	lda $7f1060	initkb_loop_out	LDA KBD_OUT_BUF		; Clear the Output buffer
.01086c	c2 20		rep #$20	                REP #$20        ; set A long
.01086e	68		pla		                PLA
.01086f	28		plp						PLP
.010870	2b		pld						PLD
.010871	6b		rtl		                RTL
.010872	00		brk #		IRESTORE        BRK ; Warm boot routine
.010873	00		brk #		ISCINIT         BRK ;
.010874	00		brk #		IIOINIT         BRK ;
.010875	00		brk #		IPUTBLOCK       BRK ; Ouput a binary block to the currently selected channel
.010876	00		brk #		ISETLFS         BRK ; Obsolete (done in OPEN)
.010877	00		brk #		ISETNAM         BRK ; Obsolete (done in OPEN)
.010878	00		brk #		IOPEN           BRK ; Open a channel for reading and/or writing. Use SETLFS and SETNAM to set the channels and filename first.
.010879	00		brk #		ICLOSE          BRK ; Close a channel
.01087a	00		brk #		ISETIN          BRK ; Set the current input channel
.01087b	00		brk #		ISETOUT         BRK ; Set the current output channel
.01087c	00		brk #		IGETB           BRK ; Get a byte from input channel. Return 0 if no input. Carry is set if no input.
.01087d	00		brk #		IGETBLOCK       BRK ; Get a X byes from input channel. If Carry is set, wait. If Carry is clear, do not wait.
.01087e	00		brk #		IGETCH          BRK ; Get a character from the input channel. A=0 and Carry=1 if no data is wating
.01087f	00		brk #		IGETS           BRK ; Get a string from the input channel. NULL terminates
.010880	00		brk #		IGETLINE        BRK ; Get a line of text from input channel. CR or NULL terminates.
.010881	00		brk #		IGETFIELD       BRK ; Get a field from the input channel. Value in A, CR, or NULL terminates
.010882	00		brk #		ITRIM           BRK ; Removes spaces at beginning and end of string.
.010883	00		brk #		IPRINTC         BRK ; Print character to screen. Handles terminal commands
.010884	00		brk #		IPRINTS         BRK ; Print string to screen. Handles terminal commands
.010885	00		brk #		IPRINTF         BRK ; Print a float value
.010886	00		brk #		IPRINTI         BRK ; Prints integer value in TEMP
.010887	00		brk #		IPRINTAI        BRK ; Prints integer value in A
.010888	00		brk #		IPRINTAH        BRK ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
.010889	00		brk #		IPUSHKEY        BRK ;
.01088a	00		brk #		IPUSHKEYS       BRK ;
.01088b	00		brk #		ICSRLEFT        BRK ;
.01088c	00		brk #		ICSRHOME        BRK ;
.01088d	00		brk #		ISCRREADLINE    BRK ; Loads the MCMDADDR/BCMDADDR variable with the address of the current line on the screen. This is called when the RETURN key is pressed and is the first step in processing an immediate mode command.
.01088e	00		brk #		ISCRGETWORD     BRK ; Read a current word on the screen. A word ends with a space, punctuation (except _), or any control character (value < 32). Loads the address into CMPTEXT_VAL and length into CMPTEXT_LEN variables.
.01088f					KERNEL_DATA
>01088f	20 20 20 20 ec a9 ec a9		greet_msg       .text $20, $20, $20, $20, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, "C256 FOENIX DEVELOPMENT SYSTEM",$0D
>010897	ec a9 ec a9 ec a9 43 32 35 36 20 46 4f 45 4e 49
>0108a7	58 20 44 45 56 45 4c 4f 50 4d 45 4e 54 20 53 59
>0108b7	53 54 45 4d 0d
>0108bc	20 20 20 ec a9 ec a9 ec		                .text $20, $20, $20, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $20, "OPEN SOURCE COMPUTER",$0D
>0108c4	a9 ec a9 ec a9 20 4f 50 45 4e 20 53 4f 55 52 43
>0108d4	45 20 43 4f 4d 50 55 54 45 52 0d
>0108df	20 20 ec a9 ec a9 ec a9		                .text $20, $20, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $20, $20, "HARDWARE DESIGNER: STEFANY ALLAIRE",$0D
>0108e7	ec a9 ec a9 20 20 48 41 52 44 57 41 52 45 20 44
>0108f7	45 53 49 47 4e 45 52 3a 20 53 54 45 46 41 4e 59
>010907	20 41 4c 4c 41 49 52 45 0d
>010910	20 ec a9 ec a9 ec a9 ec		                .text $20, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $20, $20, $20, "SOFTWARE DESIGNER: TOM WILSON",$0D
>010918	a9 ec a9 20 20 20 53 4f 46 54 57 41 52 45 20 44
>010928	45 53 49 47 4e 45 52 3a 20 54 4f 4d 20 57 49 4c
>010938	53 4f 4e 0d
>01093c	ec a9 ec a9 ec a9 ec a9		                .text $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $20, $20, $20, $20, "1024KB BASIC RAM  8192K MEDIA RAM",$0D,$00
>010944	ec a9 20 20 20 20 31 30 32 34 4b 42 20 42 41 53
>010954	49 43 20 52 41 4d 20 20 38 31 39 32 4b 20 4d 45
>010964	44 49 41 20 52 41 4d 0d 00
>01096d	1d 1d 1d 1d 1d 1d 8d 8d		greet_clr_line1 .byte $1D, $1D, $1D, $1D, $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D
>010975	4d 4d 2d 2d 5d 5d
>01097b	1d 1d 1d 1d 1d 8d 8d 4d		greet_clr_line2 .byte $1D, $1D, $1D, $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D, $5D
>010983	4d 2d 2d 5d 5d 5d
>010989	1d 1d 1d 1d 8d 8d 4d 4d		greet_clr_line3 .byte $1D, $1D, $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D, $5D, $5D
>010991	2d 2d 5d 5d 5d 5d
>010997	1d 1d 1d 8d 8d 4d 4d 2d		greet_clr_line4 .byte $1D, $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D, $5D, $5D, $5D
>01099f	2d 5d 5d 5d 5d 5d
>0109a5	1d 1d 8d 8d 4d 4d 2d 2d		greet_clr_line5 .byte $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D, $5D, $5D, $5D, $5D
>0109ad	5d 5d 5d 5d 5d 5d
>0109b3	00 00 00 ff			fg_color_lut	.byte $00, $00, $00, $FF
>0109b7	00 00 c0 ff			                .byte $00, $00, $C0, $FF
>0109bb	00 c0 00 ff			                .byte $00, $C0, $00, $FF
>0109bf	c0 00 00 ff			                .byte $C0, $00, $00, $FF
>0109c3	00 c0 c0 ff			                .byte $00, $C0, $C0, $FF
>0109c7	c0 c0 00 ff			                .byte $C0, $C0, $00, $FF
>0109cb	c0 00 c0 ff			                .byte $C0, $00, $C0, $FF
>0109cf	c0 c0 c0 ff			                .byte $C0, $C0, $C0, $FF
>0109d3	00 7f ff ff			                .byte $00, $7F, $FF, $FF
>0109d7	13 45 8b ff			                .byte $13, $45, $8B, $FF
>0109db	00 00 40 ff			                .byte $00, $00, $40, $FF
>0109df	00 40 00 ff			                .byte $00, $40, $00, $FF
>0109e3	40 00 00 ff			                .byte $40, $00, $00, $FF
>0109e7	40 40 40 ff			                .byte $40, $40, $40, $FF
>0109eb	80 80 80 ff			                .byte $80, $80, $80, $FF
>0109ef	ff ff ff ff			                .byte $FF, $FF, $FF, $FF
>0109f3	00 00 00 ff			bg_color_lut	.byte $00, $00, $00, $FF
>0109f7	00 00 c0 ff			                .byte $00, $00, $C0, $FF
>0109fb	00 c0 00 ff			                .byte $00, $C0, $00, $FF
>0109ff	c0 00 00 ff			                .byte $C0, $00, $00, $FF
>010a03	00 40 40 ff			                .byte $00, $40, $40, $FF
>010a07	40 40 00 ff			                .byte $40, $40, $00, $FF
>010a0b	40 00 40 ff			                .byte $40, $00, $40, $FF
>010a0f	40 40 40 ff			                .byte $40, $40, $40, $FF
>010a13	1e 69 d2 ff			                .byte $1E, $69, $D2, $FF
>010a17	13 45 8b ff			                .byte $13, $45, $8B, $FF
>010a1b	00 00 40 ff			                .byte $00, $00, $40, $FF
>010a1f	00 40 00 ff			                .byte $00, $40, $00, $FF
>010a23	40 00 00 ff			                .byte $40, $00, $00, $FF
>010a27	20 20 20 ff			                .byte $20, $20, $20, $FF
>010a2b	80 80 80 ff			                .byte $80, $80, $80, $FF
>010a2f	ff ff ff ff			                .byte $FF, $FF, $FF, $FF
>010a33	0d 52 45 41 44 59 2e 00		ready_msg       .null $0D,"READY."
>010a3b	31 30 20 50 52 49 4e 54		hello_basic     .null "10 PRINT ""Hello World""",$0D
>010a43	20 22 48 65 6c 6c 6f 20 57 6f 72 6c 64 22 0d 00
>010a53	52 55 4e 0d 00			                .null "RUN",$0D
>010a58	48 65 6c 6c 6f 20 57 6f		                .null "Hello World",$0D
>010a60	72 6c 64 0d 00
>010a65	0d 52 45 41 44 59 2e 00		                .null $0D,"READY."
>010a6d	47 20 30 32 30 30 30 30		hello_ml        .null "G 020000",$0D
>010a75	0d 00
>010a77	48 45 4c 4c 4f 20 57 4f		                .null "HELLO WORLD",$0D
>010a7f	52 4c 44 0d 00
>010a84	0d 00				                .null $0D
>010a86	20 50 43 20 20 20 20 20		                .null " PC     A    X    Y    SP   DBR DP   NVMXDIZC",$0D
>010a8e	41 20 20 20 20 58 20 20 20 20 59 20 20 20 20 53
>010a9e	50 20 20 20 44 42 52 20 44 50 20 20 20 4e 56 4d
>010aae	58 44 49 5a 43 0d 00
>010ab5	3b 30 30 32 31 31 32 20		                .null ";002112 0019 F0AA 0000 D6FF F8  0000 --M-----"
>010abd	30 30 31 39 20 46 30 41 41 20 30 30 30 30 20 44
>010acd	36 46 46 20 46 38 20 20 30 30 30 30 20 2d 2d 4d
>010add	2d 2d 2d 2d 2d 00
>010ae3	41 42 4f 52 54 20 45 52		error_01        .null "ABORT ERROR"
>010aeb	52 4f 52 00
>010aef	30 31 32 33 34 35 36 37		hex_digits      .text "0123456789ABCDEF",0
>010af7	38 39 41 42 43 44 45 46 00

;******  End of listing
