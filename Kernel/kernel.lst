
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass --long-address --intel-hex -o kernel.hex --list kernel.lst kernel.asm
; Sat Sep 08 22:16:10 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm


;******  Processing file: macros_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: simulator_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: directpage_inc.asm

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				DIRECT_PAGE      = $000000 ;Start of bank 0 and Direct page
=$000000				RESET            = $000000 ;4 Bytes Jumps to the beginning of kernel ROM. ($F8:0000).
=$000004				RETURN           = $000004 ;4 Bytes Called when the RETURN key is pressed in the immediate mode screen. This will process a command in MONITOR, execute a BASIC command, or add a BASIC program line.
=$000008				KEYDOWN          = $000008 ;4 Bytes Custom keyboard handler. This defaults to the kernel keypress handler, but you can redirect this to your own routines. Make sure to JML to the original address at the end of your custom routine. Use this to make F-Key macros or custom keyboard commands.
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;2 Bytes Color of next character to be printed to the screen.
=$000020				CURATTR          = $000020 ;2 Bytes Attribute of next character to be printed to the screen.
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$0000e0				TEMP             = $0000E0 ;16 Bytes Temp storage for kernel routines
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000108				DIVIDER_0        = $000108 ;0 Byte  Unsigned divider
=$000108				D0_OPERAND_A     = $000108 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$00010a				D0_OPERAND_B     = $00010A ;2 Bytes Divider 0 Divisor ex B in A/B
=$00010c				D0_RESULT        = $00010C ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$00010e				D0_REMAINDER     = $00010E ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000110				DIVIDER_1        = $000110 ;0 Byte  Signed divider
=$000110				D1_OPERAND_A     = $000110 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$000112				D1_OPERAND_B     = $000112 ;2 Bytes Divider 1 Divisor ex B in A/B
=$000114				D1_RESULT        = $000114 ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D1_REMAINDER     = $000116 ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$0001ff				VECTOR_STATE     = $0001FF ;1 Byte  Interrupt Vector State. See VECTOR_STATE_ENUM
=$0001f0				CPUPC            = $0001F0 ;2 Bytes Debug registers. When BRK is executed, Interrupt service routine will populate this block with the CPU registers.
=$0001f2				CPUPBR           = $0001F2 ;1 Byte  Program Bank Register (K)
=$0001f3				CPUDBR           = $0001F3 ;1 Byte  Data Bank Register (B)
=$0001f4				CPUA             = $0001F4 ;2 Bytes Accumulator (A)
=$0001f6				CPUX             = $0001F6 ;2 Bytes X Register
=$0001f8				CPUY             = $0001F8 ;2 Bytes Y Index Register
=$0001fa				CPUSTACK         = $0001FA ;2 Bytes Stack (S)
=$0001fc				CPUDP            = $0001FC ;2 Bytes Direct Page Register (D)
=$0001fe				CPUFLAGS         = $0001FE ;1 Byte  Flags (P)
=$000200				MCMDADDR         = $000200 ;3 Bytes Address of the current line of text being processed by the MONITOR command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$000203				MCMP_TEXT        = $000203 ;3 Bytes Address of symbol being evaluated for COMPARE routine
=$000206				MCMP_LEN         = $000206 ;2 Bytes Length of symbol being evaluated for COMPARE routine
=$000208				MCMD             = $000208 ;3 Bytes Address of the current command/function string
=$00020b				MCMD_LEN         = $00020B ;2 Bytes Length of the current command/function string
=$00020d				MARG1            = $00020D ;3 Bytes Address of the command arguments.
=$000210				MARG1_LEN        = $000210 ;2 Bytes Length of the argument
=$000212				MARG2            = $000212 ;3 Bytes Address of the command arguments.
=$000215				MARG2_LEN        = $000215 ;2 Bytes Length of the argument
=$000217				MARG3            = $000217 ;3 Bytes Address of the command arguments.
=$00021a				MARG3_LEN        = $00021A ;2 Bytes Length of the argument
=$00021c				MARG4            = $00021C ;3 Bytes Address of the command arguments.
=$00021f				MARG4_LEN        = $00021F ;2 Bytes Length of the argument
=$000221				MARG5            = $000221 ;3 Bytes Address of the command arguments.
=$000224				MARG5_LEN        = $000224 ;2 Bytes Length of the argument
=$000226				MARG6            = $000226 ;3 Bytes Address of the command arguments.
=$000229				MARG6_LEN        = $000229 ;2 Bytes Length of the argument
=$00022b				MARG7            = $00022B ;3 Bytes Address of the command arguments.
=$00022e				MARG7_LEN        = $00022E ;2 Bytes Length of the argument
=$00f00					KEY_BUFFER       = $00F00 ;64 Bytes KEY_BUFFER
=$40					KEY_BUFFER_SIZE  = $40 ;64 Bytes KEY_BUFFER_SIZE
=$000f3f				KEY_BUFFER_END   = $000F3F ;1 Byte  KEY_BUFFER_END
=$000f40				KEY_BUFFER_RPOS  = $000F40 ;2 Bytes KEY_BUFFER_RPOS
=$000f42				KEY_BUFFER_WPOS  = $000F42 ;2 Bytes KEY_BUFFER_WPOS
=$001000				SCREEN_PAGE0     = $001000 ;8192 Bytes First page of display RAM. This is used at boot time to display the welcome screen and the BASIC or MONITOR command screens.
=$003000				SCREEN_PAGE1     = $003000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$005000				SCREEN_PAGE2     = $005000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$007000				SCREEN_PAGE3     = $007000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$009000				SCREEN_END       = $009000 ;End of display memory
=$009000				USER_VARIABLES   = $009000 ;2048 Bytes This space is free for user data in Direct Page
=$009800				USER_VARIABLES_E = $009800 ;*End of user free space
=$009800				STACK_BEGIN      = $009800 ;16384 Bytes The default beginning of stack space
=$00d7ff				STACK_END        = $00D7FF ;0 Byte  End of stack space. Everything below this is I/O space
=$00d800				IO_BEGIN         = $00D800 ; Byte  Beginning of IO space
=$00d800				IO_GAVIN         = $00D800 ;1024 Bytes GAVIN I/O space
=$00dc00				IO_SUPERIO       = $00DC00 ;1024 Bytes SuperIO I/O space
=$00e000				IO_VICKY         = $00E000 ;1024 Bytes VICKY I/O space
=$00e400				IO_BEATRIX       = $00E400 ;1024 Bytes BEATRIX I/O space
=$00e800				IO_RTC           = $00E800 ;1024 Bytes RTC I/O space
=$00ec00				IO_CIA           = $00EC00 ;4864 Bytes CIA I/O space
=$00ff00				IO_END           = $00FF00 ;*End of I/O space
=$00ff00				ISR_BEGIN        = $00FF00 ; Byte  Beginning of CPU vectors in Direct page
=$00ff00				HRESET           = $00FF00 ;16 Bytes Handle RESET asserted. Reboot computer and re-initialize the kernel.
=$00ff10				HCOP             = $00FF10 ;16 Bytes Handle the COP instruction. Program use; not used by OS
=$00ff20				HBRK             = $00FF20 ;16 Bytes Handle the BRK instruction. Returns to BASIC Ready prompt.
=$00ff30				HABORT           = $00FF30 ;16 Bytes Handle ABORT asserted. Return to Ready prompt with an error message.
=$00ff40				INT_TABLE        = $00FF40 ;96 Bytes Interrupt vectors for GAVIN interrupt handler
=$00ffa0				ISR_END          = $00FFA0 ;*End of vector space
=$00ffe0				VECTORS_BEGIN    = $00FFE0 ;0 Byte  Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$00ffe0				JMP_READY        = $00FFE0 ;4 Bytes Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$00ffe4				VECTOR_COP       = $00FFE4 ;2 Bytes Native interrupt vector
=$00ffe6				VECTOR_BRK       = $00FFE6 ;2 Bytes Native interrupt vector
=$00ffe8				VECTOR_ABORT     = $00FFE8 ;2 Bytes Native interrupt vector
=$00ffea				VECTOR_NMI       = $00FFEA ;2 Bytes Native interrupt vector
=$00ffec				VECTOR_RESET     = $00FFEC ;2 Bytes Native interrupt vector
=$00ffee				VECTOR_IRQ       = $00FFEE ;2 Bytes Native interrupt vector
=$00fff4				VECTOR_ECOP      = $00FFF4 ;2 Bytes Emulation mode interrupt handler
=$00fff6				VECTOR_EBRK      = $00FFF6 ;2 Bytes Emulation mode interrupt handler
=$00fff8				VECTOR_EABORT    = $00FFF8 ;2 Bytes Emulation mode interrupt handler
=$00fffa				VECTOR_ENMI      = $00FFFA ;2 Bytes Emulation mode interrupt handler
=$00fffc				VECTOR_ERESET    = $00FFFC ;2 Bytes Emulation mode interrupt handler
=$00fffe				VECTOR_EIRQ      = $00FFFE ;2 Bytes Emulation mode interrupt handler
=$010000				VECTORS_END      = $010000 ;*End of vector space

;******  Return to file: kernel.asm


;******  Processing file: monitor.asm

.f90000	5c 00 04 f9	jmp $f90400	MONITOR         JML IMONITOR
.f90004	5c 06 04 f9	jmp $f90406	MBREAK          JML IMBREAK
.f90008	5c 07 04 f9	jmp $f90407	MSTATUS         JML IMSTATUS
.f9000c	5c 08 04 f9	jmp $f90408	MREADY          JML IMREADY
.f90010	5c 09 04 f9	jmp $f90409	MRETURN         JML IMRETURN
.f90014	5c 0a 04 f9	jmp $f9040a	MPARSE          JML IMPARSE
.f90018	5c 0b 04 f9	jmp $f9040b	MPARSE1         JML IMPARSE1
.f9001c	5c 0c 04 f9	jmp $f9040c	MEXECUTE        JML IMEXECUTE
.f90020	5c 0d 04 f9	jmp $f9040d	MASSEMBLE       JML IMASSEMBLE
.f90024	5c 0e 04 f9	jmp $f9040e	MASSEMBLEA      JML IMASSEMBLEA
.f90028	5c 0f 04 f9	jmp $f9040f	MCOMPARE        JML IMCOMPARE
.f9002c	5c 10 04 f9	jmp $f90410	MDISASSEMBLE    JML IMDISASSEMBLE
.f90030	5c 11 04 f9	jmp $f90411	MFILL           JML IMFILL
.f90034	5c 13 04 f9	jmp $f90413	MJUMP           JML IMJUMP
.f90038	5c 14 04 f9	jmp $f90414	MHUNT           JML IMHUNT
.f9003c	5c 15 04 f9	jmp $f90415	MLOAD           JML IMLOAD
.f90040	5c 16 04 f9	jmp $f90416	MMEMORY         JML IMMEMORY
.f90044	5c 17 04 f9	jmp $f90417	MREGISTERS      JML IMREGISTERS
.f90048	5c 18 04 f9	jmp $f90418	MSAVE           JML IMSAVE
.f9004c	5c 19 04 f9	jmp $f90419	MTRANSFER       JML IMTRANSFER
.f90050	5c 1a 04 f9	jmp $f9041a	MVERIFY         JML IMVERIFY
.f90054	5c 1b 04 f9	jmp $f9041b	MEXIT           JML IMEXIT
.f90058	5c 1c 04 f9	jmp $f9041c	MMODIFY         JML IMMODIFY
.f90400					IMONITOR
.f90400	18		clc		                CLC           ; clear the carry flag
.f90401	fb		xce		                XCE           ; move carry to emulation flag.
.f90402	c2 10		rep #$10	                REP #$10      ; set 16-bit index registers
.f90404	e2 20		sep #$20	                SEP #$20      ; set 8 bit accumulator
.f90406	00		brk #		IMBREAK         BRK ; Warm boot routine
.f90407	00		brk #		IMSTATUS        BRK ; Print status message
.f90408	00		brk #		IMREADY         BRK ; Prints status message and waits for input
.f90409	00		brk #		IMRETURN        BRK ; Handle RETURN key (ie: execute command)
.f9040a	00		brk #		IMPARSE         BRK ; Parse the current command line
.f9040b	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.f9040c	00		brk #		IMEXECUTE       BRK ; Execute the current command line (requires MCMD and MARG1-MARG8 to be populated)
.f9040d	00		brk #		IMASSEMBLE      BRK ; Assemble a line of text.
.f9040e	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.f9040f	00		brk #		IMCOMPARE       BRK ; Compare memory. len=1
.f90410	00		brk #		IMDISASSEMBLE   BRK ; Disassemble memory. end=1 instruction
.f90411	00		brk #		IMFILL          BRK ; Fill memory with specified value. Start and end must be in the same bank.
.f90412	00		brk #		IMGO            BRK ; Execute from specified address
.f90413	00		brk #		IMJUMP          BRK ; Execute from spefified address
.f90414	00		brk #		IMHUNT          BRK ; Hunt (find) value in memory
.f90415	00		brk #		IMLOAD          BRK ; Load data from disk. Device=1 (internal floppy) Start=Address in file
.f90416	00		brk #		IMMEMORY        BRK ; View memory
.f90417	00		brk #		IMREGISTERS     BRK ; View/edit registers
.f90418	00		brk #		IMSAVE          BRK ; Save memory to disk
.f90419	00		brk #		IMTRANSFER      BRK ; Transfer (copy) data in memory
.f9041a	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.f9041b	00		brk #		IMEXIT          BRK ; Exit monitor and return to BASIC command prompt
.f9041c	00		brk #		IMMODIFY        BRK ; Modify memory
.f9041d					MMESSAGES
>f9041d					MMERROR         .text

;******  Return to file: kernel.asm


;******  Processing file: kernel_bank_FF.asm

.ffff00	5c 00 00 f8	jmp $f80000	                JML BOOT
.ffff10	5c 20 ff 00	jmp $00ff20	                JMP HBRK
.ffff20					RHBRK
.ffff20	c2 30		rep #$30	                REP #$30        ; set A&X long
.ffff22	8b		phb		                PHB
.ffff23	0b		phd		                PHD
.ffff24	48		pha		                PHA
.ffff25	da		phx		                PHX
.ffff26	5a		phy		                PHY
.ffff27	5c 08 00 f8	jmp $f80008	                JML BREAK
.ffff50					RHIRQ
.ffff50	c2 30		rep #$30	                REP #$30        ; set A&X long
.ffff52	8b		phb		                PHB
.ffff53	0b		phd		                PHD
.ffff54	48		pha		                PHA
.ffff55	da		phx		                PHX
.ffff56	5a		phy		                PHY
.ffff57	7a		ply		                PLY
.ffff58	fa		plx		                PLX
.ffff59	68		pla		                PLA
.ffff5a	2b		pld		                PLD
.ffff5b	ab		plb		                PLB
.ffff5c	40		rti		                RTI
.ffffe0					ROM_VECTORS
.ffffe0	5c 0c 00 f8	jmp $f8000c	JUMP_READY      JML READY
>ffffe4	10 ff				RVECTOR_COP     .word $FF10     ; FFE4
>ffffe6	20 ff				RVECTOR_BRK     .word $FF20     ; FFE6
>ffffe8	30 ff				RVECTOR_ABORT   .word $FF30     ; FFE8
>ffffea	40 ff				RVECTOR_NMI     .word $FF40     ; FFEA
>ffffec	00 00				                .word $0000     ; FFEC
>ffffee	50 ff				RVECTOR_IRQ     .word $FF50     ; FFEE
>fffff0	00 00				                .word $0000     ; FFF0
>fffff2	00 00				                .word $0000     ; FFF2
>fffff4	10 ff				RVECTOR_ECOP    .word $FF10     ; FFF4
>fffff6	20 ff				RVECTOR_EBRK    .word $FF20     ; FFF6
>fffff8	30 ff				RVECTOR_EABORT  .word $FF30     ; FFF8
>fffffa	40 ff				RVECTOR_ENMI    .word $FF40     ; FFFA
>fffffc	00 ff				RVECTOR_ERESET  .word $FF00     ; FFFC
>fffffe	50 ff				RVECTOR_EIRQ    .word $FF50     ; FFFE

;******  Return to file: kernel.asm

.f80000	5c 00 04 f8	jmp $f80400	BOOT            JML IBOOT
.f80004	5c f2 05 f8	jmp $f805f2	RESTORE         JML IRESTORE
.f80008	5c 71 04 f8	jmp $f80471	BREAK           JML IBREAK
.f8000c	5c b4 04 f8	jmp $f804b4	READY           JML IREADY
.f80010	5c f3 05 f8	jmp $f805f3	SCINIT          JML ISCINIT
.f80014	5c f4 05 f8	jmp $f805f4	IOINIT          JML IIOINIT
.f80018	5c 30 05 f8	jmp $f80530	PUTC            JML IPUTC
.f8001c	5c 19 05 f8	jmp $f80519	PUTS            JML IPUTS
.f80020	5c 5d 05 f8	jmp $f8055d	PUTB            JML IPUTB
.f80024	5c f5 05 f8	jmp $f805f5	PUTBLOCK        JML IPUTBLOCK
.f80028	5c f6 05 f8	jmp $f805f6	SETLFS          JML ISETLFS
.f8002c	5c f7 05 f8	jmp $f805f7	SETNAM          JML ISETNAM
.f80030	5c f8 05 f8	jmp $f805f8	OPEN            JML IOPEN
.f80034	5c f9 05 f8	jmp $f805f9	CLOSE           JML ICLOSE
.f80038	5c fa 05 f8	jmp $f805fa	SETIN           JML ISETIN
.f8003c	5c fb 05 f8	jmp $f805fb	SETOUT          JML ISETOUT
.f80040	5c fc 05 f8	jmp $f805fc	GETB            JML IGETB
.f80044	5c fd 05 f8	jmp $f805fd	GETBLOCK        JML IGETBLOCK
.f80048	5c fe 05 f8	jmp $f805fe	GETCH           JML IGETCH
.f8004c	5c df 04 f8	jmp $f804df	GETCHW          JML IGETCHW
.f80050	5c d6 04 f8	jmp $f804d6	GETCHE          JML IGETCHE
.f80054	5c ff 05 f8	jmp $f805ff	GETS            JML IGETS
.f80058	5c 00 06 f8	jmp $f80600	GETLINE         JML IGETLINE
.f8005c	5c 01 06 f8	jmp $f80601	GETFIELD        JML IGETFIELD
.f80060	5c 02 06 f8	jmp $f80602	TRIM            JML ITRIM
.f80064	5c 03 06 f8	jmp $f80603	PRINTC          JML IPRINTC
.f80068	5c 04 06 f8	jmp $f80604	PRINTS          JML IPRINTS
.f8006c	5c 5e 05 f8	jmp $f8055e	PRINTCR         JML IPRINTCR
.f80070	5c 05 06 f8	jmp $f80605	PRINTF          JML IPRINTF
.f80074	5c 06 06 f8	jmp $f80606	PRINTI          JML IPRINTI
.f80078	5c 07 06 f8	jmp $f80607	PRINTH          JML IPRINTH
.f8007c	5c 08 06 f8	jmp $f80608	PRINTAI         JML IPRINTAI
.f80080	5c 09 06 f8	jmp $f80609	PRINTAH         JML IPRINTAH
.f80084	5c ac 05 f8	jmp $f805ac	LOCATE          JML ILOCATE
.f80088	5c 0a 06 f8	jmp $f8060a	PUSHKEY         JML IPUSHKEY
.f8008c	5c 0b 06 f8	jmp $f8060b	PUSHKEYS        JML IPUSHKEYS
.f80090	5c 7f 05 f8	jmp $f8057f	CSRRIGHT        JML ICSRRIGHT
.f80094	5c 0c 06 f8	jmp $f8060c	CSRLEFT         JML ICSRLEFT
.f80098	5c aa 05 f8	jmp $f805aa	CSRUP           JML ICSRUP
.f8009c	5c ab 05 f8	jmp $f805ab	CSRDOWN         JML ICSRDOWN
.f800a0	5c 0d 06 f8	jmp $f8060d	CSRHOME         JML ICSRHOME
.f800a4	5c d8 05 f8	jmp $f805d8	SCROLLUP        JML ISCROLLUP
.f80400					IBOOT
.f80400	18		clc		                CLC           ; clear the carry flag
.f80401	fb		xce		                XCE           ; move carry to emulation flag.
.f80402	c2 30		rep #$30	                REP #$30        ; set A&X long
.f80404	a9 ff d7	lda #$d7ff	                LDA #STACK_END   ; initialize stack pointer
.f80407	1b		tcs		                TAS
.f80408	48		pha		                PHA             ; begin setdp macro
.f80409	08		php			PHP
.f8040a	c2 20		rep #$20	                REP #$20        ; set A long
.f8040c	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.f8040f	5b		tcd		                TCD
.f80410	28		plp			PLP
.f80411	68		pla		                PLA             ; end setdp macro
.f80412	a9 00 10	lda #$1000	                LDA #$1000      ; store the initial screen buffer location
.f80415	85 0c		sta $0c		                STA SCREENBEGIN
.f80417	e2 20		sep #$20	                SEP #$20        ; set A short
.f80419	a9 00		lda #$00	                LDA #$00
.f8041b	85 0e		sta $0e		                STA SCREENBEGIN+2
.f8041d	c2 30		rep #$30	                REP #$30        ; set A&X long
.f8041f	a2 50 00	ldx #$0050	                LDX #80
.f80422	86 0f		stx $0f		                STX COLS_VISIBLE
.f80424	a0 3c 00	ldy #$003c	                LDY #60
.f80427	84 13		sty $13		                STY LINES_VISIBLE
.f80429	a2 80 00	ldx #$0080	                LDX #128
.f8042c	86 11		stx $11		                STX COLS_PER_LINE
.f8042e	a0 40 00	ldy #$0040	                LDY #64
.f80431	84 15		sty $15		                STY LINES_MAX
.f80433	c2 20		rep #$20	                REP #$20        ; set A long
.f80435	a2 00 00	ldx #$0000	                LDX #$0
.f80438	a0 00 00	ldy #$0000	                LDY #$0
.f8043b	22 ac 05 f8	jsl $f805ac	                JSL ILOCATE
.f8043f	9c 40 0f	stz $0f40	                STZ KEY_BUFFER_RPOS
.f80442	9c 42 0f	stz $0f42	                STZ KEY_BUFFER_WPOS
.f80445	c2 30		rep #$30	                REP #$30        ; set A&X long
.f80447	a9 ff 00	lda #$00ff	                LDA #$FF
.f8044a	a2 00 ff	ldx #$ff00	                LDX #$FF00
.f8044d	a0 00 ff	ldy #$ff00	                LDY #$FF00
.f80450	44 ff 00	mvp $00,$ff	                MVP $00, $FF
.f80453					greet
.f80453	48		pha		                PHA             ; begin setdbr macro
.f80454	08		php		                PHP
.f80455	e2 20		sep #$20	                SEP #$20        ; set A short
.f80457	a9 f8		lda #$f8		LDA #`greet_msg
.f80459	48		pha		                PHA
.f8045a	ab		plb		                PLB
.f8045b	28		plp		                PLP
.f8045c	68		pla		                PLA             ; end setdbr macro
.f8045d	a2 00 f0	ldx #$f000	                LDX #<>greet_msg
.f80460	22 10 05 f8	jsl $f80510	                JSL IPRINT       ; print the first line
.f80464	e2 20		sep #$20	                SEP #$20        ; set A short
.f80466	48		pha		                PHA             ; begin setdbr macro
.f80467	08		php		                PHP
.f80468	e2 20		sep #$20	                SEP #$20        ; set A short
.f8046a	a9 01		lda #$01		LDA #$01
.f8046c	48		pha		                PHA
.f8046d	ab		plb		                PLB
.f8046e	28		plp		                PLP
.f8046f	68		pla		                PLA             ; end setdbr macro
.f80470	00		brk #		greet_done      BRK             ;Terminate boot routine and go to Ready handler.
.f80471					IBREAK
.f80471	48		pha		                PHA             ; begin setdp macro
.f80472	08		php			PHP
.f80473	c2 20		rep #$20	                REP #$20        ; set A long
.f80475	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.f80478	5b		tcd		                TCD
.f80479	28		plp			PLP
.f8047a	68		pla		                PLA             ; end setdp macro
.f8047b	68		pla		                PLA             ; Pull .Y and stuff it in the CPUY variable
.f8047c	8f f8 01 00	sta $0001f8	                STA CPUY
.f80480	68		pla		                PLA             ; Pull .X and stuff it in the CPUY variable
.f80481	8f f6 01 00	sta $0001f6	                STA CPUX
.f80485	68		pla		                PLA             ; Pull .A and stuff it in the CPUY variable
.f80486	8f f4 01 00	sta $0001f4	                STA CPUA
.f8048a	68		pla		                PLA
.f8048b	8f fc 01 00	sta $0001fc	                STA CPUDP       ; Pull Direct page
.f8048f	e2 20		sep #$20	                SEP #$20        ; set A short
.f80491	68		pla		                PLA             ; Pull Data Bank (8 bits)
.f80492	8f f3 01 00	sta $0001f3	                STA CPUDBR
.f80496	68		pla		                PLA             ; Pull Flags (8 bits)
.f80497	8f fe 01 00	sta $0001fe	                STA CPUFLAGS
.f8049b	c2 20		rep #$20	                REP #$20        ; set A long
.f8049d	68		pla		                PLA             ; Pull Program Counter (16 bits)
.f8049e	8f f0 01 00	sta $0001f0	                STA CPUPC
.f804a2	e2 20		sep #$20	                SEP #$20        ; set A short
.f804a4	68		pla		                PLA             ; Pull Program Bank (8 bits)
.f804a5	8f f2 01 00	sta $0001f2	                STA CPUPBR
.f804a9	c2 20		rep #$20	                REP #$20        ; set A long
.f804ab	3b		tsc		                TSA             ; Get the stack
.f804ac	8f fa 01 00	sta $0001fa	                STA CPUSTACK    ; Store the stack at immediately before the interrupt was asserted
.f804b0	a9 ff d7	lda #$d7ff	                LDA #<>STACK_END   ; initialize stack pointer back to the bootup value
.f804b3	1b		tcs		                TAS
.f804b4					IREADY
.f804b4	48		pha		                PHA             ; begin setdbr macro
.f804b5	08		php		                PHP
.f804b6	e2 20		sep #$20	                SEP #$20        ; set A short
.f804b8	a9 f8		lda #$f8		LDA #`ready_msg
.f804ba	48		pha		                PHA
.f804bb	ab		plb		                PLB
.f804bc	28		plp		                PLP
.f804bd	68		pla		                PLA             ; end setdbr macro
.f804be	e2 20		sep #$20	                SEP #$20        ; set A short
.f804c0	a2 65 f0	ldx #$f065	                LDX #<>ready_msg
.f804c3	22 10 05 f8	jsl $f80510	                JSL IPRINT
.f804c7					IREADYWAIT
.f804c7	22 d6 04 f8	jsl $f804d6	                JSL IGETCHE
.f804cb	b0 fa		bcs $f804c7	                BCS IREADYWAIT
.f804cd	22 30 05 f8	jsl $f80530	                JSL IPUTC
.f804d1	4c c7 04	jmp $f804c7	                JMP IREADYWAIT
.f804d4	db		stp		IKEYDOWN        STP             ; Keyboard key pressed
.f804d5	db		stp		IRETURN         STP
.f804d6	22 df 04 f8	jsl $f804df	IGETCHE         JSL IGETCHW
.f804da	22 30 05 f8	jsl $f80530	                JSL IPUTC
.f804de	6b		rtl		                RTL
.f804df	0b		phd		IGETCHW         PHD
.f804e0	da		phx		                PHX
.f804e1	08		php		                PHP
.f804e2	48		pha		                PHA             ; begin setdp macro
.f804e3	08		php			PHP
.f804e4	c2 20		rep #$20	                REP #$20        ; set A long
.f804e6	a9 00 0f	lda #$0f00	                LDA #$0F00         ; set DP to page 0
.f804e9	5b		tcd		                TCD
.f804ea	28		plp			PLP
.f804eb	68		pla		                PLA             ; end setdp macro
.f804ec	c2 30		rep #$30	                REP #$30        ; set A&X long
.f804ee	a6 40		ldx $0f40	igetchw1        LDX KEY_BUFFER_RPOS
.f804f0	e4 42		cpx $0f42	                CPX KEY_BUFFER_WPOS
.f804f2	d0 05		bne $f804f9	                BNE igetchw2
>f804f4	42 00				                .byte $42, $00
.f804f6	4c ee 04	jmp $f804ee	                JMP igetchw1
.f804f9	b5 00		lda $0f00,x	igetchw2        LDA $0,D,X  ; Read the value in the keyboard buffer
.f804fb	48		pha		                PHA
.f804fc	8a		txa		                TXA
.f804fd	18		clc		                CLC
.f804fe	69 02 00	adc #$0002	                ADC #$02
.f80501	c9 40 00	cmp #$0040	                CMP #KEY_BUFFER_SIZE
.f80504	90 03		bcc $f80509	                BCC igetchw3
.f80506	a9 00 00	lda #$0000	                LDA #$0
.f80509	85 40		sta $0f40	igetchw3        STA KEY_BUFFER_RPOS
.f8050b	68		pla		                PLA
.f8050c	28		plp		igetchw_done    PLP
.f8050d	fa		plx		                PLX             ; Restore the saved registers and return
.f8050e	2b		pld		                PLD
.f8050f	6b		rtl		                RTL
.f80510	22 19 05 f8	jsl $f80519	IPRINT          JSL IPUTS
.f80514	22 5e 05 f8	jsl $f8055e	                JSL IPRINTCR
.f80518	6b		rtl		                RTL
.f80519	48		pha		IPUTS           PHA
.f8051a	08		php		                PHP
.f8051b	e2 20		sep #$20	                SEP #$20        ; set A short
.f8051d	c2 10		rep #$10	                REP #$10        ; set X long
.f8051f	bd 00 00	lda $f80000,x	iputs1          LDA $0,b,x      ; read from the string
.f80522	f0 08		beq $f8052c	                BEQ iputs_done
.f80524	22 30 05 f8	jsl $f80530	iputs2          JSL IPUTC
.f80528	e8		inx		iputs3          INX
.f80529	4c 1f 05	jmp $f8051f	                JMP iputs1
.f8052c	e8		inx		iputs_done      INX
.f8052d	28		plp		                PLP
.f8052e	68		pla		                PLA
.f8052f	6b		rtl		                RTL
.f80530	0b		phd		IPUTC           PHD
.f80531	08		php		                PHP             ; stash the flags (we'll be changing M)
.f80532	48		pha		                PHA             ; begin setdp macro
.f80533	08		php			PHP
.f80534	c2 20		rep #$20	                REP #$20        ; set A long
.f80536	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.f80539	5b		tcd		                TCD
.f8053a	28		plp			PLP
.f8053b	68		pla		                PLA             ; end setdp macro
.f8053c	e2 20		sep #$20	                SEP #$20        ; set A short
.f8053e	c9 0d		cmp #$0d	                CMP #$0D        ; handle CR
.f80540	d0 06		bne $f80548	                BNE iputc_bs
.f80542	22 5e 05 f8	jsl $f8055e	                JSL IPRINTCR
.f80546	80 10		bra $f80558	                bra iputc_done
.f80548	c9 08		cmp #$08	iputc_bs        CMP #$08        ; backspace
.f8054a	d0 06		bne $f80552	                BNE iputc_print
.f8054c	22 6f 05 f8	jsl $f8056f	                JSL IPRINTBS
.f80550	80 06		bra $f80558	                BRA iputc_done
.f80552	87 17		sta [$17]	iputc_print     STA [CURSORPOS] ; Save the character on the screen
.f80554	22 7f 05 f8	jsl $f8057f	                JSL ICSRRIGHT
.f80558					iputc_done
>f80558	42 01				                .byte $42, $01
.f8055a	28		plp		                PLP
.f8055b	2b		pld		                PLD
.f8055c	6b		rtl		                RTL
.f8055d					IPUTB
.f8055d	6b		rtl		                RTL
.f8055e	da		phx		IPRINTCR	PHX
.f8055f	5a		phy		                PHY
.f80560	08		php		                PHP
.f80561	a2 00 00	ldx #$0000	                LDX #0
.f80564	a4 1c		ldy $1c		                LDY CURSORY
.f80566	c8		iny		                INY
.f80567	22 ac 05 f8	jsl $f805ac	                JSL ILOCATE
.f8056b	28		plp		                PLP
.f8056c	7a		ply		                PLY
.f8056d	fa		plx		                PLX
.f8056e	6b		rtl		                RTL
.f8056f	da		phx		IPRINTBS	PHX
.f80570	5a		phy		                PHY
.f80571	08		php		                PHP
.f80572	a6 1a		ldx $1a		                LDX CURSORX
.f80574	a4 1c		ldy $1c		                LDY CURSORY
.f80576	ca		dex		                DEX
.f80577	22 ac 05 f8	jsl $f805ac	                JSL ILOCATE
.f8057b	28		plp		                PLP
.f8057c	7a		ply		                PLY
.f8057d	fa		plx		                PLX
.f8057e	6b		rtl		                RTL
.f8057f					ICSRRIGHT
.f8057f	da		phx		                PHX
.f80580	8b		phb		                PHB
.f80581	c2 20		rep #$20	                REP #$20        ; set A long
.f80583	c2 10		rep #$10	                REP #$10        ; set X long
.f80585	48		pha		                PHA             ; begin setdp macro
.f80586	08		php			PHP
.f80587	c2 20		rep #$20	                REP #$20        ; set A long
.f80589	a9 00 00	lda #$0000	                LDA #$0         ; set DP to page 0
.f8058c	5b		tcd		                TCD
.f8058d	28		plp			PLP
.f8058e	68		pla		                PLA             ; end setdp macro
.f8058f	e6 17		inc $17		                INC CURSORPOS
.f80591	a6 1a		ldx $1a		                LDX CURSORX
.f80593	e8		inx		                INX
.f80594	e4 0f		cpx $0f		                CPX COLS_VISIBLE
.f80596	90 0c		bcc $f805a4	                BCC icsr_nowrap  ; wrap if the cursor is at or past column 80
.f80598	a2 00 00	ldx #$0000	                LDX #0
.f8059b	5a		phy		                PHY
.f8059c	a4 1c		ldy $1c		                LDY CURSORY
.f8059e	c8		iny		                INY
.f8059f	22 ac 05 f8	jsl $f805ac	                JSL ILOCATE
.f805a3	7a		ply		                PLY
.f805a4	86 1a		stx $1a		icsr_nowrap     STX CURSORX
.f805a6	ab		plb		                PLB
.f805a7	fa		plx		                PLX
.f805a8	6b		rtl		                RTL
.f805a9	6b		rtl		ISRLEFT	RTL
.f805aa	6b		rtl		ICSRUP	RTL
.f805ab	6b		rtl		ICSRDOWN	RTL
.f805ac	48		pha		ILOCATE         PHA
.f805ad	08		php		                PHP
.f805ae	c2 30		rep #$30	                REP #$30        ; set A&X long
.f805b0					ilocate_scroll
.f805b0	c4 13		cpy $13		                CPY LINES_VISIBLE
.f805b2	90 07		bcc $f805bb	                BCC ilocate_scrolldone
.f805b4	22 d8 05 f8	jsl $f805d8	                JSL ISCROLLUP
.f805b8	88		dey		                DEY
.f805b9	80 f5		bra $f805b0	                BRA ilocate_scroll
.f805bb					ilocate_scrolldone
.f805bb	86 1a		stx $1a		                STX CURSORX
.f805bd	84 1c		sty $1c		                STY CURSORY
.f805bf	a5 0c		lda $0c		                LDA SCREENBEGIN
.f805c1					ilocate_row
.f805c1	c0 00 00	cpy #$0000	                CPY #$0
.f805c4	f0 08		beq $f805ce	                BEQ ilocate_right
.f805c6	18		clc		ilocate_down    CLC
.f805c7	65 11		adc $11		                ADC COLS_PER_LINE
.f805c9	88		dey		                DEY
.f805ca	f0 02		beq $f805ce	                BEQ ilocate_right
.f805cc	80 f8		bra $f805c6	                BRA ilocate_down
.f805ce	18		clc		ilocate_right   CLC
.f805cf	65 1a		adc $1a		                ADC CURSORX             ; move the cursor right X columns
.f805d1	85 17		sta $17		                STA CURSORPOS
.f805d3	a4 1c		ldy $1c		                LDY CURSORY
.f805d5	28		plp		ilocate_done    PLP
.f805d6	68		pla		                PLA
.f805d7	6b		rtl		                RTL
.f805d8					ISCROLLUP
.f805d8	48		pha		                PHA
.f805d9	da		phx		                PHX
.f805da	5a		phy		                PHY
.f805db	8b		phb		                PHB
.f805dc	08		php		                PHP
.f805dd	c2 30		rep #$30	                REP #$30        ; set A&X long
.f805df	18		clc		                CLC
.f805e0	a5 0c		lda $0c		                LDA SCREENBEGIN
.f805e2	a8		tay		                TAY             ; Destination is first row
.f805e3	65 11		adc $11		                ADC COLS_PER_LINE
.f805e5	aa		tax		                TAX             ; Source is second row
.f805e6	a9 ef 1f	lda #$1fef	                LDA #SCREEN_PAGE1-SCREEN_PAGE0-COLS_PER_LINE
.f805e9	44 00 00	mvp $00,$00	                MVP $00,$00
.f805ec	28		plp		                PLP
.f805ed	ab		plb		                PLB
.f805ee	7a		ply		                PLY
.f805ef	fa		plx		                PLX
.f805f0	68		pla		                PLA
.f805f1	6b		rtl		                RTL
.f805f2	00		brk #		IRESTORE        BRK ; Warm boot routine
.f805f3	00		brk #		ISCINIT         BRK ;
.f805f4	00		brk #		IIOINIT         BRK ;
.f805f5	00		brk #		IPUTBLOCK       BRK ; Ouput a binary block to the currently selected channel
.f805f6	00		brk #		ISETLFS         BRK ; Obsolete (done in OPEN)
.f805f7	00		brk #		ISETNAM         BRK ; Obsolete (done in OPEN)
.f805f8	00		brk #		IOPEN           BRK ; Open a channel for reading and/or writing. Use SETLFS and SETNAM to set the channels and filename first.
.f805f9	00		brk #		ICLOSE          BRK ; Close a channel
.f805fa	00		brk #		ISETIN          BRK ; Set the current input channel
.f805fb	00		brk #		ISETOUT         BRK ; Set the current output channel
.f805fc	00		brk #		IGETB           BRK ; Get a byte from input channel. Return 0 if no input. Carry is set if no input.
.f805fd	00		brk #		IGETBLOCK       BRK ; Get a X byes from input channel. If Carry is set, wait. If Carry is clear, do not wait.
.f805fe	00		brk #		IGETCH          BRK ; Get a character from the input channel. A=0 and Carry=1 if no data is wating
.f805ff	00		brk #		IGETS           BRK ; Get a string from the input channel. NULL terminates
.f80600	00		brk #		IGETLINE        BRK ; Get a line of text from input channel. CR or NULL terminates.
.f80601	00		brk #		IGETFIELD       BRK ; Get a field from the input channel. Value in A, CR, or NULL terminates
.f80602	00		brk #		ITRIM           BRK ; Removes spaces at beginning and end of string.
.f80603	00		brk #		IPRINTC         BRK ; Print character to screen. Handles terminal commands
.f80604	00		brk #		IPRINTS         BRK ; Print string to screen. Handles terminal commands
.f80605	00		brk #		IPRINTF         BRK ; Print a float value
.f80606	00		brk #		IPRINTI         BRK ; Prints integer value in TEMP
.f80607	00		brk #		IPRINTH         BRK ; Print Hex value in DP variable
.f80608	00		brk #		IPRINTAI        BRK ; Prints integer value in A
.f80609	00		brk #		IPRINTAH        BRK ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
.f8060a	00		brk #		IPUSHKEY        BRK ;
.f8060b	00		brk #		IPUSHKEYS       BRK ;
.f8060c	00		brk #		ICSRLEFT        BRK ;
.f8060d	00		brk #		ICSRHOME        BRK ;
>f8f000	20 20 2f 2f 2f 2f 2f 20		greet_msg       .text "  ///// FOENIX 256 DEVELOPMENT SYSTEM",$0D
>f8f008	46 4f 45 4e 49 58 20 32 35 36 20 44 45 56 45 4c
>f8f018	4f 50 4d 45 4e 54 20 53 59 53 54 45 4d 0d
>f8f026	20 2f 2f 2f 2f 2f 20 20		greet_msg1      .text " /////  OPEN SOURCE COMPUTER",$0D
>f8f02e	4f 50 45 4e 20 53 4f 55 52 43 45 20 43 4f 4d 50
>f8f03e	55 54 45 52 0d
>f8f043	2f 2f 2f 2f 2f 20 20 20		greet_msg2      .null "/////   8192KB SYSTEM 8128KB FREE"
>f8f04b	38 31 39 32 4b 42 20 53 59 53 54 45 4d 20 38 31
>f8f05b	32 38 4b 42 20 46 52 45 45 00
>f8f065	0d 52 45 41 44 59 2e 00		ready_msg       .null $0D,"READY."
>f8f06d	31 30 20 50 52 49 4e 54		hello_basic     .null "10 PRINT ""Hello World""",$0D
>f8f075	20 22 48 65 6c 6c 6f 20 57 6f 72 6c 64 22 0d 00
>f8f085	52 55 4e 0d 00			                .null "RUN",$0D
>f8f08a	48 65 6c 6c 6f 20 57 6f		                .null "Hello World",$0D
>f8f092	72 6c 64 0d 00
>f8f097	0d 52 45 41 44 59 2e 00		                .null $0D,"READY."
>f8f09f	47 20 30 32 30 30 30 30		hello_ml        .null "G 020000",$0D
>f8f0a7	0d 00
>f8f0a9	48 45 4c 4c 4f 20 57 4f		                .null "HELLO WORLD",$0D
>f8f0b1	52 4c 44 0d 00
>f8f0b6	0d 00				                .null $0D
>f8f0b8	20 50 43 20 20 20 20 20		                .null " PC     A    X    Y    SP   DBR DP   NVMXDIZC",$0D
>f8f0c0	41 20 20 20 20 58 20 20 20 20 59 20 20 20 20 53
>f8f0d0	50 20 20 20 44 42 52 20 44 50 20 20 20 4e 56 4d
>f8f0e0	58 44 49 5a 43 0d 00
>f8f0e7	3b 30 30 32 31 31 32 20		                .null ";002112 0019 F0AA 0000 D6FF F8  0000 --M-----"
>f8f0ef	30 30 31 39 20 46 30 41 41 20 30 30 30 30 20 44
>f8f0ff	36 46 46 20 46 38 20 20 30 30 30 30 20 2d 2d 4d
>f8f10f	2d 2d 2d 2d 2d 00
>f8f115	41 42 4f 52 54 20 45 52		error_01        .null "ABORT ERROR"
>f8f11d	52 4f 52 00

;******  End of listing
