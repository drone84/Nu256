
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass --long-address --intel-hex -o kernel.hex --list kernel.lst kernel.asm
; Mon Oct 08 20:51:56 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm


;******  Processing file: macros_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: simulator_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: page_00_inc.asm

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;2 Bytes Color of next character to be printed to the screen.
=$000020				CURATTR          = $000020 ;2 Bytes Attribute of next character to be printed to the screen.
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$0000d0				KERNEL_TEMP      = $0000D0 ;32 Bytes Temp space for kernel
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000108				DIVIDER_0        = $000108 ;0 Byte  Unsigned divider
=$000108				D0_OPERAND_A     = $000108 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$00010a				D0_OPERAND_B     = $00010A ;2 Bytes Divider 0 Divisor ex B in A/B
=$00010c				D0_RESULT        = $00010C ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$00010e				D0_REMAINDER     = $00010E ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000110				DIVIDER_1        = $000110 ;0 Byte  Signed divider
=$000110				D1_OPERAND_A     = $000110 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$000112				D1_OPERAND_B     = $000112 ;2 Bytes Divider 1 Divisor ex B in A/B
=$000114				D1_RESULT        = $000114 ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D1_REMAINDER     = $000116 ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$0001ff				VECTOR_STATE     = $0001FF ;1 Byte  Interrupt Vector State. See VECTOR_STATE_ENUM
=$000200				CPU_REGISTERS    = $000200 ; Byte
=$000200				CPUPC            = $000200 ;2 Bytes Program Counter (PC)
=$000202				CPUPBR           = $000202 ;2 Bytes Program Bank Register (K)
=$000204				CPUA             = $000204 ;2 Bytes Accumulator (A)
=$000206				CPUX             = $000206 ;2 Bytes X Register (X)
=$000208				CPUY             = $000208 ;2 Bytes Y Register (Y)
=$00020a				CPUSTACK         = $00020A ;2 Bytes Stack Pointer (S)
=$00020c				CPUDP            = $00020C ;2 Bytes Direct Page Register (D)
=$00020e				CPUDBR           = $00020E ;1 Byte  Data Bank Register (B)
=$00020f				CPUFLAGS         = $00020F ;1 Byte  Flags (P)
=$000210				MONITOR_VARS     = $000210 ; Byte  MONITOR Variables. BASIC variables may overlap this space
=$000210				MCMDADDR         = $000210 ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$000213				MCMP_TEXT        = $000213 ;3 Bytes Address of symbol being evaluated for COMPARE routine
=$000216				MCMP_LEN         = $000216 ;2 Bytes Length of symbol being evaluated for COMPARE routine
=$000218				MCMD             = $000218 ;3 Bytes Address of the current command/function string
=$00021b				MCMD_LEN         = $00021B ;2 Bytes Length of the current command/function string
=$00021d				MARG1            = $00021D ;4 Bytes First command argument. May be data or address, depending on command
=$000221				MARG2            = $000221 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000225				MARG3            = $000225 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000229				MARG4            = $000229 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$00022d				MARG5            = $00022D ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000231				MARG6            = $000231 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000235				MARG7            = $000235 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000239				MARG8            = $000239 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000400				STEF_BLOB_BEGIN  = $000400 ; Temp Buffer for Testing
=$0004ff				STEF_BLOB_END    = $0004FF ;
=$000f00				KEY_BUFFER       = $000F00 ;64 Bytes keyboard buffer
=$40					KEY_BUFFER_SIZE  = $40 ;64 Bytes (constant) keyboard buffer length
=$000f3f				KEY_BUFFER_END   = $000F3F ;1 Byte  Last byte of keyboard buffer
=$000f40				KEY_BUFFER_RPOS  = $000F40 ;2 Bytes keyboard buffer read position
=$000f42				KEY_BUFFER_WPOS  = $000F42 ;2 Bytes keyboard buffer write position
=$001000				TEST_BEGIN       = $001000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ff00				ISR_BEGIN        = $00FF00 ; Byte  Beginning of CPU vectors in Direct page
=$00ff00				HRESET           = $00FF00 ;16 Bytes Handle RESET asserted. Reboot computer and re-initialize the kernel.
=$00ff10				HCOP             = $00FF10 ;16 Bytes Handle the COP instruction. Program use; not used by OS
=$00ff20				HBRK             = $00FF20 ;16 Bytes Handle the BRK instruction. Returns to BASIC Ready prompt.
=$00ff30				HABORT           = $00FF30 ;16 Bytes Handle ABORT asserted. Return to Ready prompt with an error message.
=$00ff40				HNMI             = $00FF40 ;32 Bytes Handle NMI
=$00ff60				HIRQ             = $00FF60 ;32 Bytes Handle IRQ
=$00ff80				Unused_FF80      = $00FF80 ;End of direct page Interrrupt handlers
=$00ffe0				VECTORS_BEGIN    = $00FFE0 ;0 Byte  Interrupt vectors
=$00ffe0				JMP_READY        = $00FFE0 ;4 Bytes Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$00ffe4				VECTOR_COP       = $00FFE4 ;2 Bytes Native COP Interrupt vector
=$00ffe6				VECTOR_BRK       = $00FFE6 ;2 Bytes Native BRK Interrupt vector
=$00ffe8				VECTOR_ABORT     = $00FFE8 ;2 Bytes Native ABORT Interrupt vector
=$00ffea				VECTOR_NMI       = $00FFEA ;2 Bytes Native NMI Interrupt vector
=$00ffec				VECTOR_RESET     = $00FFEC ;2 Bytes Unused (Native RESET vector)
=$00ffee				VECTOR_IRQ       = $00FFEE ;2 Bytes Native IRQ Vector
=$00fff0				RETURN           = $00FFF0 ;4 Bytes RETURN key handler. Points to BASIC or MONITOR subroutine to execute when RETURN is pressed.
=$00fff4				VECTOR_ECOP      = $00FFF4 ;2 Bytes Emulation mode interrupt handler
=$00fff6				VECTOR_EBRK      = $00FFF6 ;2 Bytes Emulation mode interrupt handler
=$00fff8				VECTOR_EABORT    = $00FFF8 ;2 Bytes Emulation mode interrupt handler
=$00fffa				VECTOR_ENMI      = $00FFFA ;2 Bytes Emulation mode interrupt handler
=$00fffc				VECTOR_ERESET    = $00FFFC ;2 Bytes Emulation mode interrupt handler
=$00fffe				VECTOR_EIRQ      = $00FFFE ;2 Bytes Emulation mode interrupt handler
=$010000				VECTORS_END      = $010000 ;*End of vector space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: kernel.asm


;******  Processing file: page_00_data.asm

>0000	00 00 00 00 00 00 00 00		                .fill 12,0          ; unused_0000, 12 bytes, unused
>0008	00 00 00 00
>000c	00 00 80			                .long $800000       ; SCREENBEGIN, 3 bytes, Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
>000f	50 00				                .word 80            ; COLS_VISIBLE, 2 bytes, Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
>0011	80 00				                .word 128           ; COLS_PER_LINE, 2 bytes, Columns in memory per screen line. A virtual line can be this long. Default=128
>0013	3c 00				                .word 60            ; LINES_VISIBLE, 2 bytes, The number of rows visible on the screen. Default=25
>0015	40 00				                .word 64            ; LINES_MAX, 2 bytes, The number of rows in memory for the screen. Default=64
>0017	00 00 80			                .long $800000       ; CURSORPOS, 3 bytes, The next character written to the screen will be written in this location.
>001a	00 00				                .word 0             ; CURSORX, 2 bytes, This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
>001c	00 00				                .word 0             ; CURSORY, 2 bytes, This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
>001e	0f				                .byte $0F           ; CURCOLOR, 2 bytes, Color of next character to be printed to the screen.
>001f	00				                .byte $00           ; CURATTR, 2 bytes, Attribute of next character to be printed to the screen.
>0020	00 80				                .word STACK_BEGIN   ; STACKBOT, 2 bytes, Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
>0022	ff fe				                .word STACK_END     ; STACKTOP, 2 bytes, Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.

;******  Return to file: kernel.asm


;******  Processing file: page_00_code.asm

.ff00	18		clc		RHRESET         CLC
.ff01	fb		xce		                XCE
.ff02	5c 00 00 01	jmp $010000	                JML BOOT
.ff10					RHCOP
.ff10	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff12	8b		phb		                PHB
.ff13	0b		phd		                PHD
.ff14	48		pha		                PHA
.ff15	da		phx		                PHX
.ff16	5a		phy		                PHY
.ff17	5c 08 00 01	jmp $010008	                JML BREAK
.ff20					RHBRK
.ff20	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff22	8b		phb		                PHB
.ff23	0b		phd		                PHD
.ff24	48		pha		                PHA
.ff25	da		phx		                PHX
.ff26	5a		phy		                PHY
.ff27	5c 08 00 01	jmp $010008	                JML BREAK
.ff30					RHABORT
.ff30	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff32	8b		phb		                PHB
.ff33	0b		phd		                PHD
.ff34	48		pha		                PHA
.ff35	da		phx		                PHX
.ff36	5a		phy		                PHY
.ff37	5c 08 00 01	jmp $010008	                JML BREAK
.ff40					 RHNMI
.ff40	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff42	8b		phb		                PHB
.ff43	0b		phd		                PHD
.ff44	48		pha		                PHA
.ff45	da		phx		                PHX
.ff46	5a		phy		                PHY
.ff47	7a		ply		                PLY
.ff48	fa		plx		                PLX
.ff49	68		pla		                PLA
.ff4a	2b		pld		                PLD
.ff4b	ab		plb		                PLB
.ff4c	40		rti		                RTI
.ff60					RHIRQ
.ff60	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff62	8b		phb		                PHB
.ff63	0b		phd		                PHD
.ff64	48		pha		                PHA
.ff65	da		phx		                PHX
.ff66	5a		phy		                PHY
.ff67	7a		ply		                PLY
.ff68	fa		plx		                PLX
.ff69	68		pla		                PLA
.ff6a	2b		pld		                PLD
.ff6b	ab		plb		                PLB
.ff6c	40		rti		                RTI
.ffe0	5c 66 80 01	jmp $018066	JUMP_READY      JML IMREADY     ; Kernel READY routine. Rewrite this address to jump to a custom kernel.
>ffe4	10 ff				RVECTOR_COP     .word HCOP     ; FFE4
>ffe6	20 ff				RVECTOR_BRK     .word HBRK     ; FFE6
>ffe8	30 ff				RVECTOR_ABORT   .word HABORT   ; FFE8
>ffea	40 ff				RVECTOR_NMI     .word HNMI     ; FFEA
>ffec	00 00				                .word $0000    ; FFEC
>ffee	60 ff				RVECTOR_IRQ     .word HIRQ     ; FFEE
.fff0	5c 29 05 01	jmp $010529	RRETURN         JML IRETURN
>fff4	10 ff				RVECTOR_ECOP    .word HCOP     ; FFF4
>fff6	20 ff				RVECTOR_EBRK    .word HBRK     ; FFF6
>fff8	30 ff				RVECTOR_EABORT  .word HABORT   ; FFF8
>fffa	40 ff				RVECTOR_ENMI    .word HNMI     ; FFFA
>fffc	00 ff				RVECTOR_ERESET  .word HRESET   ; FFFC
>fffe	60 ff				RVECTOR_EIRQ    .word HIRQ     ; FFFE

;******  Return to file: kernel.asm


;******  Processing file: dram_inc.asm

=$800000				SCREEN_PAGE0     = $800000 ;8192 Bytes First page of display RAM. This is used at boot time to display the welcome screen and the BASIC or MONITOR command screens.
=$802000				SCREEN_PAGE1     = $802000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$804000				SCREEN_PAGE2     = $804000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$806000				SCREEN_PAGE3     = $806000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$808000				SCREEN_END       = $808000 ;End of display memory

;******  Return to file: kernel.asm


;******  Processing file: vicky_def.asm

=$7f0000				MASTER_CTRL_REG_L	= $7F0000
=$7f0001				MASTER_CTRL_REG_H	= $7F0001
=$7f0008				TXT_CTRL_REG_L		= $7F0008
=$7f0009				TXT_CTRL_REG_H		= $7F0009
=$7f000a				TXT_CURSOR_CTRL		= $7F000A
=$7f000b				TXT_CURSOR_COLOR	= $7F000B
=$7f000c				TXT_CURSOR_X_REG_L	= $7F000C
=$7f000d				TXT_CURSOR_X_REG_H	= $7F000D
=$7f000e				TXT_CURSOR_Y_REG_L	= $7F000E
=$7f000f				TXT_CURSOR_Y_REG_H	= $7F000F
=$7f1f40				FG_CHAR_LUT_PTR		= $7F1F40
=$7f1f80				BG_CHAR_LUT_PTR		= $7F1F80
=$7f2000				GRPH_LUT0_PTR		= $7F2000
=$7f2400				GRPH_LUT1_PTR		= $7F2400
=$7f2800				GRPH_LUT2_PTR		= $7F2800
=$7f2c00				GRPH_LUT3_PTR		= $7F2C00
=$7f3000				GRPH_LUT4_PTR		= $7F3000
=$7f3400				GRPH_LUT5_PTR		= $7F3400
=$7f3800				GRPH_LUT6_PTR		= $7F3800
=$7f3c00				GAMMA_LUT_PTR		= $7F3C00

;******  Return to file: kernel.asm


;******  Processing file: super_io_def.asm

=$7f1100				PME_STS_REG		= $7F1100
=$7f1102				PME_EN_REG		= $7F1102
=$7f1104				PME_STS1_REG		= $7F1104
=$7f1105				PME_STS2_REG		= $7F1105
=$7f1106				PME_STS3_REG		= $7F1106
=$7f1107				PME_STS4_REG		= $7F1107
=$7f1108				PME_STS5_REG		= $7F1108
=$7f110a				PME_EN1_REG		= $7F110A
=$7f110b				PME_EN2_REG		= $7F110B
=$7f110c				PME_EN3_REG		= $7F110C
=$7f110d				PME_EN4_REG		= $7F110D
=$7f110e				PME_EN5_REG		= $7F110E
=$7f1110				SMI_STS1_REG		= $7F1110
=$7f1111				SMI_STS2_REG		= $7F1111
=$7f1112				SMI_STS3_REG		= $7F1112
=$7f1113				SMI_STS4_REG		= $7F1113
=$7f1114				SMI_STS5_REG		= $7F1114
=$7f1116				SMI_EN1_REG		= $7F1116
=$7f1117				SMI_EN2_REG		= $7F1117
=$7f1118				SMI_EN3_REG		= $7F1118
=$7f1119				SMI_EN4_REG		= $7F1119
=$7f111a				SMI_EN5_REG		= $7F111A
=$7f111c				MSC_ST_REG		= $7F111C
=$7f111e				FORCE_DISK_CHANGE       = $7F111E
=$7f111f				FLOPPY_DATA_RATE        = $7F111F
=$7f1120				UART1_FIFO_CTRL_SHDW    = $7F1120
=$7f1121				UART2_FIFO_CTRL_SHDW    = $7F1121
=$7f1122				DEV_DISABLE_REG         = $7F1122
=$7f1123				GP10_REG    		= $7F1123
=$7f1124				GP11_REG    		= $7F1124
=$7f1125				GP12_REG    		= $7F1125
=$7f1126				GP13_REG    		= $7F1126
=$7f1127				GP14_REG    		= $7F1127
=$7f1128				GP15_REG    		= $7F1128
=$7f1129				GP16_REG    		= $7F1129
=$7f112a				GP17_REG    		= $7F112A
=$7f112b				GP20_REG    		= $7F112B
=$7f112c				GP21_REG    		= $7F112C
=$7f112d				GP22_REG		= $7F112D
=$7f112f				GP24_REG		= $7F112F
=$7f1130				GP25_REG		= $7F1130
=$7f1131				GP26_REG		= $7F1131
=$7f1132				GP27_REG		= $7F1132
=$7f1133				GP30_REG		= $7F1133
=$7f1134				GP31_REG		= $7F1134
=$7f1135				GP32_REG		= $7F1135
=$7f1136				GP33_REG		= $7F1136
=$7f1137				GP34_REG		= $7F1137
=$7f1138				GP35_REG		= $7F1138
=$7f1139				GP36_REG		= $7F1139
=$7f113a				GP37_REG		= $7F113A
=$7f113b				GP40_REG		= $7F113B
=$7f113c				GP41_REG		= $7F113C
=$7f113d				GP42_REG		= $7F113D
=$7f113e				GP43_REG		= $7F113E
=$7f113f				GP50_REG		= $7F113F
=$7f1140				GP51_REG		= $7F1140
=$7f1141				GP52_REG		= $7F1141
=$7f1142				GP53_REG		= $7F1142
=$7f1143				GP54_REG		= $7F1143
=$7f1144				GP55_REG		= $7F1144
=$7f1145				GP56_REG		= $7F1145
=$7f1146				GP57_REG		= $7F1146
=$7f1147				GP60_REG		= $7F1147
=$7f1148				GP61_REG		= $7F1148
=$7f114b				GP1_REG			= $7F114B
=$7f114c				GP2_REG			= $7F114C
=$7f114d				GP3_REG			= $7F114D
=$7f114e				GP4_REG			= $7F114E
=$7f114f				GP5_REG			= $7F114F
=$7f1150				GP6_REG			= $7F1150
=$7f1156				FAN1_REG		= $7F1156
=$7f1157				FAN2_REG    		= $7F1157
=$7f1158				FAN_CTRL_REG    	= $7F1158
=$7f1159				FAN1_TACH_REG    	= $7F1159
=$7f115a				FAN2_TACH_REG    	= $7F115A
=$7f115b				FAN1_PRELOAD_REG        = $7F115B
=$7f115c				FAN2_PRELOAD_REG        = $7F115C
=$7f115d				LED1_REG    		= $7F115D
=$7f115e				LED2_REG    		= $7F115E
=$7f115f				KEYBOARD_SCAN_CODE	= $7F115F

;******  Return to file: kernel.asm


;******  Processing file: keyboard_def.asm

=$7f1064				STATUS_PORT 	        =	$7F1064
=$7f1060				KBD_OUT_BUF 	        =	$7F1060
=$7f1060				KBD_INPT_BUF	        = 	$7F1060
=$7f1064				KBD_CMD_BUF		= 	$7F1064
=$7f1060				KBD_DATA_BUF	        = 	$7F1060
=$7f1060				PORT_A			= 	$7F1060
=$7f1061				PORT_B			= 	$7F1061
=$01					OUT_BUF_FULL	        = 	$01
=$02					INPT_BUF_FULL	        = 	$02
=$04					SYS_FLAG		= 	$04
=$08					CMD_DATA		=	$08
=$10					KEYBD_INH		=	$10
=$20					TRANS_TMOUT		=	$20
=$40					RCV_TMOUT		=	$40
=$80					PARITY_EVEN		=	$80
=$10					INH_KEYBOARD	        =	$10
=$ae					KBD_ENA			=	$AE
=$ad					KBD_DIS			=	$AD
=$f1					KB_MENU			=	$F1
=$f4					KB_ENABLE		=	$F4
=$f7					KB_MAKEBREAK	        =	$F7
=$fe					KB_ECHO			=	$FE
=$ff					KB_RESET		=	$FF
=$ed					KB_LED_CMD		=	$ED
=$aa					KB_OK			=	$AA
=$fa					KB_ACK			=	$FA
=$ff					KB_OVERRUN		=	$FF
=$fe					KB_RESEND		=	$FE
=$f0					KB_BREAK		=	$F0
=$10					KB_FA			=	$10
=$20					KB_FE			=	$20
=$40					KB_PR_LED		=	$40

;******  Return to file: kernel.asm


;******  Processing file: VIA_def.asm

=$7f0c00				VIA0_IO_REG_B     = $7F0C00
=$7f0c01				VIA0_IO_REG_A     = $7F0C01
=$7f0c02				VIA0_DDR_REG_B    = $7F0C02
=$7f0c03				VIA0_DDR_REG_A    = $7F0C03
=$7f0c04				VIA0_T1C_L        = $7F0C04
=$7f0c05				VIA0_T1C_H        = $7F0C05
=$7f0c06				VIA0_T1L_L        = $7F0C06
=$7f0c07				VIA0_T1L_H        = $7F0C07
=$7f0c08				VIA0_T2C_L        = $7F0C08
=$7f0c09				VIA0_T2C_H        = $7F0C09
=$7f0c0a				VIA0_SR           = $7F0C0A
=$7f0c0b				VIA0_ACR          = $7F0C0B
=$7f0c0c				VIA0_PCR          = $7F0C0C
=$7f0c0d				VIA0_IFR          = $7F0C0D
=$7f0c0e				VIA0_IER          = $7F0C0E
=$7f0c0f				VIA0_ORA_IRA      = $7F0C0F
=$7f0d00				VIA1_IO_REG_B     = $7F0D00
=$7f0d01				VIA1_IO_REG_A     = $7F0D01
=$7f0d02				VIA1_DDR_REG_B    = $7F0D02
=$7f0d03				VIA1_DDR_REG_A    = $7F0D03
=$7f0d04				VIA1_T1C_L        = $7F0D04
=$7f0d05				VIA1_T1C_H        = $7F0D05
=$7f0d06				VIA1_T1L_L        = $7F0D06
=$7f0d07				VIA1_T1L_H        = $7F0D07
=$7f0d08				VIA1_T2C_L        = $7F0D08
=$7f0d09				VIA1_T2C_H        = $7F0D09
=$7f0d0a				VIA1_SR           = $7F0D0A
=$7f0d0b				VIA1_ACR          = $7F0D0B
=$7f0d0c				VIA1_PCR          = $7F0D0C
=$7f0d0d				VIA1_IFR          = $7F0D0D
=$7f0d0e				VIA1_IER          = $7F0D0E
=$7f0d0f				VIA1_ORA_IRA      = $7F0D0F

;******  Return to file: kernel.asm


;******  Processing file: SID_def.asm

=$7f0500				SID0_V1_FREQ_LO    = $7F0500 ;SID - L - Voice 1 (Write Only) - FREQ LOW
=$7f0501				SID0_V1_FREQ_HI    = $7F0501 ;SID - L - Voice 1 (Write Only) - FREQ HI
=$7f0502				SID0_V1_PW_LO      = $7F0502 ;SID - L - Voice 1 (Write Only) - PW LOW
=$7f0503				SID0_V1_PW_HI      = $7F0503 ;SID - L - Voice 1 (Write Only) - PW HI
=$7f0504				SID0_V1_CTRL       = $7F0504 ;SID - L - Voice 1 (Write Only) - CTRL REG
=$7f0505				SID0_V1_ATCK_DECY  = $7F0505 ;SID - L - Voice 1 (Write Only) - ATTACK / DECAY
=$7f0506				SID0_V1_SSTN_RLSE  = $7F0506 ;SID - L - Voice 1 (Write Only) - SUSTAIN / RELEASE
=$7f0507				SID0_V2_FREQ_LO    = $7F0507 ;SID - L - Voice 2 (Write Only) - FREQ LOW
=$7f0508				SID0_V2_FREQ_HI    = $7F0508 ;SID - L - Voice 2 (Write Only) - FREQ HI
=$7f0509				SID0_V2_PW_LO      = $7F0509 ;SID - L - Voice 2 (Write Only) - PW LOW
=$7f050a				SID0_V2_PW_HI      = $7F050A ;SID - L - Voice 2 (Write Only) - PW HI
=$7f050b				SID0_V2_CTRL       = $7F050B ;SID - L - Voice 2 (Write Only) - CTRL REG
=$7f050c				SID0_V2_ATCK_DECY  = $7F050C ;SID - L - Voice 2 (Write Only) - ATTACK / DECAY
=$7f050d				SID0_V2_SSTN_RLSE  = $7F050D ;SID - L - Voice 2 (Write Only) - SUSTAIN / RELEASE
=$7f050e				SID0_V3_FREQ_LO    = $7F050E ;SID - L - Voice 3 (Write Only) - FREQ LOW
=$7f050f				SID0_V3_FREQ_HI    = $7F050F ;SID - L - Voice 3 (Write Only) - FREQ HI
=$7f0510				SID0_V3_PW_LO      = $7F0510 ;SID - L - Voice 3 (Write Only) - PW LOW
=$7f0511				SID0_V3_PW_HI      = $7F0511 ;SID - L - Voice 3 (Write Only) - PW HI
=$7f0512				SID0_V3_CTRL       = $7F0512 ;SID - L - Voice 3 (Write Only) - CTRL REG
=$7f0513				SID0_V3_ATCK_DECY  = $7F0513 ;SID - L - Voice 3 (Write Only) - ATTACK / DECAY
=$7f0514				SID0_V3_SSTN_RLSE  = $7F0514 ;SID - L - Voice 3 (Write Only) - SUSTAIN / RELEASE
=$7f0515				SID0_FC_LO         = $7F0515 ;SID - L - Filter (Write Only) - FC LOW
=$7f0516				SID0_FC_HI         = $7F0516 ;SID - L - Filter (Write Only) - FC HI
=$7f0517				SID0_RES_FILT      = $7F0517 ;SID - L - Filter (Write Only) - RES / FILT
=$7f0518				SID0_MODE_VOL      = $7F0518 ;SID - L - Filter (Write Only) - MODE / VOL
=$7f0519				SID0_POT_X         = $7F0519 ;SID - L - Misc (Read Only) - POT X (C256 - NOT USED)
=$7f051a				SID0_POT_Y         = $7F051A ;SID - L - Misc (Read Only) - POT Y (C256 - NOT USED)
=$7f051b				SID0_OSC3_RND      = $7F051B ;SID - L - Misc (Read Only) - OSC3 / RANDOM
=$7f051c				SID0_ENV3          = $7F051C ;SID - L - Misc (Read Only)  - ENV3
=$7f051d				SID0_NOT_USED0     = $7F051D ;SID - L - NOT USED
=$7f051e				SID0_NOT_USED1     = $7F051E ;SID - L - NOT USED
=$7f051f				SID0_NOT_USED2     = $7F051F ;SID - L - NOT USED
=$7f0580				SID1_V1_FREQ_LO    = $7F0580 ;SID - R - Voice 1 (Write Only) - FREQ LOW
=$7f0581				SID1_V1_FREQ_HI    = $7F0581 ;SID - R - Voice 1 (Write Only) - FREQ HI
=$7f0582				SID1_V1_PW_LO      = $7F0582 ;SID - R - Voice 1 (Write Only) - PW LOW
=$7f0583				SID1_V1_PW_HI      = $7F0583 ;SID - R - Voice 1 (Write Only) - PW HI
=$7f0584				SID1_V1_CTRL       = $7F0584 ;SID - R - Voice 1 (Write Only) - CTRL REG
=$7f0585				SID1_V1_ATCK_DECY  = $7F0585 ;SID - R - Voice 1 (Write Only) - ATTACK / DECAY
=$7f0586				SID1_V1_SSTN_RLSE  = $7F0586 ;SID - R - Voice 1 (Write Only) - SUSTAIN / RELEASE
=$7f0587				SID1_V2_FREQ_LO    = $7F0587 ;SID - R - Voice 2 (Write Only) - FREQ LOW
=$7f0588				SID1_V2_FREQ_HI    = $7F0588 ;SID - R - Voice 2 (Write Only) - FREQ HI
=$7f0589				SID1_V2_PW_LO      = $7F0589 ;SID - R - Voice 2 (Write Only) - PW LOW
=$7f058a				SID1_V2_PW_HI      = $7F058A ;SID - R - Voice 2 (Write Only) - PW HI
=$7f058b				SID1_V2_CTRL       = $7F058B ;SID - R - Voice 2 (Write Only) - CTRL REG
=$7f058c				SID1_V2_ATCK_DECY  = $7F058C ;SID - R - Voice 2 (Write Only) - ATTACK / DECAY
=$7f058d				SID1_V2_SSTN_RLSE  = $7F058D ;SID - R - Voice 2 (Write Only) - SUSTAIN / RELEASE
=$7f058e				SID1_V3_FREQ_LO    = $7F058E ;SID - R - Voice 3 (Write Only) - FREQ LOW
=$7f058f				SID1_V3_FREQ_HI    = $7F058F ;SID - R - Voice 3 (Write Only) - FREQ HI
=$7f0590				SID1_V3_PW_LO      = $7F0590 ;SID - R - Voice 3 (Write Only) - PW LOW
=$7f0591				SID1_V3_PW_HI      = $7F0591 ;SID - R - Voice 3 (Write Only) - PW HI
=$7f0592				SID1_V3_CTRL       = $7F0592 ;SID - R - Voice 3 (Write Only) - CTRL REG
=$7f0593				SID1_V3_ATCK_DECY  = $7F0593 ;SID - R - Voice 3 (Write Only) - ATTACK / DECAY
=$7f0594				SID1_V3_SSTN_RLSE  = $7F0594 ;SID - R - Voice 3 (Write Only) - SUSTAIN / RELEASE
=$7f0595				SID1_FC_LO         = $7F0595 ;SID - R - Filter (Write Only) - FC LOW
=$7f0596				SID1_FC_HI         = $7F0596 ;SID - R - Filter (Write Only) - FC HI
=$7f0597				SID1_RES_FILT      = $7F0597 ;SID - R - Filter (Write Only) - RES / FILT
=$7f0598				SID1_MODE_VOL      = $7F0598 ;SID - R - Filter (Write Only) - MODE / VOL
=$7f0599				SID1_POT_X         = $7F0599 ;SID - R - Misc (Read Only) - POT X (C256 - NOT USED)
=$7f059a				SID1_POT_Y         = $7F059A ;SID - R - Misc (Read Only) - POT Y (C256 - NOT USED)
=$7f059b				SID1_OSC3_RND      = $7F059B ;SID - R - Misc (Read Only) - OSC3 / RANDOM
=$7f059c				SID1_ENV3          = $7F059C ;SID - R - Misc (Read Only)  - ENV3
=$7f059d				SID1_NOT_USED0     = $7F059D ;SID - R - NOT USED
=$7f059e				SID1_NOT_USED1     = $7F059E ;SID - R - NOT USED
=$7f059f				SID1_NOT_USED2     = $7F059F ;SID - R - NOT USED

;******  Return to file: kernel.asm


;******  Processing file: RTC_def.asm

=$7f0800				RTC_SEC       = $7F0800 ;Seconds Register
=$7f0801				RTC_SEC_ALARM = $7F0801 ;Seconds Alarm Register
=$7f0802				RTC_MIN       = $7F0802 ;Minutes Register
=$7f0803				RTC_MIN_ALARM = $7F0803 ;Minutes Alarm Register
=$7f0804				RTC_HRS       = $7F0804 ;Hours Register
=$7f0805				RTC_HRS_ALARM = $7F0805 ;Hours Alarm Register
=$7f0806				RTC_DAY       = $7F0806 ;Day Register
=$7f0807				RTC_DAY_ALARM = $7F0807 ;Day Alarm Register
=$7f0808				RTC_DOW       = $7F0808 ;Day of Week Register
=$7f0809				RTC_MONTH     = $7F0809 ;Month Register
=$7f080a				RTC_YEAR      = $7F080A ;Year Register
=$7f080b				RTC_RATES     = $7F080B ;Rates Register
=$7f080c				RTC_ENABLE    = $7F080C ;Enables Register
=$7f080d				RTC_FLAGS     = $7F080D ;Flags Register
=$7f080e				RTC_CTRL      = $7F080E ;Control Register
=$7f080f				RTC_CENTURY   = $7F080F ;Century Register

;******  Return to file: kernel.asm


;******  Processing file: Math_def.asm

=$000100				UNSIGNED_MULT_A_LO  = $000100
=$000101				UNSIGNED_MULT_A_HI  = $000101
=$000102				UNSIGNED_MULT_B_LO  = $000102
=$000103				UNSIGNED_MULT_B_HI  = $000103
=$000104				UNSIGNED_MULT_AL_LO = $000104
=$000105				UNSIGNED_MULT_AL_HI = $000105
=$000106				UNSIGNED_MULT_AH_LO = $000106
=$000107				UNSIGNED_MULT_AH_HI = $000107
=$000108				SIGNED_MULT_A_LO    = $000108
=$000109				SIGNED_MULT_A_HI    = $000109
=$00010a				SIGNED_MULT_B_LO    = $00010A
=$00010b				SIGNED_MULT_B_HI    = $00010B
=$00010c				SIGNED_MULT_AL_LO   = $00010C
=$00010d				SIGNED_MULT_AL_HI   = $00010D
=$00010e				SIGNED_MULT_AH_LO   = $00010E
=$00010f				SIGNED_MULT_AH_HI   = $00010F
=$000110				UNSIGNED_DIV_DEM_LO = $000110
=$000111				UNSIGNED_DIV_DEM_HI = $000111
=$000112				UNSIGNED_DIV_NUM_LO = $000112
=$000113				UNSIGNED_DIV_NUM_HI = $000113
=$000114				UNSIGNED_DIV_QUO_LO = $000114
=$000115				UNSIGNED_DIV_QUO_HI = $000115
=$000116				UNSIGNED_DIV_REM_LO = $000116
=$000117				UNSIGNED_DIV_REM_HI = $000117
=$000118				SIGNED_DIV_DEM_LO   = $000118
=$000119				SIGNED_DIV_DEM_HI   = $000119
=$00011a				SIGNED_DIV_NUM_LO   = $00011A
=$00011b				SIGNED_DIV_NUM_HI   = $00011B
=$00011c				SIGNED_DIV_QUO_LO   = $00011C
=$00011d				SIGNED_DIV_QUO_HI   = $00011D
=$00011e				SIGNED_DIV_REM_LO   = $00011E
=$00011f				SIGNED_DIV_REM_HI   = $00011F

;******  Return to file: kernel.asm


;******  Processing file: monitor.asm

.018000	5c 5c 80 01	jmp $01805c	MONITOR         JML IMONITOR
.018004	5c 88 80 01	jmp $018088	MSTATUS         JML IMSTATUS
.018008	5c 66 80 01	jmp $018066	MREADY          JML IMREADY
.01800c	5c 33 81 01	jmp $018133	MRETURN         JML IMRETURN
.018010	5c 34 81 01	jmp $018134	MPARSE          JML IMPARSE
.018014	5c 35 81 01	jmp $018135	MPARSE1         JML IMPARSE1
.018018	5c 36 81 01	jmp $018136	MEXECUTE        JML IMEXECUTE
.01801c	5c 37 81 01	jmp $018137	MASSEMBLE       JML IMASSEMBLE
.018020	5c 38 81 01	jmp $018138	MASSEMBLEA      JML IMASSEMBLEA
.018024	5c 39 81 01	jmp $018139	MCOMPARE        JML IMCOMPARE
.018028	5c 3a 81 01	jmp $01813a	MDISASSEMBLE    JML IMDISASSEMBLE
.01802c	5c 3b 81 01	jmp $01813b	MFILL           JML IMFILL
.018030	5c 3d 81 01	jmp $01813d	MJUMP           JML IMJUMP
.018034	5c 3e 81 01	jmp $01813e	MHUNT           JML IMHUNT
.018038	5c 3f 81 01	jmp $01813f	MLOAD           JML IMLOAD
.01803c	5c 40 81 01	jmp $018140	MMEMORY         JML IMMEMORY
.018040	5c 41 81 01	jmp $018141	MREGISTERS      JML IMREGISTERS
.018044	5c 42 81 01	jmp $018142	MSAVE           JML IMSAVE
.018048	5c 43 81 01	jmp $018143	MTRANSFER       JML IMTRANSFER
.01804c	5c 44 81 01	jmp $018144	MVERIFY         JML IMVERIFY
.018050	5c 45 81 01	jmp $018145	MEXIT           JML IMEXIT
.018054	5c 46 81 01	jmp $018146	MMODIFY         JML IMMODIFY
.018058	5c 47 81 01	jmp $018147	MDOS            JML IMDOS
.01805c	18		clc		IMONITOR        CLC           ; clear the carry flag
.01805d	fb		xce		                XCE           ; move carry to emulation flag.
.01805e	a9 ff fe	lda #$feff	                LDA #STACK_END ; Reset the stack
.018061	1b		tcs		                TAS
.018062	5c 66 80 01	jmp $018066	                JML IMREADY
.018066					IMREADY
.018066	c2 30		rep #$30	                REP #$30        ; set A&X long
.018068	a9 66 80	lda #$8066	                LDA #<>IMREADY
.01806b	8d e1 ff	sta $ffe1	                STA JMP_READY+1
.01806e	e2 20		sep #$20	                SEP #$20        ; set A short
.018070	a9 01		lda #$01	                LDA #`IMREADY
.018072	8d e3 ff	sta $ffe3	                STA JMP_READY+3
.018075	c2 20		rep #$20	                REP #$20        ; set A long
.018077	a9 33 81	lda #$8133	                LDA #<>IMRETURN
.01807a	8d f1 ff	sta $fff1	                STA RETURN+1
.01807d	e2 20		sep #$20	                SEP #$20        ; set A short
.01807f	a9 01		lda #$01	                LDA #`IMRETURN
.018081	8d f3 ff	sta $fff3	                STA RETURN+3
.018084	5c 88 80 01	jmp $018088	                JML IMSTATUS
.018088					IMSTATUS
.018088	48		pha		                PHA             ; begin setdbr macro
.018089	08		php		                PHP
.01808a	e2 20		sep #$20	                SEP #$20        ; set A short
.01808c	a9 01		lda #$01		LDA #`mregisters_msg
.01808e	48		pha		                PHA
.01808f	ab		plb		                PLB
.018090	28		plp		                PLP
.018091	68		pla		                PLA             ; end setdbr macro
.018092	a2 48 81	ldx #$8148	                LDX #<>mregisters_msg
.018095	22 64 05 01	jsl $010564	                JSL IPRINT
.018099	e2 20		sep #$20	                SEP #$20        ; set A short
.01809b	a9 3b		lda #$3b	                LDA #';'
.01809d	22 84 05 01	jsl $010584	                JSL IPUTC
.0180a1	c2 30		rep #$30	                REP #$30        ; set A&X long
.0180a3	48		pha		                PHA             ; begin setdbr macro
.0180a4	08		php		                PHP
.0180a5	e2 20		sep #$20	                SEP #$20        ; set A short
.0180a7	a9 00		lda #$00		LDA #$0
.0180a9	48		pha		                PHA
.0180aa	ab		plb		                PLB
.0180ab	28		plp		                PLP
.0180ac	68		pla		                PLA             ; end setdbr macro
.0180ad	a0 03 00	ldy #$0003	                LDY #3
.0180b0	a2 02 02	ldx #$0202	                LDX #CPUPC+2
.0180b3	22 46 06 01	jsl $010646	                JSL IPRINTH
.0180b7	a5 20		lda $20		                LDA ' '
.0180b9	22 84 05 01	jsl $010584	                JSL IPUTC
.0180bd	a0 02 00	ldy #$0002	                LDY #2
.0180c0	a2 05 02	ldx #$0205	                LDX #CPUA+1
.0180c3	22 46 06 01	jsl $010646	                JSL IPRINTH
.0180c7	a5 20		lda $20		                LDA ' '
.0180c9	22 84 05 01	jsl $010584	                JSL IPUTC
.0180cd	a0 02 00	ldy #$0002	                LDY #2
.0180d0	a2 07 02	ldx #$0207	                LDX #CPUX+1
.0180d3	22 46 06 01	jsl $010646	                JSL IPRINTH
.0180d7	a5 20		lda $20		                LDA ' '
.0180d9	22 84 05 01	jsl $010584	                JSL IPUTC
.0180dd	a0 02 00	ldy #$0002	                LDY #2
.0180e0	a2 09 02	ldx #$0209	                LDX #CPUY+1
.0180e3	22 46 06 01	jsl $010646	                JSL IPRINTH
.0180e7	a5 20		lda $20		                LDA ' '
.0180e9	22 84 05 01	jsl $010584	                JSL IPUTC
.0180ed	a0 02 00	ldy #$0002	                LDY #2
.0180f0	a2 0b 02	ldx #$020b	                LDX #CPUSTACK+1
.0180f3	22 46 06 01	jsl $010646	                JSL IPRINTH
.0180f7	a5 20		lda $20		                LDA ' '
.0180f9	22 84 05 01	jsl $010584	                JSL IPUTC
.0180fd	a0 01 00	ldy #$0001	                LDY #1
.018100	a2 0e 02	ldx #$020e	                LDX #CPUDBR
.018103	22 46 06 01	jsl $010646	                JSL IPRINTH
.018107	a5 20		lda $20		                LDA ' '
.018109	22 84 05 01	jsl $010584	                JSL IPUTC
.01810d	22 84 05 01	jsl $010584	                JSL IPUTC
.018111	a0 02 00	ldy #$0002	                LDY #2
.018114	a2 0d 02	ldx #$020d	                LDX #CPUDP+1
.018117	22 46 06 01	jsl $010646	                JSL IPRINTH
.01811b	a5 20		lda $20		                LDA ' '
.01811d	22 84 05 01	jsl $010584	                JSL IPUTC
.018121	a0 01 00	ldy #$0001	                LDY #1
.018124	a2 0f 02	ldx #$020f	                LDX #CPUFLAGS
.018127	22 46 06 01	jsl $010646	                JSL IPRINTH
.01812b	22 b2 05 01	jsl $0105b2	                JSL IPRINTCR
.01812f	5c 22 05 01	jmp $010522	                JML IREADYWAIT
.018133	6b		rtl		IMRETURN        RTL ; Handle RETURN key (ie: execute command)
.018134	00		brk #		IMPARSE         BRK ; Parse the current command line
.018135	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.018136	00		brk #		IMEXECUTE       BRK ; Execute the current command line (requires MCMD and MARG1-MARG8 to be populated)
.018137	00		brk #		IMASSEMBLE      BRK ; Assemble a line of text.
.018138	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.018139	00		brk #		IMCOMPARE       BRK ; Compare memory. len=1
.01813a	00		brk #		IMDISASSEMBLE   BRK ; Disassemble memory. end=1 instruction
.01813b	00		brk #		IMFILL          BRK ; Fill memory with specified value. Start and end must be in the same bank.
.01813c	00		brk #		IMGO            BRK ; Execute from specified address
.01813d	00		brk #		IMJUMP          BRK ; Execute from spefified address
.01813e	00		brk #		IMHUNT          BRK ; Hunt (find) value in memory
.01813f	00		brk #		IMLOAD          BRK ; Load data from disk. Device=1 (internal floppy) Start=Address in file
.018140	00		brk #		IMMEMORY        BRK ; View memory
.018141	00		brk #		IMREGISTERS     BRK ; View/edit registers
.018142	00		brk #		IMSAVE          BRK ; Save memory to disk
.018143	00		brk #		IMTRANSFER      BRK ; Transfer (copy) data in memory
.018144	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.018145	00		brk #		IMEXIT          BRK ; Exit monitor and return to BASIC command prompt
.018146	00		brk #		IMMODIFY        BRK ; Modify memory
.018147	00		brk #		IMDOS           BRK ; Execute DOS command
.018148					MMESSAGES
>018148					MMERROR         .text
>018148	0d 20 50 43 20 20 20 20		mregisters_msg  .null $0D," PC     A    X    Y    SP   DBR DP   NVMXDIZC"
>018150	20 41 20 20 20 20 58 20 20 20 20 59 20 20 20 20
>018160	53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e 56
>018170	4d 58 44 49 5a 43 00

;******  Return to file: kernel.asm


;******  Processing file: kernel_jumptable.asm

.010000	5c 00 04 01	jmp $010400	BOOT            JML IBOOT
.010004	5c d8 09 01	jmp $0109d8	RESTORE         JML IRESTORE
.010008	5c c8 04 01	jmp $0104c8	BREAK           JML IBREAK
.01000c	5c 0f 05 01	jmp $01050f	READY           JML IREADY
.010010	5c d9 09 01	jmp $0109d9	SCINIT          JML ISCINIT
.010014	5c da 09 01	jmp $0109da	IOINIT          JML IIOINIT
.010018	5c 84 05 01	jmp $010584	PUTC            JML IPUTC
.01001c	5c 6d 05 01	jmp $01056d	PUTS            JML IPUTS
.010020	5c b1 05 01	jmp $0105b1	PUTB            JML IPUTB
.010024	5c db 09 01	jmp $0109db	PUTBLOCK        JML IPUTBLOCK
.010028	5c dc 09 01	jmp $0109dc	SETLFS          JML ISETLFS
.01002c	5c dd 09 01	jmp $0109dd	SETNAM          JML ISETNAM
.010030	5c de 09 01	jmp $0109de	OPEN            JML IOPEN
.010034	5c df 09 01	jmp $0109df	CLOSE           JML ICLOSE
.010038	5c e0 09 01	jmp $0109e0	SETIN           JML ISETIN
.01003c	5c e1 09 01	jmp $0109e1	SETOUT          JML ISETOUT
.010040	5c e2 09 01	jmp $0109e2	GETB            JML IGETB
.010044	5c e3 09 01	jmp $0109e3	GETBLOCK        JML IGETBLOCK
.010048	5c e4 09 01	jmp $0109e4	GETCH           JML IGETCH
.01004c	5c 33 05 01	jmp $010533	GETCHW          JML IGETCHW
.010050	5c 2a 05 01	jmp $01052a	GETCHE          JML IGETCHE
.010054	5c e5 09 01	jmp $0109e5	GETS            JML IGETS
.010058	5c e6 09 01	jmp $0109e6	GETLINE         JML IGETLINE
.01005c	5c e7 09 01	jmp $0109e7	GETFIELD        JML IGETFIELD
.010060	5c e8 09 01	jmp $0109e8	TRIM            JML ITRIM
.010064	5c e9 09 01	jmp $0109e9	PRINTC          JML IPRINTC
.010068	5c ea 09 01	jmp $0109ea	PRINTS          JML IPRINTS
.01006c	5c b2 05 01	jmp $0105b2	PRINTCR         JML IPRINTCR
.010070	5c eb 09 01	jmp $0109eb	PRINTF          JML IPRINTF
.010074	5c ec 09 01	jmp $0109ec	PRINTI          JML IPRINTI
.010078	5c 46 06 01	jmp $010646	PRINTH          JML IPRINTH
.01007c	5c ed 09 01	jmp $0109ed	PRINTAI         JML IPRINTAI
.010080	5c ee 09 01	jmp $0109ee	PRINTAH         JML IPRINTAH
.010084	5c 00 06 01	jmp $010600	LOCATE          JML ILOCATE
.010088	5c ef 09 01	jmp $0109ef	PUSHKEY         JML IPUSHKEY
.01008c	5c f0 09 01	jmp $0109f0	PUSHKEYS        JML IPUSHKEYS
.010090	5c d3 05 01	jmp $0105d3	CSRRIGHT        JML ICSRRIGHT
.010094	5c f1 09 01	jmp $0109f1	CSRLEFT         JML ICSRLEFT
.010098	5c fe 05 01	jmp $0105fe	CSRUP           JML ICSRUP
.01009c	5c ff 05 01	jmp $0105ff	CSRDOWN         JML ICSRDOWN
.0100a0	5c f2 09 01	jmp $0109f2	CSRHOME         JML ICSRHOME
.0100a4	5c 2c 06 01	jmp $01062c	SCROLLUP        JML ISCROLLUP
.0100a8	5c 74 06 01	jmp $010674	CLRSCREEN       JML ICLRSCREEN
.0100ac	5c db 06 01	jmp $0106db	INITCHLUT	      JML IINITCHLUT
.0100b0	5c 0a 07 01	jmp $01070a	INITSUPERIO	    JML IINITSUPERIO
.0100b4	5c 07 08 01	jmp $010807	INITKEYBOARD    JML IINITKEYBOARD
.0100b8	5c 68 08 01	jmp $010868	INITVIAS        JML IINITVIAS
.0100bc	5c 97 08 01	jmp $010897	INITRTC         JML IINITRTC
.0100c0	5c ce 08 01	jmp $0108ce	TESTSID         JML ITESTSID
.0100c4	5c b1 09 01	jmp $0109b1	TESTMATH        JML ITESTMATH

;******  Return to file: kernel.asm

.010400					IBOOT
.010400	18		clc		                CLC           ; clear the carry flag
.010401	fb		xce		                XCE           ; move carry to emulation flag.
.010402	c2 30		rep #$30	                REP #$30        ; set A&X long
.010404	a9 ff fe	lda #$feff	                LDA #STACK_END   ; initialize stack pointer
.010407	1b		tcs		                TAS
.010408	48		pha		                PHA             ; begin setdp macro
.010409	08		php			PHP
.01040a	c2 20		rep #$20	                REP #$20        ; set A long
.01040c	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.01040f	5b		tcd		                TCD
.010410	28		plp			PLP
.010411	68		pla		                PLA             ; end setdp macro
.010412	a9 00 00	lda #$0000	                LDA #<>SCREEN_PAGE0      ; store the initial screen buffer location
.010415	85 0c		sta $0c		                STA SCREENBEGIN
.010417	e2 20		sep #$20	                SEP #$20        ; set A short
.010419	a9 80		lda #$80	                LDA #`SCREEN_PAGE0
.01041b	85 0e		sta $0e		                STA SCREENBEGIN+2
.01041d	c2 30		rep #$30	                REP #$30        ; set A&X long
.01041f	a9 00 00	lda #$0000	                LDA #<>SCREEN_PAGE0      ; store the initial screen buffer location
.010422	85 17		sta $17		                STA CURSORPOS
.010424	e2 20		sep #$20	                SEP #$20        ; set A short
.010426	a9 80		lda #$80	                LDA #`SCREEN_PAGE0
.010428	85 19		sta $19		                STA CURSORPOS+2
.01042a	c2 30		rep #$30	                REP #$30        ; set A&X long
.01042c	a2 50 00	ldx #$0050	                LDX #80
.01042f	86 0f		stx $0f		                STX COLS_VISIBLE
.010431	a0 3c 00	ldy #$003c	                LDY #60
.010434	84 13		sty $13		                STY LINES_VISIBLE
.010436	a2 80 00	ldx #$0080	                LDX #128
.010439	86 11		stx $11		                STX COLS_PER_LINE
.01043b	a0 40 00	ldy #$0040	                LDY #64
.01043e	84 15		sty $15		                STY LINES_MAX
.010440	22 db 06 01	jsl $0106db	                JSL IINITCHLUT
.010444	22 74 06 01	jsl $010674	                JSL ICLRSCREEN
.010448					greet
.010448	48		pha		                PHA             ; begin setdbr macro
.010449	08		php		                PHP
.01044a	e2 20		sep #$20	                SEP #$20        ; set A short
.01044c	a9 01		lda #$01		LDA #`greet_msg
.01044e	48		pha		                PHA
.01044f	ab		plb		                PLB
.010450	28		plp		                PLP
.010451	68		pla		                PLA             ; end setdbr macro
.010452	a2 f5 09	ldx #$09f5	                LDX #<>greet_msg
.010455	22 64 05 01	jsl $010564	                JSL IPRINT       ; print the first line
.010459	a2 98 0b	ldx #$0b98	                LDX #<>version_msg
.01045c	22 64 05 01	jsl $010564	                JSL IPRINT       ; print the first line
.010460	22 0a 07 01	jsl $01070a	                JSL IINITSUPERIO
.010464	a2 c2 0b	ldx #$0bc2	                LDX #<>init_lpc_msg
.010467	22 64 05 01	jsl $010564	                JSL IPRINT       ; print the Init
.01046b	22 68 08 01	jsl $010868	                JSL IINITVIAS
.01046f	a2 e5 0b	ldx #$0be5	                LDX #<>init_via_msg
.010472	22 64 05 01	jsl $010564	                JSL IPRINT       ; print the VIAs Init Message
.010476	22 97 08 01	jsl $010897	                JSL IINITRTC
.01047a	a2 f3 0b	ldx #$0bf3	                LDX #<>init_rtc_msg
.01047d	22 64 05 01	jsl $010564	                JSL IPRINT       ; print the RTC Init Message
.010481	22 ce 08 01	jsl $0108ce	                JSL ITESTSID
.010485	a2 00 0c	ldx #$0c00	                LDX #<>test_SID_msg
.010488	22 64 05 01	jsl $010564	                JSL IPRINT       ; print the SID Test Message
.01048c	48		pha		                PHA             ; begin setdp macro
.01048d	08		php			PHP
.01048e	c2 20		rep #$20	                REP #$20        ; set A long
.010490	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.010493	5b		tcd		                TCD
.010494	28		plp			PLP
.010495	68		pla		                PLA             ; end setdp macro
.010496	22 b1 09 01	jsl $0109b1	                JSL ITESTMATH
.01049a	22 07 08 01	jsl $010807	                JSL IINITKEYBOARD
.01049e	a2 d3 0b	ldx #$0bd3	                LDX #<>init_kbrd_msg
.0104a1	22 64 05 01	jsl $010564	                JSL IPRINT       ; print the Keybaord Init Message
.0104a5	48		pha		                PHA             ; begin setdp macro
.0104a6	08		php			PHP
.0104a7	c2 20		rep #$20	                REP #$20        ; set A long
.0104a9	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.0104ac	5b		tcd		                TCD
.0104ad	28		plp			PLP
.0104ae	68		pla		                PLA             ; end setdp macro
.0104af	c2 20		rep #$20	                REP #$20        ; set A long
.0104b1	a2 00 00	ldx #$0000	                LDX #$0
.0104b4	a0 00 00	ldy #$0000	                LDY #$0
.0104b7	22 00 06 01	jsl $010600	                JSL ILOCATE
.0104bb	e2 20		sep #$20	                SEP #$20        ; set A short
.0104bd	48		pha		                PHA             ; begin setdbr macro
.0104be	08		php		                PHP
.0104bf	e2 20		sep #$20	                SEP #$20        ; set A short
.0104c1	a9 01		lda #$01		LDA #$01
.0104c3	48		pha		                PHA
.0104c4	ab		plb		                PLB
.0104c5	28		plp		                PLP
.0104c6	68		pla		                PLA             ; end setdbr macro
.0104c7	00		brk #		greet_done      BRK             ;Terminate boot routine and go to Ready handler.
.0104c8					IBREAK
.0104c8	48		pha		                PHA             ; begin setdp macro
.0104c9	08		php			PHP
.0104ca	c2 20		rep #$20	                REP #$20        ; set A long
.0104cc	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.0104cf	5b		tcd		                TCD
.0104d0	28		plp			PLP
.0104d1	68		pla		                PLA             ; end setdp macro
.0104d2	68		pla		                PLA             ; Pull .Y and stuff it in the CPUY variable
.0104d3	8f 08 02 00	sta $000208	                STA CPUY
.0104d7	68		pla		                PLA             ; Pull .X and stuff it in the CPUY variable
.0104d8	8f 06 02 00	sta $000206	                STA CPUX
.0104dc	68		pla		                PLA             ; Pull .A and stuff it in the CPUY variable
.0104dd	8f 04 02 00	sta $000204	                STA CPUA
.0104e1	68		pla		                PLA
.0104e2	8f 0c 02 00	sta $00020c	                STA CPUDP       ; Pull Direct page
.0104e6	e2 20		sep #$20	                SEP #$20        ; set A short
.0104e8	68		pla		                PLA             ; Pull Data Bank (8 bits)
.0104e9	8f 0e 02 00	sta $00020e	                STA CPUDBR
.0104ed	68		pla		                PLA             ; Pull Flags (8 bits)
.0104ee	8f 0f 02 00	sta $00020f	                STA CPUFLAGS
.0104f2	c2 20		rep #$20	                REP #$20        ; set A long
.0104f4	68		pla		                PLA             ; Pull Program Counter (16 bits)
.0104f5	8f 00 02 00	sta $000200	                STA CPUPC
.0104f9	e2 20		sep #$20	                SEP #$20        ; set A short
.0104fb	68		pla		                PLA             ; Pull Program Bank (8 bits)
.0104fc	8f 02 02 00	sta $000202	                STA CPUPBR
.010500	c2 20		rep #$20	                REP #$20        ; set A long
.010502	3b		tsc		                TSA             ; Get the stack
.010503	8f 0a 02 00	sta $00020a	                STA CPUSTACK    ; Store the stack at immediately before the interrupt was asserted
.010507	a9 ff fe	lda #$feff	                LDA #<>STACK_END   ; initialize stack pointer back to the bootup value
.01050a	1b		tcs		                TAS
.01050b	5c e0 ff 00	jmp $00ffe0	                JML JMP_READY   ; Run READY routine (usually BASIC or MONITOR)
.01050f					IREADY
.01050f	48		pha		                PHA             ; begin setdbr macro
.010510	08		php		                PHP
.010511	e2 20		sep #$20	                SEP #$20        ; set A short
.010513	a9 01		lda #$01		LDA #`ready_msg
.010515	48		pha		                PHA
.010516	ab		plb		                PLB
.010517	28		plp		                PLP
.010518	68		pla		                PLA             ; end setdbr macro
.010519	e2 20		sep #$20	                SEP #$20        ; set A short
.01051b	a2 1a 0c	ldx #$0c1a	                LDX #<>ready_msg
.01051e	22 64 05 01	jsl $010564	                JSL IPRINT
.010522					IREADYWAIT
.010522	22 2a 05 01	jsl $01052a	                JSL IGETCHE
.010526	80 fa		bra $010522	                BRA IREADYWAIT
.010528	db		stp		IKEYDOWN        STP             ; Keyboard key pressed
.010529	db		stp		IRETURN         STP
.01052a	22 33 05 01	jsl $010533	IGETCHE         JSL IGETCHW
.01052e	22 84 05 01	jsl $010584	                JSL IPUTC
.010532	6b		rtl		                RTL
.010533	0b		phd		IGETCHW         PHD
.010534	da		phx		                PHX
.010535	08		php		                PHP
.010536	48		pha		                PHA             ; begin setdp macro
.010537	08		php			PHP
.010538	c2 20		rep #$20	                REP #$20        ; set A long
.01053a	a9 00 0f	lda #$0f00	                LDA #$0F00         ; set DP to page 0
.01053d	5b		tcd		                TCD
.01053e	28		plp			PLP
.01053f	68		pla		                PLA             ; end setdp macro
.010540	c2 30		rep #$30	                REP #$30        ; set A&X long
.010542	a6 40		ldx $0f40	igetchw1        LDX KEY_BUFFER_RPOS
.010544	e4 42		cpx $0f42	                CPX KEY_BUFFER_WPOS
.010546	d0 05		bne $01054d	                BNE igetchw2
>010548	42 00				                .byte $42, $00
.01054a	4c 42 05	jmp $010542	                JMP igetchw1
.01054d	b5 00		lda $0f00,x	igetchw2        LDA $0,D,X  ; Read the value in the keyboard buffer
.01054f	48		pha		                PHA
.010550	8a		txa		                TXA
.010551	18		clc		                CLC
.010552	69 02 00	adc #$0002	                ADC #$02
.010555	c9 40 00	cmp #$0040	                CMP #KEY_BUFFER_SIZE
.010558	90 03		bcc $01055d	                BCC igetchw3
.01055a	a9 00 00	lda #$0000	                LDA #$0
.01055d	85 40		sta $0f40	igetchw3        STA KEY_BUFFER_RPOS
.01055f	68		pla		                PLA
.010560	28		plp		igetchw_done    PLP
.010561	fa		plx		                PLX             ; Restore the saved registers and return
.010562	2b		pld		                PLD
.010563	6b		rtl		                RTL
.010564	22 6d 05 01	jsl $01056d	IPRINT          JSL IPUTS
.010568	22 b2 05 01	jsl $0105b2	                JSL IPRINTCR
.01056c	6b		rtl		                RTL
.01056d	48		pha		IPUTS           PHA
.01056e	08		php		                PHP
.01056f	e2 20		sep #$20	                SEP #$20        ; set A short
.010571	c2 10		rep #$10	                REP #$10        ; set X long
.010573	bd 00 00	lda $010000,x	iputs1          LDA $0,b,x      ; read from the string
.010576	f0 08		beq $010580	                BEQ iputs_done
.010578	22 84 05 01	jsl $010584	iputs2          JSL IPUTC
.01057c	e8		inx		iputs3          INX
.01057d	4c 73 05	jmp $010573	                JMP iputs1
.010580	e8		inx		iputs_done      INX
.010581	28		plp		                PLP
.010582	68		pla		                PLA
.010583	6b		rtl		                RTL
.010584	0b		phd		IPUTC           PHD
.010585	08		php		                PHP             ; stash the flags (we'll be changing M)
.010586	48		pha		                PHA             ; begin setdp macro
.010587	08		php			PHP
.010588	c2 20		rep #$20	                REP #$20        ; set A long
.01058a	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.01058d	5b		tcd		                TCD
.01058e	28		plp			PLP
.01058f	68		pla		                PLA             ; end setdp macro
.010590	e2 20		sep #$20	                SEP #$20        ; set A short
.010592	c9 0d		cmp #$0d	                CMP #$0D        ; handle CR
.010594	d0 06		bne $01059c	                BNE iputc_bs
.010596	22 b2 05 01	jsl $0105b2	                JSL IPRINTCR
.01059a	80 10		bra $0105ac	                bra iputc_done
.01059c	c9 08		cmp #$08	iputc_bs        CMP #$08        ; backspace
.01059e	d0 06		bne $0105a6	                BNE iputc_print
.0105a0	22 c3 05 01	jsl $0105c3	                JSL IPRINTBS
.0105a4	80 06		bra $0105ac	                BRA iputc_done
.0105a6	87 17		sta [$17]	iputc_print     STA [CURSORPOS] ; Save the character on the screen
.0105a8	22 d3 05 01	jsl $0105d3	                JSL ICSRRIGHT
.0105ac					iputc_done
>0105ac	42 01				                .byte $42, $01
.0105ae	28		plp		                PLP
.0105af	2b		pld		                PLD
.0105b0	6b		rtl		                RTL
.0105b1					IPUTB
.0105b1	6b		rtl		                RTL
.0105b2	da		phx		IPRINTCR	PHX
.0105b3	5a		phy		                PHY
.0105b4	08		php		                PHP
.0105b5	a2 00 00	ldx #$0000	                LDX #0
.0105b8	a4 1c		ldy $1c		                LDY CURSORY
.0105ba	c8		iny		                INY
.0105bb	22 00 06 01	jsl $010600	                JSL ILOCATE
.0105bf	28		plp		                PLP
.0105c0	7a		ply		                PLY
.0105c1	fa		plx		                PLX
.0105c2	6b		rtl		                RTL
.0105c3	da		phx		IPRINTBS	PHX
.0105c4	5a		phy		                PHY
.0105c5	08		php		                PHP
.0105c6	a6 1a		ldx $1a		                LDX CURSORX
.0105c8	a4 1c		ldy $1c		                LDY CURSORY
.0105ca	ca		dex		                DEX
.0105cb	22 00 06 01	jsl $010600	                JSL ILOCATE
.0105cf	28		plp		                PLP
.0105d0	7a		ply		                PLY
.0105d1	fa		plx		                PLX
.0105d2	6b		rtl		                RTL
.0105d3					ICSRRIGHT
.0105d3	da		phx		                PHX
.0105d4	8b		phb		                PHB
.0105d5	c2 20		rep #$20	                REP #$20        ; set A long
.0105d7	c2 10		rep #$10	                REP #$10        ; set X long
.0105d9	48		pha		                PHA             ; begin setdp macro
.0105da	08		php			PHP
.0105db	c2 20		rep #$20	                REP #$20        ; set A long
.0105dd	a9 00 00	lda #$0000	                LDA #$0         ; set DP to page 0
.0105e0	5b		tcd		                TCD
.0105e1	28		plp			PLP
.0105e2	68		pla		                PLA             ; end setdp macro
.0105e3	e6 17		inc $17		                INC CURSORPOS
.0105e5	a6 1a		ldx $1a		                LDX CURSORX
.0105e7	e8		inx		                INX
.0105e8	e4 0f		cpx $0f		                CPX COLS_VISIBLE
.0105ea	90 0c		bcc $0105f8	                BCC icsr_nowrap  ; wrap if the cursor is at or past column 80
.0105ec	a2 00 00	ldx #$0000	                LDX #0
.0105ef	5a		phy		                PHY
.0105f0	a4 1c		ldy $1c		                LDY CURSORY
.0105f2	c8		iny		                INY
.0105f3	22 00 06 01	jsl $010600	                JSL ILOCATE
.0105f7	7a		ply		                PLY
.0105f8	86 1a		stx $1a		icsr_nowrap     STX CURSORX
.0105fa	ab		plb		                PLB
.0105fb	fa		plx		                PLX
.0105fc	6b		rtl		                RTL
.0105fd	6b		rtl		ISRLEFT	RTL
.0105fe	6b		rtl		ICSRUP	RTL
.0105ff	6b		rtl		ICSRDOWN	RTL
.010600	48		pha		ILOCATE         PHA
.010601	08		php		                PHP
.010602	c2 30		rep #$30	                REP #$30        ; set A&X long
.010604					ilocate_scroll
.010604	c4 13		cpy $13		                CPY LINES_VISIBLE
.010606	90 07		bcc $01060f	                BCC ilocate_scrolldone
.010608	22 2c 06 01	jsl $01062c	                JSL ISCROLLUP
.01060c	88		dey		                DEY
.01060d	80 f5		bra $010604	                BRA ilocate_scroll
.01060f					ilocate_scrolldone
.01060f	86 1a		stx $1a		                STX CURSORX
.010611	84 1c		sty $1c		                STY CURSORY
.010613	a5 0c		lda $0c		                LDA SCREENBEGIN
.010615					ilocate_row
.010615	c0 00 00	cpy #$0000	                CPY #$0
.010618	f0 08		beq $010622	                BEQ ilocate_right
.01061a	18		clc		ilocate_down    CLC
.01061b	65 11		adc $11		                ADC COLS_PER_LINE
.01061d	88		dey		                DEY
.01061e	f0 02		beq $010622	                BEQ ilocate_right
.010620	80 f8		bra $01061a	                BRA ilocate_down
.010622	18		clc		ilocate_right   CLC
.010623	65 1a		adc $1a		                ADC CURSORX             ; move the cursor right X columns
.010625	85 17		sta $17		                STA CURSORPOS
.010627	a4 1c		ldy $1c		                LDY CURSORY
.010629	28		plp		ilocate_done    PLP
.01062a	68		pla		                PLA
.01062b	6b		rtl		                RTL
.01062c					ISCROLLUP
.01062c	48		pha		                PHA
.01062d	da		phx		                PHX
.01062e	5a		phy		                PHY
.01062f	8b		phb		                PHB
.010630	08		php		                PHP
.010631	c2 30		rep #$30	                REP #$30        ; set A&X long
.010633	18		clc		                CLC
.010634	a5 0c		lda $0c		                LDA SCREENBEGIN
.010636	a8		tay		                TAY             ; Destination is first row
.010637	65 11		adc $11		                ADC COLS_PER_LINE
.010639	aa		tax		                TAX             ; Source is second row
.01063a	a9 ef 1f	lda #$1fef	                LDA #SCREEN_PAGE1-SCREEN_PAGE0-COLS_PER_LINE
.01063d	44 00 00	mvp $00,$00	                MVP $00,$00
.010640	28		plp		                PLP
.010641	ab		plb		                PLB
.010642	7a		ply		                PLY
.010643	fa		plx		                PLX
.010644	68		pla		                PLA
.010645	6b		rtl		                RTL
.010646	08		php		IPRINTH         PHP
.010647	48		pha		                PHA
.010648					iprinth1
.010648	e2 20		sep #$20	                SEP #$20        ; set A short
.01064a	bd 00 00	lda $010000,x	                LDA #0,b,x      ; Read the value to be printed
.01064d	4a		lsr a		                LSR
.01064e	4a		lsr a		                LSR
.01064f	4a		lsr a		                LSR
.010650	4a		lsr a		                LSR
.010651	22 63 06 01	jsl $010663	                JSL iprint_digit
.010655	bd 00 00	lda $010000,x	                LDA #0,b,x
.010658	22 63 06 01	jsl $010663	                JSL iprint_digit
.01065c	ca		dex		                DEX
.01065d	88		dey		                DEY
.01065e	d0 e8		bne $010648	                BNE iprinth1
.010660	68		pla		                PLA
.010661	28		plp		                PLP
.010662	6b		rtl		                RTL
.010663	da		phx		iprint_digit    PHX
.010664	c2 20		rep #$20	                REP #$20        ; set A long
.010666	29 0f 00	and #$000f	                AND #$0F
.010669	aa		tax		                TAX
.01066a	bf d6 0c 01	lda $010cd6,x	                LDA hex_digits,X
.01066e	22 84 05 01	jsl $010584	                JSL IPUTC       ; Print the digit
.010672	fa		plx		                PLX
.010673	6b		rtl		                RTL
.010674	0b		phd		ICLRSCREEN	    PHD
.010675	08		php		                PHP
.010676	48		pha		                PHA
.010677	da		phx		                PHX
.010678	e2 20		sep #$20	                SEP #$20        ; set A short
.01067a	c2 10		rep #$10	                REP #$10        ; set X long
.01067c	a2 00 00	ldx #$0000	                LDX #$0000		; Only Use One Pointer
.01067f	a9 20		lda #$20	                LDA #$20		; Fill the Entire Screen with Space
.010681	9f 00 00 80	sta $800000,x	iclearloop0	    STA $800000,x	;
.010685	e8		inx		                inx
.010686	e0 00 20	cpx #$2000	                cpx #$2000
.010689	d0 f6		bne $010681	                bne iclearloop0
.01068b	a2 00 00	ldx #$0000	                LDX	#$0000		; Only Use One Pointer
.01068e	a9 ed		lda #$ed	                LDA #$ED		; Fill the Color Memory with Foreground: 75% Purple, Background 12.5% White
.010690	9f 00 20 80	sta $802000,x	iclearloop1	    STA $802000,x	;
.010694	e8		inx		                inx
.010695	e0 00 20	cpx #$2000	                cpx #$2000
.010698	d0 f6		bne $010690	                bne iclearloop1
.01069a	c2 10		rep #$10	                REP #$10        ; set X long
.01069c	c2 20		rep #$20	                REP #$20        ; set A long
.01069e	fa		plx		                PLX
.01069f	68		pla		                PLA
.0106a0	28		plp		                PLP
.0106a1	2b		pld		                PLD
.0106a2	6b		rtl		                RTL
.0106a3	48		pha		ICOLORFLAG      PHA
.0106a4	da		phx		                PHX
.0106a5	08		php		                PHP
.0106a6	e2 30		sep #$30	                SEP #$30        ; set A&X short
.0106a8	a2 00		ldx #$00	                LDX #$00
.0106aa	bf d2 0a 01	lda $010ad2,x	iclearloop2	    LDA @lgreet_clr_line1,x
.0106ae	9f 00 20 80	sta $802000,x	                STA $802000,x
.0106b2	bf e0 0a 01	lda $010ae0,x	                LDA @lgreet_clr_line2,x
.0106b6	9f 80 20 80	sta $802080,x	                STA $802080,x
.0106ba	bf ee 0a 01	lda $010aee,x	                LDA @lgreet_clr_line3,x
.0106be	9f 00 21 80	sta $802100,x	                STA $802100,x
.0106c2	bf fc 0a 01	lda $010afc,x	                LDA @lgreet_clr_line4,x
.0106c6	9f 80 21 80	sta $802180,x	                STA $802180,x
.0106ca	bf 0a 0b 01	lda $010b0a,x	                LDA @lgreet_clr_line5,x
.0106ce	9f 00 22 80	sta $802200,x	                STA $802200,x
.0106d2	e8		inx		                inx
.0106d3	e0 0e		cpx #$0e	                cpx #$0E
.0106d5	d0 d3		bne $0106aa	                bne iclearloop2
.0106d7	28		plp		                PLP
.0106d8	fa		plx		                PLX
.0106d9	68		pla		                PLA
.0106da	6b		rtl		                RTL
.0106db	0b		phd		IINITCHLUT		  PHD
.0106dc	08		php		                PHP
.0106dd	48		pha		                PHA
.0106de	da		phx		                PHX
.0106df	e2 20		sep #$20	                SEP #$20        ; set A short
.0106e1	e2 10		sep #$10	                SEP #$10        ; set X short
.0106e3	a2 00		ldx #$00					        LDX	#$00
.0106e5	bf 18 0b 01	lda $010b18,x	lutinitloop0	  LDA @lfg_color_lut,x		; get Local Data
.0106e9	9f 40 1f 7f	sta $7f1f40,x	                STA FG_CHAR_LUT_PTR,x	; Write in LUT Memory
.0106ed	e8		inx		                inx
.0106ee	e0 40		cpx #$40	                cpx #$40
.0106f0	d0 f3		bne $0106e5	                bne lutinitloop0
.0106f2	a2 00		ldx #$00	                LDX	#$00
.0106f4	bf 58 0b 01	lda $010b58,x	lutinitloop1	  LDA @lbg_color_lut,x		; get Local Data
.0106f8	9f 80 1f 7f	sta $7f1f80,x	                STA BG_CHAR_LUT_PTR,x	; Write in LUT Memory
.0106fc	e8		inx		                inx
.0106fd	e0 40		cpx #$40	                cpx #$40
.0106ff	d0 f3		bne $0106f4	                bne lutinitloop1
.010701	c2 20		rep #$20	                REP #$20        ; set A long
.010703	c2 10		rep #$10	                REP #$10        ; set X long
.010705	fa		plx		                PLX
.010706	68		pla		                PLA
.010707	28		plp		                PLP
.010708	2b		pld		                PLD
.010709	6b		rtl		                RTL
.01070a	0b		phd		IINITSUPERIO	  PHD
.01070b	08		php		                PHP
.01070c	48		pha		                PHA
.01070d	e2 20		sep #$20	                SEP #$20        ; set A short
.01070f	a9 01		lda #$01	                LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.010711	8f 23 11 7f	sta $7f1123	                STA GP10_REG
.010715	a9 01		lda #$01	                LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.010717	8f 24 11 7f	sta $7f1124	                STA GP11_REG
.01071b	a9 01		lda #$01	                LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.01071d	a9 01		lda #$01	        				LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.01071f	8f 26 11 7f	sta $7f1126	        				STA GP13_REG
.010723	a9 05		lda #$05	        				LDA #$05		;(C256 - POT A Analog BX) Bit[0] = 1, Bit[2] = 1
.010725	8f 27 11 7f	sta $7f1127	        				STA GP14_REG
.010729	a9 05		lda #$05	        				LDA #$05		;(C256 - POT A Analog BY) Bit[0] = 1, Bit[2] = 1
.01072b	8f 28 11 7f	sta $7f1128	        				STA GP15_REG
.01072f	a9 05		lda #$05	        				LDA #$05		;(C256 - POT B Analog BX) Bit[0] = 1, Bit[2] = 1
.010731	8f 29 11 7f	sta $7f1129	        				STA GP16_REG
.010735	a9 05		lda #$05	        				LDA #$05		;(C256 - POT B Analog BY) Bit[0] = 1, Bit[2] = 1
.010737	8f 2a 11 7f	sta $7f112a	        				STA GP17_REG
.01073b	a9 00		lda #$00	        				LDA #$00		;(C256 - HEADPHONE MUTE) - Output GPIO - Push-Pull (1 - Headphone On, 0 - HeadPhone Off)
.01073d	8f 2b 11 7f	sta $7f112b	        				STA GP20_REG
.010741	a9 01		lda #$01					        LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.010743	8f 2f 11 7f	sta $7f112f					        STA GP24_REG
.010747	a9 05		lda #$05					        LDA #$05		;(C256 - MIDI IN) Bit[0] = 1, Bit[2] = 1 (Page 132 Manual)
.010749	8f 30 11 7f	sta $7f1130					        STA GP25_REG
.01074d	a9 84		lda #$84				        	LDA #$84		;(C256 - MIDI OUT) Bit[2] = 1, Bit[7] = 1 (Open Drain - To be Checked)
.01074f	8f 31 11 7f	sta $7f1131					        STA GP26_REG
.010753	a9 01		lda #$01	        				LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.010755	8f 2f 11 7f	sta $7f112f					        STA GP24_REG
.010759	a9 01		lda #$01					        LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 1) Setup as GPIO Input for now
.01075b	8f 33 11 7f	sta $7f1133					        STA GP30_REG
.01075f	a9 01		lda #$01					        LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 4) Setup as GPIO Input for now
.010761	8f 34 11 7f	sta $7f1134					        STA GP31_REG
.010765	a9 01		lda #$01					        LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 3) Setup as GPIO Input for now
.010767	8f 35 11 7f	sta $7f1135					        STA GP32_REG
.01076b	a9 01		lda #$01					        LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 6) Setup as GPIO Input for now
.01076d	8f 36 11 7f	sta $7f1136					        STA GP33_REG
.010771	a9 01		lda #$01					        LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 5) Setup as GPIO Input for now
.010773	8f 37 11 7f	sta $7f1137					        STA GP34_REG
.010777	a9 01		lda #$01					        LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 8) Setup as GPIO Input for now
.010779	8f 38 11 7f	sta $7f1138					        STA GP35_REG
.01077d	a9 01		lda #$01					        LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 7) Setup as GPIO Input for now
.01077f	8f 39 11 7f	sta $7f1139					        STA GP36_REG
.010783	a9 01		lda #$01					        LDA #$01		;Default Value - (C256 - JP1 Fanout Pin 10) Setup as GPIO Input for now
.010785	8f 3a 11 7f	sta $7f113a					        STA GP37_REG
.010789	a9 01		lda #$01					        LDA #$01		;Default Value - C256 Doesn't use this IO Pin
.01078b	8f 3d 11 7f	sta $7f113d					        STA GP42_REG
.01078f	a9 01		lda #$01				          LDA #$01		;(C256 - INPUT PLL CLK INTERRUPT) Default Value - Will keep it as an input for now, no real usage for now
.010791	8f 3e 11 7f	sta $7f113e					        STA GP43_REG
.010795	a9 05		lda #$05					        LDA #$05		;(C256 - UART2 - RI2) - Input - Set Secondary Function
.010797	8f 3f 11 7f	sta $7f113f					        STA GP50_REG
.01079b	a9 05		lda #$05					        LDA #$05		;(C256 - UART2 - DCD2) - Input - Set Secondary Function
.01079d	8f 40 11 7f	sta $7f1140					        STA GP51_REG
.0107a1	a9 05		lda #$05					        LDA #$05		;(C256 - UART2 - RXD2) - Input - Set Secondary Function
.0107a3	8f 41 11 7f	sta $7f1141					        STA GP52_REG
.0107a7	a9 04		lda #$04					        LDA #$04		;(C256 - UART2 - TXD2) - Output - Set Secondary Function
.0107a9	8f 42 11 7f	sta $7f1142					        STA GP53_REG
.0107ad	a9 05		lda #$05					        LDA #$05		;(C256 - UART2 - DSR2) - Input - Set Secondary Function
.0107af	8f 43 11 7f	sta $7f1143					        STA GP54_REG
.0107b3	a9 04		lda #$04					        LDA #$04		;(C256 - UART2 - RTS2) - Output - Set Secondary Function
.0107b5	8f 44 11 7f	sta $7f1144					        STA GP55_REG
.0107b9	a9 05		lda #$05					        LDA #$05		;(C256 - UART2 - CTS2) - Input - Set Secondary Function
.0107bb	8f 45 11 7f	sta $7f1145					        STA GP56_REG
.0107bf	a9 04		lda #$04					        LDA #$04		;(C256 - UART2 - DTR2) - Output - Set Secondary Function
.0107c1	8f 46 11 7f	sta $7f1146					        STA GP57_REG
.0107c5	a9 84		lda #$84					        LDA #$84		;(C256 - LED1) - Open Drain - Output
.0107c7	8f 47 11 7f	sta $7f1147					        STA GP60_REG
.0107cb	a9 84		lda #$84					        LDA #$84		;(C256 - LED2) - Open Drain - Output
.0107cd	8f 48 11 7f	sta $7f1148					        STA GP61_REG
.0107d1	a9 00		lda #$00				        	LDA #$00		;GPIO Data Register (GP10..GP17) - Not Used
.0107d3	8f 4b 11 7f	sta $7f114b					        STA GP1_REG
.0107d7	a9 01		lda #$01					        LDA #$01		;GPIO Data Register (GP20..GP27) - Bit[0] - Headphone Mute (Enabling it)
.0107d9	8f 4c 11 7f	sta $7f114c					        STA GP2_REG
.0107dd	a9 00		lda #$00					        LDA #$00		;GPIO Data Register (GP30..GP37) - Since it is in Output mode, nothing to write here.
.0107df	8f 4d 11 7f	sta $7f114d					        STA GP3_REG
.0107e3	a9 00		lda #$00					        LDA #$00		;GPIO Data Register (GP40..GP47)  - Not Used
.0107e5	8f 4e 11 7f	sta $7f114e					        STA GP4_REG
.0107e9	a9 00		lda #$00					        LDA #$00		;GPIO Data Register (GP50..GP57)  - Not Used
.0107eb	8f 4f 11 7f	sta $7f114f					        STA GP5_REG
.0107ef	a9 00		lda #$00					        LDA #$00		;GPIO Data Register (GP60..GP61)  - Not Used
.0107f1	8f 50 11 7f	sta $7f1150					        STA GP6_REG
.0107f5	a9 01		lda #$01					        LDA #$01		;LED1 Output - Already setup by Vicky Init Phase, for now, I will leave it alone
.0107f7	8f 5d 11 7f	sta $7f115d					        STA LED1_REG
.0107fb	a9 02		lda #$02					        LDA #$02		;LED2 Output - However, I will setup this one, to make sure the Code works (Full On, when Code was ran)
.0107fd	8f 5e 11 7f	sta $7f115e					        STA LED2_REG
.010801	c2 20		rep #$20	                REP #$20        ; set A long
.010803	68		pla		                PLA
.010804	28		plp						        PLP
.010805	2b		pld					        	PLD
.010806	6b		rtl		                RTL
.010807	0b		phd		IINITKEYBOARD	  PHD
.010808	08		php						        PHP
.010809	48		pha						        PHA
.01080a	da		phx						        PHX
.01080b	e2 20		sep #$20	                SEP #$20        ; set A short
.01080d	e2 10		sep #$10	                SEP #$10        ; set X short
.01080f	a2 00		ldx #$00					        LDX	#$00
.010811	bf 64 10 7f	lda $7f1064,x	initkb_loop1	  LDA @lSTATUS_PORT,x		; Load Status Byte
.010815	29 02		and #$02					        AND	#INPT_BUF_FULL	; Test bit $02 (if 0, Empty)
.010817	c9 02		cmp #$02					        CMP #INPT_BUF_FULL
.010819	f0 f6		beq $010811					        BEQ initkb_loop1
.01081b	a9 aa		lda #$aa					        LDA #$0AA			;Send self test command
.01081d	9f 64 10 7f	sta $7f1064,x					        STA @lKBD_CMD_BUF,x
.010821	bf 64 10 7f	lda $7f1064,x	initkb_loop2	  LDA @lSTATUS_PORT,x		; Wait for test to complete
.010825	29 01		and #$01					        AND	#OUT_BUF_FULL	; Test bit $01 (0 = No Data)
.010827	c9 01		cmp #$01					        CMP #OUT_BUF_FULL
.010829	d0 f6		bne $010821					        BNE initkb_loop2
.01082b	bf 60 10 7f	lda $7f1060,x					        LDA @lKBD_OUT_BUF,x		;Check self test result
.01082f	c9 55		cmp #$55					        CMP #$55
.010831	d0 2c		bne $01085f					        BNE	initkb_loop_out
.010833	a9 ab		lda #$ab					        LDA #$AB			;Send test Interface command
.010835	9f 60 10 7f	sta $7f1060,x					        STA @lKBD_DATA_BUF,x
.010839	bf 64 10 7f	lda $7f1064,x	initkb_loop3	  LDA @lSTATUS_PORT,x		; Wait for test to complete
.01083d	29 01		and #$01					        AND	#OUT_BUF_FULL	; Test bit $01 (if 0, Empty)
.01083f	c9 01		cmp #$01					        CMP #OUT_BUF_FULL
.010841	d0 f6		bne $010839				        	BNE initkb_loop3
.010843	bf 60 10 7f	lda $7f1060,x					        LDA @lKBD_OUT_BUF,x		;Display Interface test results
.010847	c9 00		cmp #$00					        CMP #$00			;Should be 00
.010849	d0 14		bne $01085f					        BNE	initkb_loop_out
.01084b	a9 ae		lda #$ae					        LDA #$AE			; Enable the Keyboard
.01084d	9f 60 10 7f	sta $7f1060,x					        STA @lKBD_DATA_BUF,x
.010851	bf 64 10 7f	lda $7f1064,x	initkb_loop8	  LDA @lSTATUS_PORT,x		; Wait for test to complete
.010855	29 01		and #$01					        AND	#OUT_BUF_FULL	; Test bit $01 (if 0, Empty)
.010857	c9 01		cmp #$01					        CMP #OUT_BUF_FULL
.010859	d0 f6		bne $010851					        BNE initkb_loop8
.01085b	bf 60 10 7f	lda $7f1060,x					        LDA @lKBD_OUT_BUF,x		; Clear the Output buffer
.01085f					initkb_loop_out
.01085f	c2 20		rep #$20	                REP #$20        ; set A long
.010861	c2 10		rep #$10	                REP #$10        ; set X long
.010863	fa		plx		                PLX
.010864	68		pla		                PLA
.010865	28		plp						        PLP
.010866	2b		pld						        PLD
.010867	6b		rtl		                RTL
.010868	48		pha		IINITVIAS       PHA
.010869	e2 20		sep #$20	                SEP #$20        ; set A short
.01086b	a9 e0		lda #$e0	                LDA #$E0
.01086d	8f 02 0c 7f	sta $7f0c02	                STA VIA0_DDR_REG_B ; Set Dir ( JOYA )- PA0..4 In, PA5..7 output
.010871	8f 03 0c 7f	sta $7f0c03	                STA VIA0_DDR_REG_A ; Set Dir ( JOYB )- PA0..4 In, PA5..7 output
.010875	a9 ff		lda #$ff	                LDA #$FF
.010877	8f 02 0d 7f	sta $7f0d02	                STA VIA1_DDR_REG_B ; Set Dir( USER Port ) - PA0..7 Output
.01087b	a9 55		lda #$55	                LDA #$55
.01087d	8f 01 0d 7f	sta $7f0d01	                STA VIA1_IO_REG_A ; THis is to Test if Code Worked Fine (check Value on the USER Port Connector)
.010881	a9 0b		lda #$0b	                LDA #$0B
.010883	8f 06 0d 7f	sta $7f0d06	                STA VIA1_T1L_L
.010887	a9 e9		lda #$e9	                LDA #$E9
.010889	8f 07 0d 7f	sta $7f0d07	                STA VIA1_T1L_H
.01088d	a9 41		lda #$41	                LDA #$41
.01088f	8f 0b 0d 7f	sta $7f0d0b	                STA VIA1_ACR    ; Continuous interrupts, enable latching
.010893	c2 20		rep #$20	                REP #$20        ; set A long
.010895	68		pla		                PLA
.010896	6b		rtl		                RTL
.010897	48		pha		IINITRTC        PHA
.010898	e2 20		sep #$20	                SEP #$20        ; set A short
.01089a	a9 00		lda #$00	                LDA #$00
.01089c	8f 00 08 7f	sta $7f0800	                STA RTC_SEC     ;Set the Time to 10:10AM
.0108a0	a9 0a		lda #$0a	                LDA #10
.0108a2	8f 02 08 7f	sta $7f0802	                STA RTC_MIN
.0108a6	8f 04 08 7f	sta $7f0804	                STA RTC_HRS
.0108aa	a9 0c		lda #$0c	                LDA #12
.0108ac	8f 06 08 7f	sta $7f0806	                STA RTC_DAY
.0108b0	a9 04		lda #$04	                LDA #04
.0108b2	8f 09 08 7f	sta $7f0809	                STA RTC_MONTH   ; April 12th, 2018 - Begining of the Project
.0108b6	a9 04		lda #$04	                LDA #04
.0108b8	8f 09 08 7f	sta $7f0809	                STA RTC_MONTH   ; Thursday
.0108bc	a9 12		lda #$12	                LDA #18
.0108be	8f 0a 08 7f	sta $7f080a	                STA RTC_YEAR    ; Thursday
.0108c2	af 06 08 7f	lda $7f0806	                LDA RTC_DAY     ; Read the Day Registers
.0108c6	8f 06 08 7f	sta $7f0806	                STA RTC_DAY     ; Store it back
.0108ca	c2 20		rep #$20	                REP #$20        ; set A long
.0108cc	68		pla		                PLA
.0108cd	6b		rtl		                RTL
.0108ce	48		pha		ITESTSID        PHA
.0108cf	e2 20		sep #$20	                SEP #$20        ; set A short
.0108d1	a9 36		lda #$36	                LDA #$36              ;Left Side (Rev A of Board)
.0108d3	8f 00 05 7f	sta $7f0500	                STA SID0_V1_FREQ_LO
.0108d7	a9 03		lda #$03	                LDA #$03
.0108d9	8f 01 05 7f	sta $7f0501	                STA SID0_V1_FREQ_HI   ;G1
.0108dd	a9 00		lda #$00	                LDA #$00              ;Left Side (Rev A of Board)
.0108df	8f 02 05 7f	sta $7f0502	                STA SID0_V1_PW_LO
.0108e3	a9 08		lda #$08	                LDA #$08
.0108e5	8f 03 05 7f	sta $7f0503	                STA SID0_V1_PW_HI   ;G1
.0108e9	a9 08		lda #$08	                LDA #$08
.0108eb	8f 04 05 7f	sta $7f0504	                STA SID0_V1_CTRL    ; Reset
.0108ef	a9 0c		lda #$0c	                LDA #$0C
.0108f1	8f 07 05 7f	sta $7f0507	                STA SID0_V2_FREQ_LO
.0108f5	a9 04		lda #$04	                LDA #$04
.0108f7	8f 08 05 7f	sta $7f0508	                STA SID0_V2_FREQ_HI   ;B1
.0108fb	a9 00		lda #$00	                LDA #$00              ;Left Side (Rev A of Board)
.0108fd	8f 09 05 7f	sta $7f0509	                STA SID0_V2_PW_LO
.010901	a9 08		lda #$08	                LDA #$08
.010903	8f 0a 05 7f	sta $7f050a	                STA SID0_V2_PW_HI   ;G1
.010907	a9 08		lda #$08	                LDA #$08
.010909	8f 0b 05 7f	sta $7f050b	                STA SID0_V2_CTRL    ; Reset
.01090d	a9 00		lda #$00	                LDA #$00
.01090f	8f 0e 05 7f	sta $7f050e	                STA SID0_V3_FREQ_LO
.010913	a9 08		lda #$08	                LDA #$08
.010915	8f 0f 05 7f	sta $7f050f	                STA SID0_V3_FREQ_HI   ;D
.010919	a9 00		lda #$00	                LDA #$00              ;Left Side (Rev A of Board)
.01091b	8f 10 05 7f	sta $7f0510	                STA SID0_V3_PW_LO
.01091f	a9 08		lda #$08	                LDA #$08
.010921	8f 11 05 7f	sta $7f0511	                STA SID0_V3_PW_HI   ;G1
.010925	a9 08		lda #$08	                LDA #$08
.010927	8f 12 05 7f	sta $7f0512	                STA SID0_V3_CTRL    ; Reset
.01092b	a9 0f		lda #$0f	                LDA #$0F
.01092d	8f 18 05 7f	sta $7f0518	                STA SID0_MODE_VOL
.010931	a9 10		lda #$10	                LDA #$10
.010933	8f 04 05 7f	sta $7f0504	                STA SID0_V1_CTRL    ; Triangle
.010937	8f 0b 05 7f	sta $7f050b	                STA SID0_V2_CTRL    ; Triangle
.01093b	8f 12 05 7f	sta $7f0512	                STA SID0_V3_CTRL    ; Triangle
.01093f	a9 36		lda #$36	                LDA #$36              ;Left Side (Rev A of Board)
.010941	8f 80 05 7f	sta $7f0580	                STA SID1_V1_FREQ_LO
.010945	a9 03		lda #$03	                LDA #$03
.010947	8f 81 05 7f	sta $7f0581	                STA SID1_V1_FREQ_HI   ;G1
.01094b	a9 00		lda #$00	                LDA #$00              ;Left Side (Rev A of Board)
.01094d	8f 82 05 7f	sta $7f0582	                STA SID1_V1_PW_LO
.010951	a9 08		lda #$08	                LDA #$08
.010953	8f 83 05 7f	sta $7f0583	                STA SID1_V1_PW_HI   ;G1
.010957	a9 08		lda #$08	                LDA #$08
.010959	8f 84 05 7f	sta $7f0584	                STA SID1_V1_CTRL    ; Reset
.01095d	a9 0c		lda #$0c	                LDA #$0C
.01095f	8f 87 05 7f	sta $7f0587	                STA SID1_V2_FREQ_LO
.010963	a9 04		lda #$04	                LDA #$04
.010965	8f 88 05 7f	sta $7f0588	                STA SID1_V2_FREQ_HI   ;B1
.010969	a9 00		lda #$00	                LDA #$00              ;Left Side (Rev A of Board)
.01096b	8f 89 05 7f	sta $7f0589	                STA SID1_V2_PW_LO
.01096f	a9 08		lda #$08	                LDA #$08
.010971	8f 8a 05 7f	sta $7f058a	                STA SID1_V2_PW_HI   ;G1
.010975	a9 08		lda #$08	                LDA #$08
.010977	8f 8b 05 7f	sta $7f058b	                STA SID1_V2_CTRL    ; Reset
.01097b	a9 00		lda #$00	                LDA #$00
.01097d	8f 8e 05 7f	sta $7f058e	                STA SID1_V3_FREQ_LO
.010981	a9 08		lda #$08	                LDA #$08
.010983	8f 8f 05 7f	sta $7f058f	                STA SID1_V3_FREQ_HI   ;D
.010987	a9 00		lda #$00	                LDA #$00              ;Left Side (Rev A of Board)
.010989	8f 90 05 7f	sta $7f0590	                STA SID1_V3_PW_LO
.01098d	a9 08		lda #$08	                LDA #$08
.01098f	8f 91 05 7f	sta $7f0591	                STA SID1_V3_PW_HI   ;G1
.010993	a9 08		lda #$08	                LDA #$08
.010995	8f 92 05 7f	sta $7f0592	                STA SID1_V3_CTRL    ; Reset
.010999	a9 0f		lda #$0f	                LDA #$0F
.01099b	8f 98 05 7f	sta $7f0598	                STA SID1_MODE_VOL
.01099f	a9 10		lda #$10	                LDA #$10
.0109a1	8f 84 05 7f	sta $7f0584	                STA SID1_V1_CTRL    ; Triangle
.0109a5	8f 8b 05 7f	sta $7f058b	                STA SID1_V2_CTRL    ; Triangle
.0109a9	8f 92 05 7f	sta $7f0592	                STA SID1_V3_CTRL    ; Triangle
.0109ad	c2 20		rep #$20	                REP #$20        ; set A long
.0109af	68		pla		                PLA
.0109b0	6b		rtl		                RTL
.0109b1	48		pha		ITESTMATH       PHA
.0109b2	c2 20		rep #$20	                REP #$20        ; set A long
.0109b4	a9 34 12	lda #$1234	                LDA #$1234
.0109b7	8f 00 01 00	sta $000100	                STA UNSIGNED_MULT_A_LO
.0109bb	a9 aa 55	lda #$55aa	                LDA #$55AA
.0109be	8f 02 01 00	sta $000102	                STA UNSIGNED_MULT_B_LO
.0109c2	af 04 01 00	lda $000104	                LDA UNSIGNED_MULT_AL_LO
.0109c6	8f 00 04 00	sta $000400	                STA STEF_BLOB_BEGIN
.0109ca	af 06 01 00	lda $000106	                LDA UNSIGNED_MULT_AH_LO
.0109ce	8f 02 04 00	sta $000402	                STA STEF_BLOB_BEGIN + 2
.0109d2	c2 10		rep #$10	                REP #$10        ; set X long
.0109d4	c2 20		rep #$20	                REP #$20        ; set A long
.0109d6	68		pla		                PLA
.0109d7	6b		rtl		                RTL
.0109d8	00		brk #		IRESTORE        BRK ; Warm boot routine
.0109d9	00		brk #		ISCINIT         BRK ;
.0109da	00		brk #		IIOINIT         BRK ;
.0109db	00		brk #		IPUTBLOCK       BRK ; Ouput a binary block to the currently selected channel
.0109dc	00		brk #		ISETLFS         BRK ; Obsolete (done in OPEN)
.0109dd	00		brk #		ISETNAM         BRK ; Obsolete (done in OPEN)
.0109de	00		brk #		IOPEN           BRK ; Open a channel for reading and/or writing. Use SETLFS and SETNAM to set the channels and filename first.
.0109df	00		brk #		ICLOSE          BRK ; Close a channel
.0109e0	00		brk #		ISETIN          BRK ; Set the current input channel
.0109e1	00		brk #		ISETOUT         BRK ; Set the current output channel
.0109e2	00		brk #		IGETB           BRK ; Get a byte from input channel. Return 0 if no input. Carry is set if no input.
.0109e3	00		brk #		IGETBLOCK       BRK ; Get a X byes from input channel. If Carry is set, wait. If Carry is clear, do not wait.
.0109e4	00		brk #		IGETCH          BRK ; Get a character from the input channel. A=0 and Carry=1 if no data is wating
.0109e5	00		brk #		IGETS           BRK ; Get a string from the input channel. NULL terminates
.0109e6	00		brk #		IGETLINE        BRK ; Get a line of text from input channel. CR or NULL terminates.
.0109e7	00		brk #		IGETFIELD       BRK ; Get a field from the input channel. Value in A, CR, or NULL terminates
.0109e8	00		brk #		ITRIM           BRK ; Removes spaces at beginning and end of string.
.0109e9	00		brk #		IPRINTC         BRK ; Print character to screen. Handles terminal commands
.0109ea	00		brk #		IPRINTS         BRK ; Print string to screen. Handles terminal commands
.0109eb	00		brk #		IPRINTF         BRK ; Print a float value
.0109ec	00		brk #		IPRINTI         BRK ; Prints integer value in TEMP
.0109ed	00		brk #		IPRINTAI        BRK ; Prints integer value in A
.0109ee	00		brk #		IPRINTAH        BRK ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
.0109ef	00		brk #		IPUSHKEY        BRK ;
.0109f0	00		brk #		IPUSHKEYS       BRK ;
.0109f1	00		brk #		ICSRLEFT        BRK ;
.0109f2	00		brk #		ICSRHOME        BRK ;
.0109f3	00		brk #		ISCRREADLINE    BRK ; Loads the MCMDADDR/BCMDADDR variable with the address of the current line on the screen. This is called when the RETURN key is pressed and is the first step in processing an immediate mode command.
.0109f4	00		brk #		ISCRGETWORD     BRK ; Read a current word on the screen. A word ends with a space, punctuation (except _), or any control character (value < 32). Loads the address into CMPTEXT_VAL and length into CMPTEXT_LEN variables.
.0109f5					KERNEL_DATA
>0109f5	20 20 20 20 ec a9 ec a9		greet_msg       .text $20, $20, $20, $20, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, "C256 FOENIX DEVELOPMENT SYSTEM",$0D
>0109fd	ec a9 ec a9 ec a9 43 32 35 36 20 46 4f 45 4e 49
>010a0d	58 20 44 45 56 45 4c 4f 50 4d 45 4e 54 20 53 59
>010a1d	53 54 45 4d 0d
>010a22	20 20 20 ec a9 ec a9 ec		                .text $20, $20, $20, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $20, "OPEN SOURCE COMPUTER",$0D
>010a2a	a9 ec a9 ec a9 20 4f 50 45 4e 20 53 4f 55 52 43
>010a3a	45 20 43 4f 4d 50 55 54 45 52 0d
>010a45	20 20 ec a9 ec a9 ec a9		                .text $20, $20, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $20, $20, "HARDWARE DESIGNER: STEFANY ALLAIRE",$0D
>010a4d	ec a9 ec a9 20 20 48 41 52 44 57 41 52 45 20 44
>010a5d	45 53 49 47 4e 45 52 3a 20 53 54 45 46 41 4e 59
>010a6d	20 41 4c 4c 41 49 52 45 0d
>010a76	20 ec a9 ec a9 ec a9 ec		                .text $20, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $20, $20, $20, "SOFTWARE DESIGNER: TOM WILSON",$0D
>010a7e	a9 ec a9 20 20 20 53 4f 46 54 57 41 52 45 20 44
>010a8e	45 53 49 47 4e 45 52 3a 20 54 4f 4d 20 57 49 4c
>010a9e	53 4f 4e 0d
>010aa2	ec a9 ec a9 ec a9 ec a9		                .text $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $EC, $A9, $20, $20, $20, $20, "1024KB BASIC RAM  8192K MEDIA RAM",$00
>010aaa	ec a9 20 20 20 20 31 30 32 34 4b 42 20 42 41 53
>010aba	49 43 20 52 41 4d 20 20 38 31 39 32 4b 20 4d 45
>010aca	44 49 41 20 52 41 4d 00
>010ad2	1d 1d 1d 1d 1d 1d 8d 8d		greet_clr_line1 .text $1D, $1D, $1D, $1D, $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D
>010ada	4d 4d 2d 2d 5d 5d
>010ae0	1d 1d 1d 1d 1d 8d 8d 4d		greet_clr_line2 .text $1D, $1D, $1D, $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D, $5D
>010ae8	4d 2d 2d 5d 5d 5d
>010aee	1d 1d 1d 1d 8d 8d 4d 4d		greet_clr_line3 .text $1D, $1D, $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D, $5D, $5D
>010af6	2d 2d 5d 5d 5d 5d
>010afc	1d 1d 1d 8d 8d 4d 4d 2d		greet_clr_line4 .text $1D, $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D, $5D, $5D, $5D
>010b04	2d 5d 5d 5d 5d 5d
>010b0a	1d 1d 8d 8d 4d 4d 2d 2d		greet_clr_line5 .text $1D, $1D, $8D, $8D, $4D, $4D, $2D, $2D, $5D, $5D, $5D, $5D, $5D, $5D
>010b12	5d 5d 5d 5d 5d 5d
>010b18	00 00 00 ff			fg_color_lut	  .text $00, $00, $00, $FF
>010b1c	00 00 c0 ff			                .text $00, $00, $C0, $FF
>010b20	00 c0 00 ff			                .text $00, $C0, $00, $FF
>010b24	c0 00 00 ff			                .text $C0, $00, $00, $FF
>010b28	00 c0 c0 ff			                .text $00, $C0, $C0, $FF
>010b2c	c0 c0 00 ff			                .text $C0, $C0, $00, $FF
>010b30	c0 00 c0 ff			                .text $C0, $00, $C0, $FF
>010b34	c0 c0 c0 ff			                .text $C0, $C0, $C0, $FF
>010b38	00 7f ff ff			                .text $00, $7F, $FF, $FF
>010b3c	13 45 8b ff			                .text $13, $45, $8B, $FF
>010b40	00 00 40 ff			                .text $00, $00, $40, $FF
>010b44	00 40 00 ff			                .text $00, $40, $00, $FF
>010b48	40 00 00 ff			                .text $40, $00, $00, $FF
>010b4c	40 40 40 ff			                .text $40, $40, $40, $FF
>010b50	80 80 80 ff			                .text $80, $80, $80, $FF
>010b54	ff ff ff ff			                .text $FF, $FF, $FF, $FF
>010b58	00 00 00 ff			bg_color_lut	  .text $00, $00, $00, $FF
>010b5c	00 00 c0 ff			                .text $00, $00, $C0, $FF
>010b60	00 c0 00 ff			                .text $00, $C0, $00, $FF
>010b64	c0 00 00 ff			                .text $C0, $00, $00, $FF
>010b68	00 40 40 ff			                .text $00, $40, $40, $FF
>010b6c	40 40 00 ff			                .text $40, $40, $00, $FF
>010b70	40 00 40 ff			                .text $40, $00, $40, $FF
>010b74	40 40 40 ff			                .text $40, $40, $40, $FF
>010b78	1e 69 d2 ff			                .text $1E, $69, $D2, $FF
>010b7c	13 45 8b ff			                .text $13, $45, $8B, $FF
>010b80	00 00 40 ff			                .text $00, $00, $40, $FF
>010b84	00 40 00 ff			                .text $00, $40, $00, $FF
>010b88	40 00 00 ff			                .text $40, $00, $00, $FF
>010b8c	20 20 20 ff			                .text $20, $20, $20, $FF
>010b90	80 80 80 ff			                .text $80, $80, $80, $FF
>010b94	ff ff ff ff			                .text $FF, $FF, $FF, $FF
>010b98	44 65 67 75 67 20 43 6f		version_msg     .text "Degug Code Version 0.0.1 - Oct 8th, 2018", $0D, $00
>010ba0	64 65 20 56 65 72 73 69 6f 6e 20 30 2e 30 2e 31
>010bb0	20 2d 20 4f 63 74 20 38 74 68 2c 20 32 30 31 38
>010bc0	0d 00
>010bc2	49 6e 69 74 20 53 75 70		init_lpc_msg    .text "Init SuperIO...", $0D, $00
>010bca	65 72 49 4f 2e 2e 2e 0d 00
>010bd3	49 6e 69 74 20 4b 65 79		init_kbrd_msg   .text "Init Keyboard...", $0D, $00
>010bdb	62 6f 61 72 64 2e 2e 2e 0d 00
>010be5	49 6e 69 74 20 56 49 41		init_via_msg    .text "Init VIAs...", $0D, $00
>010bed	73 2e 2e 2e 0d 00
>010bf3	49 6e 69 74 20 52 54 43		init_rtc_msg    .text "Init RTC...", $0D, $00
>010bfb	2e 2e 2e 0d 00
>010c00	54 65 73 74 69 6e 67 20		test_SID_msg    .text "Testing Right & Left SID", $0D, $00
>010c08	52 69 67 68 74 20 26 20 4c 65 66 74 20 53 49 44
>010c18	0d 00
>010c1a	0d 52 45 41 44 59 2e 00		ready_msg       .null $0D,"READY."
>010c22	31 30 20 50 52 49 4e 54		hello_basic     .null "10 PRINT ""Hello World""",$0D
>010c2a	20 22 48 65 6c 6c 6f 20 57 6f 72 6c 64 22 0d 00
>010c3a	52 55 4e 0d 00			                .null "RUN",$0D
>010c3f	48 65 6c 6c 6f 20 57 6f		                .null "Hello World",$0D
>010c47	72 6c 64 0d 00
>010c4c	0d 52 45 41 44 59 2e 00		                .null $0D,"READY."
>010c54	47 20 30 32 30 30 30 30		hello_ml        .null "G 020000",$0D
>010c5c	0d 00
>010c5e	48 45 4c 4c 4f 20 57 4f		                .null "HELLO WORLD",$0D
>010c66	52 4c 44 0d 00
>010c6b	0d 00				                .null $0D
>010c6d	20 50 43 20 20 20 20 20		                .null " PC     A    X    Y    SP   DBR DP   NVMXDIZC",$0D
>010c75	41 20 20 20 20 58 20 20 20 20 59 20 20 20 20 53
>010c85	50 20 20 20 44 42 52 20 44 50 20 20 20 4e 56 4d
>010c95	58 44 49 5a 43 0d 00
>010c9c	3b 30 30 32 31 31 32 20		                .null ";002112 0019 F0AA 0000 D6FF F8  0000 --M-----"
>010ca4	30 30 31 39 20 46 30 41 41 20 30 30 30 30 20 44
>010cb4	36 46 46 20 46 38 20 20 30 30 30 30 20 2d 2d 4d
>010cc4	2d 2d 2d 2d 2d 00
>010cca	41 42 4f 52 54 20 45 52		error_01        .null "ABORT ERROR"
>010cd2	52 4f 52 00
>010cd6	30 31 32 33 34 35 36 37		hex_digits      .text "0123456789ABCDEF",0
>010cde	38 39 41 42 43 44 45 46 00

;******  End of listing
