
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass --long-address --intel-hex -o kernel.hex --list kernel.lst kernel.asm
; Tue Sep 18 21:56:43 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm


;******  Processing file: macros_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: simulator_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: page_00_inc.asm

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				RESET            = $000000 ;4 Bytes Jumps to the beginning of kernel ROM. ($F8:0000).
=$000004				RETURN           = $000004 ;4 Bytes Called when the RETURN key is pressed in the immediate mode screen. This will process a command in MONITOR, execute a BASIC command, or add a BASIC program line.
=$000008				KEYDOWN          = $000008 ;4 Bytes Custom keyboard handler. This defaults to the kernel keypress handler, but you can redirect this to your own routines. Make sure to JML to the original address at the end of your custom routine. Use this to make F-Key macros or custom keyboard commands.
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;2 Bytes Color of next character to be printed to the screen.
=$000020				CURATTR          = $000020 ;2 Bytes Attribute of next character to be printed to the screen.
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$0000c0				KERNEL_TEMP      = $0000C0 ;32 Bytes Temp space for kernel
=$0000e0				USER_TEMP        = $0000E0 ;32 Bytes Temp space for user programs
=$000100				PAGE0_END_       = $000100 ; Byte
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000108				DIVIDER_0        = $000108 ;0 Byte  Unsigned divider
=$000108				D0_OPERAND_A     = $000108 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$00010a				D0_OPERAND_B     = $00010A ;2 Bytes Divider 0 Divisor ex B in A/B
=$00010c				D0_RESULT        = $00010C ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$00010e				D0_REMAINDER     = $00010E ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000110				DIVIDER_1        = $000110 ;0 Byte  Signed divider
=$000110				D1_OPERAND_A     = $000110 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$000112				D1_OPERAND_B     = $000112 ;2 Bytes Divider 1 Divisor ex B in A/B
=$000114				D1_RESULT        = $000114 ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D1_REMAINDER     = $000116 ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$0001ff				VECTOR_STATE     = $0001FF ;1 Byte  Interrupt Vector State. See VECTOR_STATE_ENUM
=$000200				CPU_REGISTERS    = $000200 ; Byte
=$000200				CPUPC            = $000200 ;2 Bytes Debug registers. When BRK is executed, Interrupt service routine will populate this block with the CPU registers.
=$000202				CPUPBR           = $000202 ;1 Byte  Program Bank Register (K)
=$000203				CPUDBR           = $000203 ;1 Byte  Data Bank Register (B)
=$000204				CPUFLAGS         = $000204 ;1 Byte  Flags (P) (The second byte is ignored)
=$000205				CPUA             = $000205 ;2 Bytes Accumulator (A)
=$000207				CPUX             = $000207 ;2 Bytes X Register
=$000209				CPUY             = $000209 ;2 Bytes Y Index Register
=$00020b				CPUDP            = $00020B ;2 Bytes Direct Page Register (D)
=$00020d				CPUSTACK         = $00020D ;2 Bytes Stack Pointer
=$000210				MONITOR_VARS     = $000210 ; Byte  MONITOR Variables. BASIC variables may overlap this space
=$000210				MCMDADDR         = $000210 ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$000213				MCMP_TEXT        = $000213 ;3 Bytes Address of symbol being evaluated for COMPARE routine
=$000216				MCMP_LEN         = $000216 ;2 Bytes Length of symbol being evaluated for COMPARE routine
=$000218				MCMD             = $000218 ;3 Bytes Address of the current command/function string
=$00021b				MCMD_LEN         = $00021B ;2 Bytes Length of the current command/function string
=$00021d				MARG1            = $00021D ;4 Bytes First command argument. May be data or address, depending on command
=$000221				MARG2            = $000221 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000225				MARG3            = $000225 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000229				MARG4            = $000229 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$00022d				MARG5            = $00022D ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000231				MARG6            = $000231 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000235				MARG7            = $000235 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000239				MARG8            = $000239 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$00f00					KEY_BUFFER       = $00F00 ;64 Bytes KEY_BUFFER
=$40					KEY_BUFFER_SIZE  = $40 ;64 Bytes KEY_BUFFER_SIZE
=$000f3f				KEY_BUFFER_END   = $000F3F ;1 Byte  KEY_BUFFER_END
=$000f40				KEY_BUFFER_RPOS  = $000F40 ;2 Bytes KEY_BUFFER_RPOS
=$000f42				KEY_BUFFER_WPOS  = $000F42 ;2 Bytes KEY_BUFFER_WPOS
=$001000				TEST_BEGIN       = $001000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ff00				ISR_BEGIN        = $00FF00 ; Byte  Beginning of CPU vectors in Direct page
=$00ff00				HRESET           = $00FF00 ;16 Bytes Handle RESET asserted. Reboot computer and re-initialize the kernel.
=$00ff10				HCOP             = $00FF10 ;16 Bytes Handle the COP instruction. Program use; not used by OS
=$00ff20				HBRK             = $00FF20 ;16 Bytes Handle the BRK instruction. Returns to BASIC Ready prompt.
=$00ff30				HABORT           = $00FF30 ;16 Bytes Handle ABORT asserted. Return to Ready prompt with an error message.
=$00ff40				HNMI             = $00FF40 ;32 Bytes Handle NMI
=$00ff60				HIRQ             = $00FF60 ;32 Bytes Handle IRQ
=$00ff80				ISR_END          = $00FF80 ;End of direct page Interrrupt handlers
=$00ffe0				VECTORS_BEGIN    = $00FFE0 ;0 Byte  Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$00ffe0				JMP_READY        = $00FFE0 ;4 Bytes Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$00ffe4				VECTOR_COP       = $00FFE4 ;2 Bytes Native COP Interrupt vector
=$00ffe6				VECTOR_BRK       = $00FFE6 ;2 Bytes Native BRK Interrupt vector
=$00ffe8				VECTOR_ABORT     = $00FFE8 ;2 Bytes Native ABORT Interrupt vector
=$00ffea				VECTOR_NMI       = $00FFEA ;2 Bytes Native NMI Interrupt vector
=$00ffec				VECTOR_RESET     = $00FFEC ;2 Bytes Unused (Native RESET vector)
=$00ffee				VECTOR_IRQ       = $00FFEE ;2 Bytes Native IRQ Vector
=$00fff4				VECTOR_ECOP      = $00FFF4 ;2 Bytes Emulation mode interrupt handler
=$00fff6				VECTOR_EBRK      = $00FFF6 ;2 Bytes Emulation mode interrupt handler
=$00fff8				VECTOR_EABORT    = $00FFF8 ;2 Bytes Emulation mode interrupt handler
=$00fffa				VECTOR_ENMI      = $00FFFA ;2 Bytes Emulation mode interrupt handler
=$00fffc				VECTOR_ERESET    = $00FFFC ;2 Bytes Emulation mode interrupt handler
=$00fffe				VECTOR_EIRQ      = $00FFFE ;2 Bytes Emulation mode interrupt handler
=$010000				VECTORS_END      = $010000 ;*End of vector space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: kernel.asm


;******  Processing file: dram_inc.asm

=$800000				SCREEN_PAGE0     = $800000 ;8192 Bytes First page of display RAM. This is used at boot time to display the welcome screen and the BASIC or MONITOR command screens.
=$802000				SCREEN_PAGE1     = $802000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$804000				SCREEN_PAGE2     = $804000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$806000				SCREEN_PAGE3     = $806000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$808000				SCREEN_END       = $808000 ;End of display memory

;******  Return to file: kernel.asm


;******  Processing file: monitor.asm

.f90000	5c 00 04 f9	jmp $f90400	MONITOR         JML IMONITOR
.f90004	5c 06 04 f9	jmp $f90406	MBREAK          JML IMBREAK
.f90008	5c 07 04 f9	jmp $f90407	MSTATUS         JML IMSTATUS
.f9000c	5c 08 04 f9	jmp $f90408	MREADY          JML IMREADY
.f90010	5c 09 04 f9	jmp $f90409	MRETURN         JML IMRETURN
.f90014	5c 0a 04 f9	jmp $f9040a	MPARSE          JML IMPARSE
.f90018	5c 0b 04 f9	jmp $f9040b	MPARSE1         JML IMPARSE1
.f9001c	5c 0c 04 f9	jmp $f9040c	MEXECUTE        JML IMEXECUTE
.f90020	5c 0d 04 f9	jmp $f9040d	MASSEMBLE       JML IMASSEMBLE
.f90024	5c 0e 04 f9	jmp $f9040e	MASSEMBLEA      JML IMASSEMBLEA
.f90028	5c 0f 04 f9	jmp $f9040f	MCOMPARE        JML IMCOMPARE
.f9002c	5c 10 04 f9	jmp $f90410	MDISASSEMBLE    JML IMDISASSEMBLE
.f90030	5c 11 04 f9	jmp $f90411	MFILL           JML IMFILL
.f90034	5c 13 04 f9	jmp $f90413	MJUMP           JML IMJUMP
.f90038	5c 14 04 f9	jmp $f90414	MHUNT           JML IMHUNT
.f9003c	5c 15 04 f9	jmp $f90415	MLOAD           JML IMLOAD
.f90040	5c 16 04 f9	jmp $f90416	MMEMORY         JML IMMEMORY
.f90044	5c 17 04 f9	jmp $f90417	MREGISTERS      JML IMREGISTERS
.f90048	5c 18 04 f9	jmp $f90418	MSAVE           JML IMSAVE
.f9004c	5c 19 04 f9	jmp $f90419	MTRANSFER       JML IMTRANSFER
.f90050	5c 1a 04 f9	jmp $f9041a	MVERIFY         JML IMVERIFY
.f90054	5c 1b 04 f9	jmp $f9041b	MEXIT           JML IMEXIT
.f90058	5c 1c 04 f9	jmp $f9041c	MMODIFY         JML IMMODIFY
.f90400					IMONITOR
.f90400	18		clc		                CLC           ; clear the carry flag
.f90401	fb		xce		                XCE           ; move carry to emulation flag.
.f90402	c2 10		rep #$10	                REP #$10      ; set 16-bit index registers
.f90404	e2 20		sep #$20	                SEP #$20      ; set 8 bit accumulator
.f90406	00		brk #		IMBREAK         BRK ; Warm boot routine
.f90407	00		brk #		IMSTATUS        BRK ; Print status message
.f90408	00		brk #		IMREADY         BRK ; Prints status message and waits for input
.f90409	00		brk #		IMRETURN        BRK ; Handle RETURN key (ie: execute command)
.f9040a	00		brk #		IMPARSE         BRK ; Parse the current command line
.f9040b	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.f9040c	00		brk #		IMEXECUTE       BRK ; Execute the current command line (requires MCMD and MARG1-MARG8 to be populated)
.f9040d	00		brk #		IMASSEMBLE      BRK ; Assemble a line of text.
.f9040e	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.f9040f	00		brk #		IMCOMPARE       BRK ; Compare memory. len=1
.f90410	00		brk #		IMDISASSEMBLE   BRK ; Disassemble memory. end=1 instruction
.f90411	00		brk #		IMFILL          BRK ; Fill memory with specified value. Start and end must be in the same bank.
.f90412	00		brk #		IMGO            BRK ; Execute from specified address
.f90413	00		brk #		IMJUMP          BRK ; Execute from spefified address
.f90414	00		brk #		IMHUNT          BRK ; Hunt (find) value in memory
.f90415	00		brk #		IMLOAD          BRK ; Load data from disk. Device=1 (internal floppy) Start=Address in file
.f90416	00		brk #		IMMEMORY        BRK ; View memory
.f90417	00		brk #		IMREGISTERS     BRK ; View/edit registers
.f90418	00		brk #		IMSAVE          BRK ; Save memory to disk
.f90419	00		brk #		IMTRANSFER      BRK ; Transfer (copy) data in memory
.f9041a	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.f9041b	00		brk #		IMEXIT          BRK ; Exit monitor and return to BASIC command prompt
.f9041c	00		brk #		IMMODIFY        BRK ; Modify memory
.f9041d					MMESSAGES
>f9041d					MMERROR         .text

;******  Return to file: kernel.asm


;******  Processing file: kernel_bank_FF.asm

.ffff00	5c 00 00 01	jmp $010000	                JML BOOT
.ffff10	5c 20 ff 00	jmp $00ff20	                JMP HBRK
.ffff20					RHBRK
.ffff20	c2 30		rep #$30	                REP #$30        ; set A&X long
.ffff22	8b		phb		                PHB
.ffff23	0b		phd		                PHD
.ffff24	48		pha		                PHA
.ffff25	da		phx		                PHX
.ffff26	5a		phy		                PHY
.ffff27	5c 08 00 01	jmp $010008	                JML BREAK
.ffff50					RHIRQ
.ffff50	c2 30		rep #$30	                REP #$30        ; set A&X long
.ffff52	8b		phb		                PHB
.ffff53	0b		phd		                PHD
.ffff54	48		pha		                PHA
.ffff55	da		phx		                PHX
.ffff56	5a		phy		                PHY
.ffff57	7a		ply		                PLY
.ffff58	fa		plx		                PLX
.ffff59	68		pla		                PLA
.ffff5a	2b		pld		                PLD
.ffff5b	ab		plb		                PLB
.ffff5c	40		rti		                RTI
.ffffe0					ROM_VECTORS
.ffffe0	5c 0c 00 01	jmp $01000c	JUMP_READY      JML READY
>ffffe4	10 ff				RVECTOR_COP     .word $FF10     ; FFE4
>ffffe6	20 ff				RVECTOR_BRK     .word $FF20     ; FFE6
>ffffe8	30 ff				RVECTOR_ABORT   .word $FF30     ; FFE8
>ffffea	40 ff				RVECTOR_NMI     .word $FF40     ; FFEA
>ffffec	00 00				                .word $0000     ; FFEC
>ffffee	50 ff				RVECTOR_IRQ     .word $FF50     ; FFEE
>fffff0	00 00				                .word $0000     ; FFF0
>fffff2	00 00				                .word $0000     ; FFF2
>fffff4	10 ff				RVECTOR_ECOP    .word $FF10     ; FFF4
>fffff6	20 ff				RVECTOR_EBRK    .word $FF20     ; FFF6
>fffff8	30 ff				RVECTOR_EABORT  .word $FF30     ; FFF8
>fffffa	40 ff				RVECTOR_ENMI    .word $FF40     ; FFFA
>fffffc	00 ff				RVECTOR_ERESET  .word $FF00     ; FFFC
>fffffe	50 ff				RVECTOR_EIRQ    .word $FF50     ; FFFE

;******  Return to file: kernel.asm

.010000	5c 00 04 01	jmp $010400	BOOT            JML IBOOT
.010004	5c f2 05 01	jmp $0105f2	RESTORE         JML IRESTORE
.010008	5c 71 04 01	jmp $010471	BREAK           JML IBREAK
.01000c	5c b4 04 01	jmp $0104b4	READY           JML IREADY
.010010	5c f3 05 01	jmp $0105f3	SCINIT          JML ISCINIT
.010014	5c f4 05 01	jmp $0105f4	IOINIT          JML IIOINIT
.010018	5c 30 05 01	jmp $010530	PUTC            JML IPUTC
.01001c	5c 19 05 01	jmp $010519	PUTS            JML IPUTS
.010020	5c 5d 05 01	jmp $01055d	PUTB            JML IPUTB
.010024	5c f5 05 01	jmp $0105f5	PUTBLOCK        JML IPUTBLOCK
.010028	5c f6 05 01	jmp $0105f6	SETLFS          JML ISETLFS
.01002c	5c f7 05 01	jmp $0105f7	SETNAM          JML ISETNAM
.010030	5c f8 05 01	jmp $0105f8	OPEN            JML IOPEN
.010034	5c f9 05 01	jmp $0105f9	CLOSE           JML ICLOSE
.010038	5c fa 05 01	jmp $0105fa	SETIN           JML ISETIN
.01003c	5c fb 05 01	jmp $0105fb	SETOUT          JML ISETOUT
.010040	5c fc 05 01	jmp $0105fc	GETB            JML IGETB
.010044	5c fd 05 01	jmp $0105fd	GETBLOCK        JML IGETBLOCK
.010048	5c fe 05 01	jmp $0105fe	GETCH           JML IGETCH
.01004c	5c df 04 01	jmp $0104df	GETCHW          JML IGETCHW
.010050	5c d6 04 01	jmp $0104d6	GETCHE          JML IGETCHE
.010054	5c ff 05 01	jmp $0105ff	GETS            JML IGETS
.010058	5c 00 06 01	jmp $010600	GETLINE         JML IGETLINE
.01005c	5c 01 06 01	jmp $010601	GETFIELD        JML IGETFIELD
.010060	5c 02 06 01	jmp $010602	TRIM            JML ITRIM
.010064	5c 03 06 01	jmp $010603	PRINTC          JML IPRINTC
.010068	5c 04 06 01	jmp $010604	PRINTS          JML IPRINTS
.01006c	5c 5e 05 01	jmp $01055e	PRINTCR         JML IPRINTCR
.010070	5c 05 06 01	jmp $010605	PRINTF          JML IPRINTF
.010074	5c 06 06 01	jmp $010606	PRINTI          JML IPRINTI
.010078	5c 07 06 01	jmp $010607	PRINTH          JML IPRINTH
.01007c	5c 08 06 01	jmp $010608	PRINTAI         JML IPRINTAI
.010080	5c 09 06 01	jmp $010609	PRINTAH         JML IPRINTAH
.010084	5c ac 05 01	jmp $0105ac	LOCATE          JML ILOCATE
.010088	5c 0a 06 01	jmp $01060a	PUSHKEY         JML IPUSHKEY
.01008c	5c 0b 06 01	jmp $01060b	PUSHKEYS        JML IPUSHKEYS
.010090	5c 7f 05 01	jmp $01057f	CSRRIGHT        JML ICSRRIGHT
.010094	5c 0c 06 01	jmp $01060c	CSRLEFT         JML ICSRLEFT
.010098	5c aa 05 01	jmp $0105aa	CSRUP           JML ICSRUP
.01009c	5c ab 05 01	jmp $0105ab	CSRDOWN         JML ICSRDOWN
.0100a0	5c 0d 06 01	jmp $01060d	CSRHOME         JML ICSRHOME
.0100a4	5c d8 05 01	jmp $0105d8	SCROLLUP        JML ISCROLLUP
.010400					IBOOT
.010400	18		clc		                CLC           ; clear the carry flag
.010401	fb		xce		                XCE           ; move carry to emulation flag.
.010402	c2 30		rep #$30	                REP #$30        ; set A&X long
.010404	a9 ff fe	lda #$feff	                LDA #STACK_END   ; initialize stack pointer
.010407	1b		tcs		                TAS
.010408	48		pha		                PHA             ; begin setdp macro
.010409	08		php			PHP
.01040a	c2 20		rep #$20	                REP #$20        ; set A long
.01040c	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.01040f	5b		tcd		                TCD
.010410	28		plp			PLP
.010411	68		pla		                PLA             ; end setdp macro
.010412	a9 00 10	lda #$1000	                LDA #$1000      ; store the initial screen buffer location
.010415	85 0c		sta $0c		                STA SCREENBEGIN
.010417	e2 20		sep #$20	                SEP #$20        ; set A short
.010419	a9 00		lda #$00	                LDA #$00
.01041b	85 0e		sta $0e		                STA SCREENBEGIN+2
.01041d	c2 30		rep #$30	                REP #$30        ; set A&X long
.01041f	a2 50 00	ldx #$0050	                LDX #80
.010422	86 0f		stx $0f		                STX COLS_VISIBLE
.010424	a0 3c 00	ldy #$003c	                LDY #60
.010427	84 13		sty $13		                STY LINES_VISIBLE
.010429	a2 80 00	ldx #$0080	                LDX #128
.01042c	86 11		stx $11		                STX COLS_PER_LINE
.01042e	a0 40 00	ldy #$0040	                LDY #64
.010431	84 15		sty $15		                STY LINES_MAX
.010433	c2 20		rep #$20	                REP #$20        ; set A long
.010435	a2 00 00	ldx #$0000	                LDX #$0
.010438	a0 00 00	ldy #$0000	                LDY #$0
.01043b	22 ac 05 01	jsl $0105ac	                JSL ILOCATE
.01043f	9c 40 0f	stz $0f40	                STZ KEY_BUFFER_RPOS
.010442	9c 42 0f	stz $0f42	                STZ KEY_BUFFER_WPOS
.010445	c2 30		rep #$30	                REP #$30        ; set A&X long
.010447	a9 ff 00	lda #$00ff	                LDA #$FF
.01044a	a2 00 ff	ldx #$ff00	                LDX #$FF00
.01044d	a0 00 ff	ldy #$ff00	                LDY #$FF00
.010450	44 ff 00	mvp $00,$ff	                MVP $00, $FF
.010453					greet
.010453	48		pha		                PHA             ; begin setdbr macro
.010454	08		php		                PHP
.010455	e2 20		sep #$20	                SEP #$20        ; set A short
.010457	a9 01		lda #$01		LDA #`greet_msg
.010459	48		pha		                PHA
.01045a	ab		plb		                PLB
.01045b	28		plp		                PLP
.01045c	68		pla		                PLA             ; end setdbr macro
.01045d	a2 0e 06	ldx #$060e	                LDX #<>greet_msg
.010460	22 10 05 01	jsl $010510	                JSL IPRINT       ; print the first line
.010464	e2 20		sep #$20	                SEP #$20        ; set A short
.010466	48		pha		                PHA             ; begin setdbr macro
.010467	08		php		                PHP
.010468	e2 20		sep #$20	                SEP #$20        ; set A short
.01046a	a9 01		lda #$01		LDA #$01
.01046c	48		pha		                PHA
.01046d	ab		plb		                PLB
.01046e	28		plp		                PLP
.01046f	68		pla		                PLA             ; end setdbr macro
.010470	00		brk #		greet_done      BRK             ;Terminate boot routine and go to Ready handler.
.010471					IBREAK
.010471	48		pha		                PHA             ; begin setdp macro
.010472	08		php			PHP
.010473	c2 20		rep #$20	                REP #$20        ; set A long
.010475	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.010478	5b		tcd		                TCD
.010479	28		plp			PLP
.01047a	68		pla		                PLA             ; end setdp macro
.01047b	68		pla		                PLA             ; Pull .Y and stuff it in the CPUY variable
.01047c	8f 09 02 00	sta $000209	                STA CPUY
.010480	68		pla		                PLA             ; Pull .X and stuff it in the CPUY variable
.010481	8f 07 02 00	sta $000207	                STA CPUX
.010485	68		pla		                PLA             ; Pull .A and stuff it in the CPUY variable
.010486	8f 05 02 00	sta $000205	                STA CPUA
.01048a	68		pla		                PLA
.01048b	8f 0b 02 00	sta $00020b	                STA CPUDP       ; Pull Direct page
.01048f	e2 20		sep #$20	                SEP #$20        ; set A short
.010491	68		pla		                PLA             ; Pull Data Bank (8 bits)
.010492	8f 03 02 00	sta $000203	                STA CPUDBR
.010496	68		pla		                PLA             ; Pull Flags (8 bits)
.010497	8f 04 02 00	sta $000204	                STA CPUFLAGS
.01049b	c2 20		rep #$20	                REP #$20        ; set A long
.01049d	68		pla		                PLA             ; Pull Program Counter (16 bits)
.01049e	8f 00 02 00	sta $000200	                STA CPUPC
.0104a2	e2 20		sep #$20	                SEP #$20        ; set A short
.0104a4	68		pla		                PLA             ; Pull Program Bank (8 bits)
.0104a5	8f 02 02 00	sta $000202	                STA CPUPBR
.0104a9	c2 20		rep #$20	                REP #$20        ; set A long
.0104ab	3b		tsc		                TSA             ; Get the stack
.0104ac	8f 0d 02 00	sta $00020d	                STA CPUSTACK    ; Store the stack at immediately before the interrupt was asserted
.0104b0	a9 ff fe	lda #$feff	                LDA #<>STACK_END   ; initialize stack pointer back to the bootup value
.0104b3	1b		tcs		                TAS
.0104b4					IREADY
.0104b4	48		pha		                PHA             ; begin setdbr macro
.0104b5	08		php		                PHP
.0104b6	e2 20		sep #$20	                SEP #$20        ; set A short
.0104b8	a9 01		lda #$01		LDA #`ready_msg
.0104ba	48		pha		                PHA
.0104bb	ab		plb		                PLB
.0104bc	28		plp		                PLP
.0104bd	68		pla		                PLA             ; end setdbr macro
.0104be	e2 20		sep #$20	                SEP #$20        ; set A short
.0104c0	a2 73 06	ldx #$0673	                LDX #<>ready_msg
.0104c3	22 10 05 01	jsl $010510	                JSL IPRINT
.0104c7					IREADYWAIT
.0104c7	22 d6 04 01	jsl $0104d6	                JSL IGETCHE
.0104cb	b0 fa		bcs $0104c7	                BCS IREADYWAIT
.0104cd	22 30 05 01	jsl $010530	                JSL IPUTC
.0104d1	4c c7 04	jmp $0104c7	                JMP IREADYWAIT
.0104d4	db		stp		IKEYDOWN        STP             ; Keyboard key pressed
.0104d5	db		stp		IRETURN         STP
.0104d6	22 df 04 01	jsl $0104df	IGETCHE         JSL IGETCHW
.0104da	22 30 05 01	jsl $010530	                JSL IPUTC
.0104de	6b		rtl		                RTL
.0104df	0b		phd		IGETCHW         PHD
.0104e0	da		phx		                PHX
.0104e1	08		php		                PHP
.0104e2	48		pha		                PHA             ; begin setdp macro
.0104e3	08		php			PHP
.0104e4	c2 20		rep #$20	                REP #$20        ; set A long
.0104e6	a9 00 0f	lda #$0f00	                LDA #$0F00         ; set DP to page 0
.0104e9	5b		tcd		                TCD
.0104ea	28		plp			PLP
.0104eb	68		pla		                PLA             ; end setdp macro
.0104ec	c2 30		rep #$30	                REP #$30        ; set A&X long
.0104ee	a6 40		ldx $0f40	igetchw1        LDX KEY_BUFFER_RPOS
.0104f0	e4 42		cpx $0f42	                CPX KEY_BUFFER_WPOS
.0104f2	d0 05		bne $0104f9	                BNE igetchw2
>0104f4	42 00				                .byte $42, $00
.0104f6	4c ee 04	jmp $0104ee	                JMP igetchw1
.0104f9	b5 00		lda $0f00,x	igetchw2        LDA $0,D,X  ; Read the value in the keyboard buffer
.0104fb	48		pha		                PHA
.0104fc	8a		txa		                TXA
.0104fd	18		clc		                CLC
.0104fe	69 02 00	adc #$0002	                ADC #$02
.010501	c9 40 00	cmp #$0040	                CMP #KEY_BUFFER_SIZE
.010504	90 03		bcc $010509	                BCC igetchw3
.010506	a9 00 00	lda #$0000	                LDA #$0
.010509	85 40		sta $0f40	igetchw3        STA KEY_BUFFER_RPOS
.01050b	68		pla		                PLA
.01050c	28		plp		igetchw_done    PLP
.01050d	fa		plx		                PLX             ; Restore the saved registers and return
.01050e	2b		pld		                PLD
.01050f	6b		rtl		                RTL
.010510	22 19 05 01	jsl $010519	IPRINT          JSL IPUTS
.010514	22 5e 05 01	jsl $01055e	                JSL IPRINTCR
.010518	6b		rtl		                RTL
.010519	48		pha		IPUTS           PHA
.01051a	08		php		                PHP
.01051b	e2 20		sep #$20	                SEP #$20        ; set A short
.01051d	c2 10		rep #$10	                REP #$10        ; set X long
.01051f	bd 00 00	lda $010000,x	iputs1          LDA $0,b,x      ; read from the string
.010522	f0 08		beq $01052c	                BEQ iputs_done
.010524	22 30 05 01	jsl $010530	iputs2          JSL IPUTC
.010528	e8		inx		iputs3          INX
.010529	4c 1f 05	jmp $01051f	                JMP iputs1
.01052c	e8		inx		iputs_done      INX
.01052d	28		plp		                PLP
.01052e	68		pla		                PLA
.01052f	6b		rtl		                RTL
.010530	0b		phd		IPUTC           PHD
.010531	08		php		                PHP             ; stash the flags (we'll be changing M)
.010532	48		pha		                PHA             ; begin setdp macro
.010533	08		php			PHP
.010534	c2 20		rep #$20	                REP #$20        ; set A long
.010536	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.010539	5b		tcd		                TCD
.01053a	28		plp			PLP
.01053b	68		pla		                PLA             ; end setdp macro
.01053c	e2 20		sep #$20	                SEP #$20        ; set A short
.01053e	c9 0d		cmp #$0d	                CMP #$0D        ; handle CR
.010540	d0 06		bne $010548	                BNE iputc_bs
.010542	22 5e 05 01	jsl $01055e	                JSL IPRINTCR
.010546	80 10		bra $010558	                bra iputc_done
.010548	c9 08		cmp #$08	iputc_bs        CMP #$08        ; backspace
.01054a	d0 06		bne $010552	                BNE iputc_print
.01054c	22 6f 05 01	jsl $01056f	                JSL IPRINTBS
.010550	80 06		bra $010558	                BRA iputc_done
.010552	87 17		sta [$17]	iputc_print     STA [CURSORPOS] ; Save the character on the screen
.010554	22 7f 05 01	jsl $01057f	                JSL ICSRRIGHT
.010558					iputc_done
>010558	42 01				                .byte $42, $01
.01055a	28		plp		                PLP
.01055b	2b		pld		                PLD
.01055c	6b		rtl		                RTL
.01055d					IPUTB
.01055d	6b		rtl		                RTL
.01055e	da		phx		IPRINTCR	PHX
.01055f	5a		phy		                PHY
.010560	08		php		                PHP
.010561	a2 00 00	ldx #$0000	                LDX #0
.010564	a4 1c		ldy $1c		                LDY CURSORY
.010566	c8		iny		                INY
.010567	22 ac 05 01	jsl $0105ac	                JSL ILOCATE
.01056b	28		plp		                PLP
.01056c	7a		ply		                PLY
.01056d	fa		plx		                PLX
.01056e	6b		rtl		                RTL
.01056f	da		phx		IPRINTBS	PHX
.010570	5a		phy		                PHY
.010571	08		php		                PHP
.010572	a6 1a		ldx $1a		                LDX CURSORX
.010574	a4 1c		ldy $1c		                LDY CURSORY
.010576	ca		dex		                DEX
.010577	22 ac 05 01	jsl $0105ac	                JSL ILOCATE
.01057b	28		plp		                PLP
.01057c	7a		ply		                PLY
.01057d	fa		plx		                PLX
.01057e	6b		rtl		                RTL
.01057f					ICSRRIGHT
.01057f	da		phx		                PHX
.010580	8b		phb		                PHB
.010581	c2 20		rep #$20	                REP #$20        ; set A long
.010583	c2 10		rep #$10	                REP #$10        ; set X long
.010585	48		pha		                PHA             ; begin setdp macro
.010586	08		php			PHP
.010587	c2 20		rep #$20	                REP #$20        ; set A long
.010589	a9 00 00	lda #$0000	                LDA #$0         ; set DP to page 0
.01058c	5b		tcd		                TCD
.01058d	28		plp			PLP
.01058e	68		pla		                PLA             ; end setdp macro
.01058f	e6 17		inc $17		                INC CURSORPOS
.010591	a6 1a		ldx $1a		                LDX CURSORX
.010593	e8		inx		                INX
.010594	e4 0f		cpx $0f		                CPX COLS_VISIBLE
.010596	90 0c		bcc $0105a4	                BCC icsr_nowrap  ; wrap if the cursor is at or past column 80
.010598	a2 00 00	ldx #$0000	                LDX #0
.01059b	5a		phy		                PHY
.01059c	a4 1c		ldy $1c		                LDY CURSORY
.01059e	c8		iny		                INY
.01059f	22 ac 05 01	jsl $0105ac	                JSL ILOCATE
.0105a3	7a		ply		                PLY
.0105a4	86 1a		stx $1a		icsr_nowrap     STX CURSORX
.0105a6	ab		plb		                PLB
.0105a7	fa		plx		                PLX
.0105a8	6b		rtl		                RTL
.0105a9	6b		rtl		ISRLEFT	RTL
.0105aa	6b		rtl		ICSRUP	RTL
.0105ab	6b		rtl		ICSRDOWN	RTL
.0105ac	48		pha		ILOCATE         PHA
.0105ad	08		php		                PHP
.0105ae	c2 30		rep #$30	                REP #$30        ; set A&X long
.0105b0					ilocate_scroll
.0105b0	c4 13		cpy $13		                CPY LINES_VISIBLE
.0105b2	90 07		bcc $0105bb	                BCC ilocate_scrolldone
.0105b4	22 d8 05 01	jsl $0105d8	                JSL ISCROLLUP
.0105b8	88		dey		                DEY
.0105b9	80 f5		bra $0105b0	                BRA ilocate_scroll
.0105bb					ilocate_scrolldone
.0105bb	86 1a		stx $1a		                STX CURSORX
.0105bd	84 1c		sty $1c		                STY CURSORY
.0105bf	a5 0c		lda $0c		                LDA SCREENBEGIN
.0105c1					ilocate_row
.0105c1	c0 00 00	cpy #$0000	                CPY #$0
.0105c4	f0 08		beq $0105ce	                BEQ ilocate_right
.0105c6	18		clc		ilocate_down    CLC
.0105c7	65 11		adc $11		                ADC COLS_PER_LINE
.0105c9	88		dey		                DEY
.0105ca	f0 02		beq $0105ce	                BEQ ilocate_right
.0105cc	80 f8		bra $0105c6	                BRA ilocate_down
.0105ce	18		clc		ilocate_right   CLC
.0105cf	65 1a		adc $1a		                ADC CURSORX             ; move the cursor right X columns
.0105d1	85 17		sta $17		                STA CURSORPOS
.0105d3	a4 1c		ldy $1c		                LDY CURSORY
.0105d5	28		plp		ilocate_done    PLP
.0105d6	68		pla		                PLA
.0105d7	6b		rtl		                RTL
.0105d8					ISCROLLUP
.0105d8	48		pha		                PHA
.0105d9	da		phx		                PHX
.0105da	5a		phy		                PHY
.0105db	8b		phb		                PHB
.0105dc	08		php		                PHP
.0105dd	c2 30		rep #$30	                REP #$30        ; set A&X long
.0105df	18		clc		                CLC
.0105e0	a5 0c		lda $0c		                LDA SCREENBEGIN
.0105e2	a8		tay		                TAY             ; Destination is first row
.0105e3	65 11		adc $11		                ADC COLS_PER_LINE
.0105e5	aa		tax		                TAX             ; Source is second row
.0105e6	a9 ef 1f	lda #$1fef	                LDA #SCREEN_PAGE1-SCREEN_PAGE0-COLS_PER_LINE
.0105e9	44 00 00	mvp $00,$00	                MVP $00,$00
.0105ec	28		plp		                PLP
.0105ed	ab		plb		                PLB
.0105ee	7a		ply		                PLY
.0105ef	fa		plx		                PLX
.0105f0	68		pla		                PLA
.0105f1	6b		rtl		                RTL
.0105f2	00		brk #		IRESTORE        BRK ; Warm boot routine
.0105f3	00		brk #		ISCINIT         BRK ;
.0105f4	00		brk #		IIOINIT         BRK ;
.0105f5	00		brk #		IPUTBLOCK       BRK ; Ouput a binary block to the currently selected channel
.0105f6	00		brk #		ISETLFS         BRK ; Obsolete (done in OPEN)
.0105f7	00		brk #		ISETNAM         BRK ; Obsolete (done in OPEN)
.0105f8	00		brk #		IOPEN           BRK ; Open a channel for reading and/or writing. Use SETLFS and SETNAM to set the channels and filename first.
.0105f9	00		brk #		ICLOSE          BRK ; Close a channel
.0105fa	00		brk #		ISETIN          BRK ; Set the current input channel
.0105fb	00		brk #		ISETOUT         BRK ; Set the current output channel
.0105fc	00		brk #		IGETB           BRK ; Get a byte from input channel. Return 0 if no input. Carry is set if no input.
.0105fd	00		brk #		IGETBLOCK       BRK ; Get a X byes from input channel. If Carry is set, wait. If Carry is clear, do not wait.
.0105fe	00		brk #		IGETCH          BRK ; Get a character from the input channel. A=0 and Carry=1 if no data is wating
.0105ff	00		brk #		IGETS           BRK ; Get a string from the input channel. NULL terminates
.010600	00		brk #		IGETLINE        BRK ; Get a line of text from input channel. CR or NULL terminates.
.010601	00		brk #		IGETFIELD       BRK ; Get a field from the input channel. Value in A, CR, or NULL terminates
.010602	00		brk #		ITRIM           BRK ; Removes spaces at beginning and end of string.
.010603	00		brk #		IPRINTC         BRK ; Print character to screen. Handles terminal commands
.010604	00		brk #		IPRINTS         BRK ; Print string to screen. Handles terminal commands
.010605	00		brk #		IPRINTF         BRK ; Print a float value
.010606	00		brk #		IPRINTI         BRK ; Prints integer value in TEMP
.010607	00		brk #		IPRINTH         BRK ; Print Hex value in DP variable
.010608	00		brk #		IPRINTAI        BRK ; Prints integer value in A
.010609	00		brk #		IPRINTAH        BRK ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
.01060a	00		brk #		IPUSHKEY        BRK ;
.01060b	00		brk #		IPUSHKEYS       BRK ;
.01060c	00		brk #		ICSRLEFT        BRK ;
.01060d	00		brk #		ICSRHOME        BRK ;
.01060e					KERNEL_DATA
>01060e	20 20 2f 2f 2f 2f 2f 20		greet_msg       .text "  ///// FOENIX 256 DEVELOPMENT SYSTEM",$0D
>010616	46 4f 45 4e 49 58 20 32 35 36 20 44 45 56 45 4c
>010626	4f 50 4d 45 4e 54 20 53 59 53 54 45 4d 0d
>010634	20 2f 2f 2f 2f 2f 20 20		greet_msg1      .text " /////  OPEN SOURCE COMPUTER",$0D
>01063c	4f 50 45 4e 20 53 4f 55 52 43 45 20 43 4f 4d 50
>01064c	55 54 45 52 0d
>010651	2f 2f 2f 2f 2f 20 20 20		greet_msg2      .null "/////   8192KB SYSTEM 8128KB FREE"
>010659	38 31 39 32 4b 42 20 53 59 53 54 45 4d 20 38 31
>010669	32 38 4b 42 20 46 52 45 45 00
>010673	0d 52 45 41 44 59 2e 00		ready_msg       .null $0D,"READY."
>01067b	31 30 20 50 52 49 4e 54		hello_basic     .null "10 PRINT ""Hello World""",$0D
>010683	20 22 48 65 6c 6c 6f 20 57 6f 72 6c 64 22 0d 00
>010693	52 55 4e 0d 00			                .null "RUN",$0D
>010698	48 65 6c 6c 6f 20 57 6f		                .null "Hello World",$0D
>0106a0	72 6c 64 0d 00
>0106a5	0d 52 45 41 44 59 2e 00		                .null $0D,"READY."
>0106ad	47 20 30 32 30 30 30 30		hello_ml        .null "G 020000",$0D
>0106b5	0d 00
>0106b7	48 45 4c 4c 4f 20 57 4f		                .null "HELLO WORLD",$0D
>0106bf	52 4c 44 0d 00
>0106c4	0d 00				                .null $0D
>0106c6	20 50 43 20 20 20 20 20		                .null " PC     A    X    Y    SP   DBR DP   NVMXDIZC",$0D
>0106ce	41 20 20 20 20 58 20 20 20 20 59 20 20 20 20 53
>0106de	50 20 20 20 44 42 52 20 44 50 20 20 20 4e 56 4d
>0106ee	58 44 49 5a 43 0d 00
>0106f5	3b 30 30 32 31 31 32 20		                .null ";002112 0019 F0AA 0000 D6FF F8  0000 --M-----"
>0106fd	30 30 31 39 20 46 30 41 41 20 30 30 30 30 20 44
>01070d	36 46 46 20 46 38 20 20 30 30 30 30 20 2d 2d 4d
>01071d	2d 2d 2d 2d 2d 00
>010723	41 42 4f 52 54 20 45 52		error_01        .null "ABORT ERROR"
>01072b	52 4f 52 00

;******  End of listing
