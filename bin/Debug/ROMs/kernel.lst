
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass --long-address --intel-hex -o kernel.hex --list kernel.lst boot_test.asm
; Tue Sep 18 19:56:13 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: boot_test.asm


;******  Processing file: page_00_inc.asm

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				RESET            = $000000 ;4 Bytes Jumps to the beginning of kernel ROM. ($F8:0000).
=$000004				RETURN           = $000004 ;4 Bytes Called when the RETURN key is pressed in the immediate mode screen. This will process a command in MONITOR, execute a BASIC command, or add a BASIC program line.
=$000008				KEYDOWN          = $000008 ;4 Bytes Custom keyboard handler. This defaults to the kernel keypress handler, but you can redirect this to your own routines. Make sure to JML to the original address at the end of your custom routine. Use this to make F-Key macros or custom keyboard commands.
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;2 Bytes Color of next character to be printed to the screen.
=$000020				CURATTR          = $000020 ;2 Bytes Attribute of next character to be printed to the screen.
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$0000c0				KERNEL_TEMP      = $0000C0 ;32 Bytes Temp space for kernel
=$0000e0				USER_TEMP        = $0000E0 ;32 Bytes Temp space for user programs
=$000100				PAGE0_END_       = $000100 ; Byte
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000108				DIVIDER_0        = $000108 ;0 Byte  Unsigned divider
=$000108				D0_OPERAND_A     = $000108 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$00010a				D0_OPERAND_B     = $00010A ;2 Bytes Divider 0 Divisor ex B in A/B
=$00010c				D0_RESULT        = $00010C ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$00010e				D0_REMAINDER     = $00010E ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000110				DIVIDER_1        = $000110 ;0 Byte  Signed divider
=$000110				D1_OPERAND_A     = $000110 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$000112				D1_OPERAND_B     = $000112 ;2 Bytes Divider 1 Divisor ex B in A/B
=$000114				D1_RESULT        = $000114 ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D1_REMAINDER     = $000116 ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$0001ff				VECTOR_STATE     = $0001FF ;1 Byte  Interrupt Vector State. See VECTOR_STATE_ENUM
=$000200				CPU_REGISTERS    = $000200 ; Byte
=$000200				CPUPC            = $000200 ;2 Bytes Debug registers. When BRK is executed, Interrupt service routine will populate this block with the CPU registers.
=$000202				CPUPBR           = $000202 ;1 Byte  Program Bank Register (K)
=$000203				CPUDBR           = $000203 ;1 Byte  Data Bank Register (B)
=$000204				CPUFLAGS         = $000204 ;1 Byte  Flags (P) (The second byte is ignored)
=$000205				CPUA             = $000205 ;2 Bytes Accumulator (A)
=$000207				CPUX             = $000207 ;2 Bytes X Register
=$000209				CPUY             = $000209 ;2 Bytes Y Index Register
=$00020b				CPUDP            = $00020B ;2 Bytes Direct Page Register (D)
=$00020d				CPUSTACK         = $00020D ;2 Bytes Stack Pointer
=$000210				MONITOR_VARS     = $000210 ; Byte  MONITOR Variables. BASIC variables may overlap this space
=$000210				MCMDADDR         = $000210 ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$000213				MCMP_TEXT        = $000213 ;3 Bytes Address of symbol being evaluated for COMPARE routine
=$000216				MCMP_LEN         = $000216 ;2 Bytes Length of symbol being evaluated for COMPARE routine
=$000218				MCMD             = $000218 ;3 Bytes Address of the current command/function string
=$00021b				MCMD_LEN         = $00021B ;2 Bytes Length of the current command/function string
=$00021d				MARG1            = $00021D ;4 Bytes First command argument. May be data or address, depending on command
=$000221				MARG2            = $000221 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000225				MARG3            = $000225 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000229				MARG4            = $000229 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$00022d				MARG5            = $00022D ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000231				MARG6            = $000231 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000235				MARG7            = $000235 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000239				MARG8            = $000239 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$00f00					KEY_BUFFER       = $00F00 ;64 Bytes KEY_BUFFER
=$40					KEY_BUFFER_SIZE  = $40 ;64 Bytes KEY_BUFFER_SIZE
=$000f3f				KEY_BUFFER_END   = $000F3F ;1 Byte  KEY_BUFFER_END
=$000f40				KEY_BUFFER_RPOS  = $000F40 ;2 Bytes KEY_BUFFER_RPOS
=$000f42				KEY_BUFFER_WPOS  = $000F42 ;2 Bytes KEY_BUFFER_WPOS
=$001000				TEST_BEGIN       = $001000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ff00				ISR_BEGIN        = $00FF00 ; Byte  Beginning of CPU vectors in Direct page
=$00ff00				HRESET           = $00FF00 ;16 Bytes Handle RESET asserted. Reboot computer and re-initialize the kernel.
=$00ff10				HCOP             = $00FF10 ;16 Bytes Handle the COP instruction. Program use; not used by OS
=$00ff20				HBRK             = $00FF20 ;16 Bytes Handle the BRK instruction. Returns to BASIC Ready prompt.
=$00ff30				HABORT           = $00FF30 ;16 Bytes Handle ABORT asserted. Return to Ready prompt with an error message.
=$00ff40				HNMI             = $00FF40 ;32 Bytes Handle NMI
=$00ff60				HIRQ             = $00FF60 ;32 Bytes Handle IRQ
=$00ff80				ISR_END          = $00FF80 ;End of direct page Interrrupt handlers
=$00ffe0				VECTORS_BEGIN    = $00FFE0 ;0 Byte  Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$00ffe0				JMP_READY        = $00FFE0 ;4 Bytes Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$00ffe4				VECTOR_COP       = $00FFE4 ;2 Bytes Native COP Interrupt vector
=$00ffe6				VECTOR_BRK       = $00FFE6 ;2 Bytes Native BRK Interrupt vector
=$00ffe8				VECTOR_ABORT     = $00FFE8 ;2 Bytes Native ABORT Interrupt vector
=$00ffea				VECTOR_NMI       = $00FFEA ;2 Bytes Native NMI Interrupt vector
=$00ffec				VECTOR_RESET     = $00FFEC ;2 Bytes Unused (Native RESET vector)
=$00ffee				VECTOR_IRQ       = $00FFEE ;2 Bytes Native IRQ Vector
=$00fff4				VECTOR_ECOP      = $00FFF4 ;2 Bytes Emulation mode interrupt handler
=$00fff6				VECTOR_EBRK      = $00FFF6 ;2 Bytes Emulation mode interrupt handler
=$00fff8				VECTOR_EABORT    = $00FFF8 ;2 Bytes Emulation mode interrupt handler
=$00fffa				VECTOR_ENMI      = $00FFFA ;2 Bytes Emulation mode interrupt handler
=$00fffc				VECTOR_ERESET    = $00FFFC ;2 Bytes Emulation mode interrupt handler
=$00fffe				VECTOR_EIRQ      = $00FFFE ;2 Bytes Emulation mode interrupt handler
=$010000				VECTORS_END      = $010000 ;*End of vector space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: boot_test.asm


;******  Processing file: page_00.asm

.0000	5c 00 10 00	jmp $001000	                JML IBOOT           ; RESET           Jumps to the beginning of kernel ROM. ($F8:0000).
.0004	5c da 10 00	jmp $0010da	                JML IRETURN         ; RETURN          Called when the RETURN key is pressed in the immediate mode screen. This will process a command in MONITOR, execute a BASIC command, or add a BASIC program line.
.0008	5c 08 00 00	jmp $000008	                JML KEYDOWN         ; KEYDOWN         Custom keyboard handler. This defaults to the kernel keypress handler, but you can redirect this to your own routines. Make sure to JML to the original address at the end of your custom routine. Use this to make F-Key macros or custom keyboard commands.
>000c	00 10 80			                .long $801000       ; SCREENBEGIN     Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
>000f	50 00				                .word 80            ; COLS_VISIBLE    Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
>0011	80 00				                .word 128           ; COLS_PER_LINE   Columns in memory per screen line. A virtual line can be this long. Default=128
>0013	3c 00				                .word 60            ; LINES_VISIBLE   The number of rows visible on the screen. Default=25
>0015	40 00				                .word 64            ; LINES_MAX       The number of rows in memory for the screen. Default=64
>0017	00 00				                .word 0             ; CURSORPOS       The next character written to the screen will be written in this location.
>0019	00 00				                .word 0             ; CURSORX         This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
>001b	00 00				                .word 0             ; CURSORY         This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
>001d	0f				                .byte $0F           ; CURCOLOR        Color of next character to be printed to the screen.
>001e	00				                .byte $00           ; CURATTR         Attribute of next character to be printed to the screen.
>001f	ff fe				                .word STACK_END     ; STACKBOT        Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
>0021	00 80				                .word STACK_BEGIN   ; STACKTOP        Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.

;******  Return to file: boot_test.asm


;******  Processing file: dram_inc.asm

=$800000				SCREEN_PAGE0     = $800000 ;8192 Bytes First page of display RAM. This is used at boot time to display the welcome screen and the BASIC or MONITOR command screens.
=$802000				SCREEN_PAGE1     = $802000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$804000				SCREEN_PAGE2     = $804000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$806000				SCREEN_PAGE3     = $806000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$808000				SCREEN_END       = $808000 ;End of display memory

;******  Return to file: boot_test.asm


;******  Processing file: macros_inc.asm


;******  Return to file: boot_test.asm


;******  Processing file: simulator_inc.asm


;******  Return to file: boot_test.asm

.1000					IBOOT
.1000	18		clc		                CLC           ; clear the carry flag
.1001	fb		xce		                XCE           ; move carry to emulation flag.
.1002	c2 30		rep #$30	                REP #$30        ; set A&X long
.1004	a9 ff fe	lda #$feff	                LDA #STACK_END   ; initialize stack pointer
.1007	1b		tcs		                TAS
.1008	48		pha		                PHA             ; begin setdp macro
.1009	08		php			PHP
.100a	c2 20		rep #$20	                REP #$20        ; set A long
.100c	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.100f	5b		tcd		                TCD
.1010	28		plp			PLP
.1011	68		pla		                PLA             ; end setdp macro
.1012	a9 00 00	lda #$0000	                LDA #$0000      ; store the initial screen buffer location
.1015	85 0c		sta $0c		                STA SCREENBEGIN
.1017	e2 20		sep #$20	                SEP #$20        ; set A short
.1019	a9 80		lda #$80	                LDA #$80
.101b	85 0e		sta $0e		                STA SCREENBEGIN+2
.101d	c2 30		rep #$30	                REP #$30        ; set A&X long
.101f	a5 0c		lda $0c		                LDA SCREENBEGIN ; store the initial cursor position
.1021	85 17		sta $17		                STA CURSORPOS
.1023	e2 20		sep #$20	                SEP #$20        ; set A short
.1025	a5 0e		lda $0e		                LDA SCREENBEGIN+2
.1027	85 19		sta $19		                STA CURSORPOS+2
.1029	c2 30		rep #$30	                REP #$30        ; set A&X long
.102b	a2 50 00	ldx #$0050	                LDX #80
.102e	86 0f		stx $0f		                STX COLS_VISIBLE
.1030	a0 3c 00	ldy #$003c	                LDY #60
.1033	84 13		sty $13		                STY LINES_VISIBLE
.1035	a2 80 00	ldx #$0080	                LDX #128
.1038	86 11		stx $11		                STX COLS_PER_LINE
.103a	a0 40 00	ldy #$0040	                LDY #64
.103d	84 15		sty $15		                STY LINES_MAX
.103f	c2 20		rep #$20	                REP #$20        ; set A long
.1041	a2 00 00	ldx #$0000	                LDX #$0
.1044	a0 00 00	ldy #$0000	                LDY #$0
.1047	22 b1 11 00	jsl $0011b1	                JSL ILOCATE
.104b	9c 40 0f	stz $0f40	                STZ KEY_BUFFER_RPOS
.104e	9c 42 0f	stz $0f42	                STZ KEY_BUFFER_WPOS
.1051					greet
.1051	48		pha		                PHA             ; begin setdbr macro
.1052	08		php		                PHP
.1053	e2 20		sep #$20	                SEP #$20        ; set A short
.1055	a9 00		lda #$00		LDA #`greet_msg
.1057	48		pha		                PHA
.1058	ab		plb		                PLB
.1059	28		plp		                PLP
.105a	68		pla		                PLA             ; end setdbr macro
.105b	a2 13 12	ldx #$1213	                LDX #<>greet_msg
.105e	22 15 11 00	jsl $001115	                JSL IPRINT       ; print the first line
.1062	e2 20		sep #$20	                SEP #$20        ; set A short
.1064	48		pha		                PHA             ; begin setdbr macro
.1065	08		php		                PHP
.1066	e2 20		sep #$20	                SEP #$20        ; set A short
.1068	a9 01		lda #$01		LDA #$01
.106a	48		pha		                PHA
.106b	ab		plb		                PLB
.106c	28		plp		                PLP
.106d	68		pla		                PLA             ; end setdbr macro
.106e	00		brk #		greet_done      BRK             ;Terminate boot routine and go to Ready handler.
.106f					IBREAK
.106f	48		pha		                PHA             ; begin setdp macro
.1070	08		php			PHP
.1071	c2 20		rep #$20	                REP #$20        ; set A long
.1073	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.1076	5b		tcd		                TCD
.1077	28		plp			PLP
.1078	68		pla		                PLA             ; end setdp macro
.1079	68		pla		                PLA             ; Pull .Y and stuff it in the CPUY variable
.107a	8f 09 02 00	sta $000209	                STA CPUY
.107e	68		pla		                PLA             ; Pull .X and stuff it in the CPUY variable
.107f	8f 07 02 00	sta $000207	                STA CPUX
.1083	68		pla		                PLA             ; Pull .A and stuff it in the CPUY variable
.1084	8f 05 02 00	sta $000205	                STA CPUA
.1088	68		pla		                PLA
.1089	8f 0b 02 00	sta $00020b	                STA CPUDP       ; Pull Direct page
.108d	e2 20		sep #$20	                SEP #$20        ; set A short
.108f	68		pla		                PLA             ; Pull Data Bank (8 bits)
.1090	8f 03 02 00	sta $000203	                STA CPUDBR
.1094	68		pla		                PLA             ; Pull Flags (8 bits)
.1095	8f 04 02 00	sta $000204	                STA CPUFLAGS
.1099	c2 20		rep #$20	                REP #$20        ; set A long
.109b	68		pla		                PLA             ; Pull Program Counter (16 bits)
.109c	8f 00 02 00	sta $000200	                STA CPUPC
.10a0	e2 20		sep #$20	                SEP #$20        ; set A short
.10a2	68		pla		                PLA             ; Pull Program Bank (8 bits)
.10a3	8f 02 02 00	sta $000202	                STA CPUPBR
.10a7	c2 20		rep #$20	                REP #$20        ; set A long
.10a9	3b		tsc		                TSA             ; Get the stack
.10aa	8f 0d 02 00	sta $00020d	                STA CPUSTACK    ; Store the stack at immediately before the interrupt was asserted
.10ae	a9 ff fe	lda #$feff	                LDA #<>STACK_END   ; initialize stack pointer back to the bootup value
.10b1	1b		tcs		                TAS
.10b2	a9 0d 00	lda #$000d	IREADY          LDA #13
.10b5	22 35 11 00	jsl $001135	                JSL IPUTC
.10b9	48		pha		                PHA             ; begin setdbr macro
.10ba	08		php		                PHP
.10bb	e2 20		sep #$20	                SEP #$20        ; set A short
.10bd	a9 00		lda #$00		LDA #`ready_msg
.10bf	48		pha		                PHA
.10c0	ab		plb		                PLB
.10c1	28		plp		                PLP
.10c2	68		pla		                PLA             ; end setdbr macro
.10c3	e2 20		sep #$20	                SEP #$20        ; set A short
.10c5	a2 72 12	ldx #$1272	                LDX #<>ready_msg
.10c8	22 15 11 00	jsl $001115	                JSL IPRINT
.10cc					IREADYWAIT
.10cc	22 db 10 00	jsl $0010db	                JSL IGETCHE
.10d0	b0 fa		bcs $10cc	                BCS IREADYWAIT
.10d2	22 35 11 00	jsl $001135	                JSL IPUTC
.10d6	4c cc 10	jmp $10cc	                JMP IREADYWAIT
.10d9	db		stp		IKEYDOWN        STP             ; Keyboard key pressed
.10da	db		stp		IRETURN         STP
.10db	22 e4 10 00	jsl $0010e4	IGETCHE         JSL IGETCHW
.10df	22 35 11 00	jsl $001135	                JSL IPUTC
.10e3	6b		rtl		                RTL
.10e4	0b		phd		IGETCHW         PHD
.10e5	da		phx		                PHX
.10e6	08		php		                PHP
.10e7	48		pha		                PHA             ; begin setdp macro
.10e8	08		php			PHP
.10e9	c2 20		rep #$20	                REP #$20        ; set A long
.10eb	a9 00 0f	lda #$0f00	                LDA #$0F00         ; set DP to page 0
.10ee	5b		tcd		                TCD
.10ef	28		plp			PLP
.10f0	68		pla		                PLA             ; end setdp macro
.10f1	c2 30		rep #$30	                REP #$30        ; set A&X long
.10f3	a6 40		ldx $0f40	igetchw1        LDX KEY_BUFFER_RPOS
.10f5	e4 42		cpx $0f42	                CPX KEY_BUFFER_WPOS
.10f7	d0 05		bne $10fe	                BNE igetchw2
>10f9	42 00				                .byte $42, $00
.10fb	4c f3 10	jmp $10f3	                JMP igetchw1
.10fe	b5 00		lda $0f00,x	igetchw2        LDA $0,D,X  ; Read the value in the keyboard buffer
.1100	48		pha		                PHA
.1101	8a		txa		                TXA
.1102	18		clc		                CLC
.1103	69 02 00	adc #$0002	                ADC #$02
.1106	c9 40 00	cmp #$0040	                CMP #KEY_BUFFER_SIZE
.1109	90 03		bcc $110e	                BCC igetchw3
.110b	a9 00 00	lda #$0000	                LDA #$0
.110e	85 40		sta $0f40	igetchw3        STA KEY_BUFFER_RPOS
.1110	68		pla		                PLA
.1111	28		plp		igetchw_done    PLP
.1112	fa		plx		                PLX             ; Restore the saved registers and return
.1113	2b		pld		                PLD
.1114	6b		rtl		                RTL
.1115	22 1e 11 00	jsl $00111e	IPRINT          JSL IPUTS
.1119	22 63 11 00	jsl $001163	                JSL IPRINTCR
.111d	6b		rtl		                RTL
.111e	48		pha		IPUTS           PHA
.111f	08		php		                PHP
.1120	e2 20		sep #$20	                SEP #$20        ; set A short
.1122	c2 10		rep #$10	                REP #$10        ; set X long
.1124	bd 00 00	lda $0000,x	iputs1          LDA $0,b,x      ; read from the string
.1127	f0 08		beq $1131	                BEQ iputs_done
.1129	22 35 11 00	jsl $001135	iputs2          JSL IPUTC
.112d	e8		inx		iputs3          INX
.112e	4c 24 11	jmp $1124	                JMP iputs1
.1131	e8		inx		iputs_done      INX
.1132	28		plp		                PLP
.1133	68		pla		                PLA
.1134	6b		rtl		                RTL
.1135	0b		phd		IPUTC           PHD
.1136	08		php		                PHP             ; stash the flags (we'll be changing M)
.1137	48		pha		                PHA             ; begin setdp macro
.1138	08		php			PHP
.1139	c2 20		rep #$20	                REP #$20        ; set A long
.113b	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.113e	5b		tcd		                TCD
.113f	28		plp			PLP
.1140	68		pla		                PLA             ; end setdp macro
.1141	e2 20		sep #$20	                SEP #$20        ; set A short
.1143	c9 0d		cmp #$0d	                CMP #$0D        ; handle CR
.1145	d0 06		bne $114d	                BNE iputc_bs
.1147	22 63 11 00	jsl $001163	                JSL IPRINTCR
.114b	80 10		bra $115d	                bra iputc_done
.114d	c9 08		cmp #$08	iputc_bs        CMP #$08        ; backspace
.114f	d0 06		bne $1157	                BNE iputc_print
.1151	22 74 11 00	jsl $001174	                JSL IPRINTBS
.1155	80 06		bra $115d	                BRA iputc_done
.1157	87 17		sta [$17]	iputc_print     STA [CURSORPOS] ; Save the character on the screen
.1159	22 84 11 00	jsl $001184	                JSL ICSRRIGHT
.115d					iputc_done
>115d	42 01				                .byte $42, $01
.115f	28		plp		                PLP
.1160	2b		pld		                PLD
.1161	6b		rtl		                RTL
.1162					IPUTB
.1162	6b		rtl		                RTL
.1163	da		phx		IPRINTCR	PHX
.1164	5a		phy		                PHY
.1165	08		php		                PHP
.1166	a2 00 00	ldx #$0000	                LDX #0
.1169	a4 1c		ldy $1c		                LDY CURSORY
.116b	c8		iny		                INY
.116c	22 b1 11 00	jsl $0011b1	                JSL ILOCATE
.1170	28		plp		                PLP
.1171	7a		ply		                PLY
.1172	fa		plx		                PLX
.1173	6b		rtl		                RTL
.1174	da		phx		IPRINTBS	PHX
.1175	5a		phy		                PHY
.1176	08		php		                PHP
.1177	a6 1a		ldx $1a		                LDX CURSORX
.1179	a4 1c		ldy $1c		                LDY CURSORY
.117b	ca		dex		                DEX
.117c	22 b1 11 00	jsl $0011b1	                JSL ILOCATE
.1180	28		plp		                PLP
.1181	7a		ply		                PLY
.1182	fa		plx		                PLX
.1183	6b		rtl		                RTL
.1184					ICSRRIGHT
.1184	da		phx		                PHX
.1185	8b		phb		                PHB
.1186	c2 20		rep #$20	                REP #$20        ; set A long
.1188	c2 10		rep #$10	                REP #$10        ; set X long
.118a	48		pha		                PHA             ; begin setdp macro
.118b	08		php			PHP
.118c	c2 20		rep #$20	                REP #$20        ; set A long
.118e	a9 00 00	lda #$0000	                LDA #$0         ; set DP to page 0
.1191	5b		tcd		                TCD
.1192	28		plp			PLP
.1193	68		pla		                PLA             ; end setdp macro
.1194	e6 17		inc $17		                INC CURSORPOS
.1196	a6 1a		ldx $1a		                LDX CURSORX
.1198	e8		inx		                INX
.1199	e4 0f		cpx $0f		                CPX COLS_VISIBLE
.119b	90 0c		bcc $11a9	                BCC icsr_nowrap  ; wrap if the cursor is at or past column 80
.119d	a2 00 00	ldx #$0000	                LDX #0
.11a0	5a		phy		                PHY
.11a1	a4 1c		ldy $1c		                LDY CURSORY
.11a3	c8		iny		                INY
.11a4	22 b1 11 00	jsl $0011b1	                JSL ILOCATE
.11a8	7a		ply		                PLY
.11a9	86 1a		stx $1a		icsr_nowrap     STX CURSORX
.11ab	ab		plb		                PLB
.11ac	fa		plx		                PLX
.11ad	6b		rtl		                RTL
.11ae	6b		rtl		ISRLEFT	RTL
.11af	6b		rtl		ICSRUP	RTL
.11b0	6b		rtl		ICSRDOWN	RTL
.11b1	48		pha		ILOCATE         PHA
.11b2	08		php		                PHP
.11b3	c2 30		rep #$30	                REP #$30        ; set A&X long
.11b5					ilocate_scroll
.11b5	c4 13		cpy $13		                CPY LINES_VISIBLE
.11b7	90 07		bcc $11c0	                BCC ilocate_scrolldone
.11b9	22 dd 11 00	jsl $0011dd	                JSL ISCROLLUP
.11bd	88		dey		                DEY
.11be	80 f5		bra $11b5	                BRA ilocate_scroll
.11c0					ilocate_scrolldone
.11c0	86 1a		stx $1a		                STX CURSORX
.11c2	84 1c		sty $1c		                STY CURSORY
.11c4	a5 0c		lda $0c		                LDA SCREENBEGIN
.11c6					ilocate_row
.11c6	c0 00 00	cpy #$0000	                CPY #$0
.11c9	f0 08		beq $11d3	                BEQ ilocate_right
.11cb	18		clc		ilocate_down    CLC
.11cc	65 11		adc $11		                ADC COLS_PER_LINE
.11ce	88		dey		                DEY
.11cf	f0 02		beq $11d3	                BEQ ilocate_right
.11d1	80 f8		bra $11cb	                BRA ilocate_down
.11d3	18		clc		ilocate_right   CLC
.11d4	65 1a		adc $1a		                ADC CURSORX             ; move the cursor right X columns
.11d6	85 17		sta $17		                STA CURSORPOS
.11d8	a4 1c		ldy $1c		                LDY CURSORY
.11da	28		plp		ilocate_done    PLP
.11db	68		pla		                PLA
.11dc	6b		rtl		                RTL
.11dd					ISCROLLUP
.11dd	48		pha		                PHA
.11de	da		phx		                PHX
.11df	5a		phy		                PHY
.11e0	8b		phb		                PHB
.11e1	08		php		                PHP
.11e2	c2 30		rep #$30	                REP #$30        ; set A&X long
.11e4	18		clc		                CLC
.11e5	a5 0c		lda $0c		                LDA SCREENBEGIN
.11e7	a8		tay		                TAY             ; Destination is first row
.11e8	65 11		adc $11		                ADC COLS_PER_LINE
.11ea	aa		tax		                TAX             ; Source is second row
.11eb	a9 ef 1f	lda #$1fef	                LDA #SCREEN_PAGE1-SCREEN_PAGE0-COLS_PER_LINE
.11ee	44 00 00	mvp $00,$00	                MVP $00,$00
.11f1	28		plp		                PLP
.11f2	ab		plb		                PLB
.11f3	7a		ply		                PLY
.11f4	fa		plx		                PLX
.11f5	68		pla		                PLA
.11f6	6b		rtl		                RTL
.11f7	00		brk #		IRESTORE        BRK ; Warm boot routine
.11f8	00		brk #		ISCINIT         BRK ;
.11f9	00		brk #		IIOINIT         BRK ;
.11fa	00		brk #		IPUTBLOCK       BRK ; Ouput a binary block to the currently selected channel
.11fb	00		brk #		ISETLFS         BRK ; Obsolete (done in OPEN)
.11fc	00		brk #		ISETNAM         BRK ; Obsolete (done in OPEN)
.11fd	00		brk #		IOPEN           BRK ; Open a channel for reading and/or writing. Use SETLFS and SETNAM to set the channels and filename first.
.11fe	00		brk #		ICLOSE          BRK ; Close a channel
.11ff	00		brk #		ISETIN          BRK ; Set the current input channel
.1200	00		brk #		ISETOUT         BRK ; Set the current output channel
.1201	00		brk #		IGETB           BRK ; Get a byte from input channel. Return 0 if no input. Carry is set if no input.
.1202	00		brk #		IGETBLOCK       BRK ; Get a X byes from input channel. If Carry is set, wait. If Carry is clear, do not wait.
.1203	00		brk #		IGETCH          BRK ; Get a character from the input channel. A=0 and Carry=1 if no data is wating
.1204	00		brk #		IGETS           BRK ; Get a string from the input channel. NULL terminates
.1205	00		brk #		IGETLINE        BRK ; Get a line of text from input channel. CR or NULL terminates.
.1206	00		brk #		IGETFIELD       BRK ; Get a field from the input channel. Value in A, CR, or NULL terminates
.1207	00		brk #		ITRIM           BRK ; Removes spaces at beginning and end of string.
.1208	00		brk #		IPRINTC         BRK ; Print character to screen. Handles terminal commands
.1209	00		brk #		IPRINTS         BRK ; Print string to screen. Handles terminal commands
.120a	00		brk #		IPRINTF         BRK ; Print a float value
.120b	00		brk #		IPRINTI         BRK ; Prints integer value in TEMP
.120c	00		brk #		IPRINTH         BRK ; Print Hex value in DP variable
.120d	00		brk #		IPRINTAI        BRK ; Prints integer value in A
.120e	00		brk #		IPRINTAH        BRK ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
.120f	00		brk #		IPUSHKEY        BRK ;
.1210	00		brk #		IPUSHKEYS       BRK ;
.1211	00		brk #		ICSRLEFT        BRK ;
.1212	00		brk #		ICSRHOME        BRK ;
>1213	20 20 2f 2f 2f 2f 2f 20		greet_msg       .text "  ///// FOENIX 256 DEVELOPMENT SYSTEM",$0D
>121b	46 4f 45 4e 49 58 20 32 35 36 20 44 45 56 45 4c
>122b	4f 50 4d 45 4e 54 20 53 59 53 54 45 4d 0d
>1239	20 2f 2f 2f 2f 2f 20 20		greet_msg1      .text " /////  PROTOTYPE TEST CODE",$0D
>1241	50 52 4f 54 4f 54 59 50 45 20 54 45 53 54 20 43
>1251	4f 44 45 0d
>1255	2f 2f 2f 2f 2f 20 20 20		greet_msg2      .null "/////   512K SRAM 8192K DRAM"
>125d	35 31 32 4b 20 53 52 41 4d 20 38 31 39 32 4b 20
>126d	44 52 41 4d 00
>1272	52 45 41 44 59 2e 00		ready_msg       .null "READY."
>1279	45 52 52 4f 52 00		error_msg       .null "ERROR"
>127f	41 42 4f 52 54 20 45 52		error_abort     .null "ABORT ERROR"
>1287	52 4f 52 00
.ff00	5c 00 10 00	jmp $001000	                JML IBOOT
.ff10	4c 20 ff	jmp $ff20	                JMP HBRK
.ff20	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff22	8b		phb		                PHB
.ff23	0b		phd		                PHD
.ff24	48		pha		                PHA
.ff25	da		phx		                PHX
.ff26	5a		phy		                PHY
.ff27	5c 6f 10 00	jmp $00106f	                JML IBREAK
.ff60	c2 30		rep #$30	                REP #$30        ; set A&X long
.ff62	8b		phb		                PHB
.ff63	0b		phd		                PHD
.ff64	48		pha		                PHA
.ff65	da		phx		                PHX
.ff66	5a		phy		                PHY
.ff67	7a		ply		                PLY
.ff68	fa		plx		                PLX
.ff69	68		pla		                PLA
.ff6a	2b		pld		                PLD
.ff6b	ab		plb		                PLB
.ff6c	40		rti		                RTI
.ffe0					ROM_VECTORS
.ffe0	5c b2 10 00	jmp $0010b2	JUMP_READY      JML IREADY      ; FFE0
>ffe4	10 ff				KVECTOR_COP     .word $FF10     ; FFE4
>ffe6	20 ff				KVECTOR_BRK     .word $FF20     ; FFE6
>ffe8	30 ff				KVECTOR_ABORT   .word $FF30     ; FFE8
>ffea	40 ff				KVECTOR_NMI     .word $FF40     ; FFEA
>ffec	00 00				                .word $0000     ; FFEC
>ffee	50 ff				KVECTOR_IRQ     .word $FF50     ; FFEE
>fff0	00 00				                .word $0000     ; FFF0
>fff2	00 00				                .word $0000     ; FFF2
>fff4	10 ff				RVECTOR_ECOP    .word $FF10     ; FFF4
>fff6	20 ff				RVECTOR_EBRK    .word $FF20     ; FFF6
>fff8	30 ff				RVECTOR_EABORT  .word $FF30     ; FFF8
>fffa	40 ff				RVECTOR_ENMI    .word $FF40     ; FFFA
>fffc	00 ff				RVECTOR_ERESET  .word $FF00     ; FFFC
>fffe	50 ff				RVECTOR_EIRQ    .word $FF50     ; FFFE

;******  End of listing
