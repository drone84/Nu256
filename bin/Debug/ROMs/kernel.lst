
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass --long-address --intel-hex -o kernel.hex --list kernel.lst kernel.asm
; Sat Sep 01 15:16:19 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm


;******  Processing file: macros_inc.asm


;******  Return to file: kernel.asm


;******  Processing file: directpage_inc.asm

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				DIRECT_PAGE      = $000000 ;Start of bank 0 and Direct page
=$000000				RESET            = $000000 ;4 Bytes Jumps to the beginning of kernel ROM. ($F8:0000).
=$000004				RETURN           = $000004 ;4 Bytes Called when the RETURN key is pressed in the immediate mode screen. This will process a command in MONITOR, execute a BASIC command, or add a BASIC program line.
=$000008				KEYDOWN          = $000008 ;4 Bytes Custom keyboard handler. This defaults to the kernel keypress handler, but you can redirect this to your own routines. Make sure to JML to the original address at the end of your custom routine. Use this to make F-Key macros or custom keyboard commands.
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;2 Bytes Color of next character to be printed to the screen.
=$000020				CURATTR          = $000020 ;2 Bytes Attribute of next character to be printed to the screen.
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$0000e0				TEMP             = $0000E0 ;16 Bytes Temp storage for kernel routines
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000108				DIVIDER_0        = $000108 ;0 Byte  Unsigned divider
=$000108				D0_OPERAND_A     = $000108 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$00010a				D0_OPERAND_B     = $00010A ;2 Bytes Divider 0 Divisor ex B in A/B
=$00010c				D0_RESULT        = $00010C ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$00010e				D0_REMAINDER     = $00010E ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000110				DIVIDER_1        = $000110 ;0 Byte  Signed divider
=$000110				D1_OPERAND_A     = $000110 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$000112				D1_OPERAND_B     = $000112 ;2 Bytes Divider 1 Divisor ex B in A/B
=$000114				D1_RESULT        = $000114 ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D1_REMAINDER     = $000116 ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$0001f0				CPUPC            = $0001F0 ;2 Bytes Debug registers. When BRK is executed, Interrupt service routine will populate this block with the CPU registers.
=$0001f2				CPUPBR           = $0001F2 ;1 Byte  Program Bank Register (K)
=$0001f3				CPUDBR           = $0001F3 ;1 Byte  Data Bank Register (B)
=$0001f4				CPUA             = $0001F4 ;2 Bytes Accumulator (A)
=$0001f6				CPUX             = $0001F6 ;2 Bytes X Register
=$0001f8				CPUY             = $0001F8 ;2 Bytes Y Index Register
=$0001fa				CPUSTACK         = $0001FA ;2 Bytes Stack (S)
=$0001fc				CPUDP            = $0001FC ;2 Bytes Direct Page Register (D)
=$0001fe				CPUFLAGS         = $0001FE ;1 Byte  Flags (P)
=$000200				MCMDADDR         = $000200 ;3 Bytes Address of the current line of text being processed by the MONITOR command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$000203				MCMDLEN          = $000203 ;2 Bytes Length of string being read by the parser. This should be the screen width when in screen memory. Otherwise should be as long as the buffer used to hold the text to parse.
=$000205				MCMDPOS          = $000205 ;3 Bytes Next character being read by the command parser.
=$000208				MCMD             = $000208 ;3 Bytes Address of the command text. The first character is used to decide which function to execute
=$00020b				MARG1            = $00020B ;3 Bytes Address of the command arguments.
=$00020e				MARG2            = $00020E ;3 Bytes Address of the command arguments.
=$000211				MARG3            = $000211 ;3 Bytes Address of the command arguments.
=$000214				MARG4            = $000214 ;3 Bytes Address of the command arguments.
=$000217				MARG5            = $000217 ;3 Bytes Address of the command arguments.
=$00021a				MARG6            = $00021A ;3 Bytes Address of the command arguments.
=$00021d				MARG7            = $00021D ;3 Bytes Address of the command arguments.
=$000300				BCMDADDR         = $000300 ;3 Bytes Pointer to current BASIC line on screen
=$000303				BCMDLEN          = $000303 ;2 Bytes Length of the BASIC command
=$000305				BCMDPOS          = $000305 ;3 Bytes Next character being read in the BASIC command
=$00f00					KEY_BUFFER       = $00F00 ;64 Bytes SCREEN_PAGE1
=$40					KEY_BUFFER_LEN   = $40 ;64 Bytes SCREEN_PAGE2
=$000f3f				KEY_BUFFER_END   = $000F3F ;1 Byte  SCREEN_PAGE3
=$000f40				KEY_BUFFER_RPOS  = $000F40 ;2 Bytes keyboard buffer read position
=$000f42				KEY_BUFFER_WPOS  = $000F42 ;2 Bytes keyboard buffer write position
=$001000				SCREEN_PAGE0     = $001000 ;8192 Bytes First page of display RAM. This is used at boot time to display the welcome screen and the BASIC or MONITOR command screens.
=$003000				SCREEN_PAGE1     = $003000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$005000				SCREEN_PAGE2     = $005000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$007000				SCREEN_PAGE3     = $007000 ;8192 Bytes Additional page of display RAM. This can be used for page flipping or to handle multiple edit buffers.
=$009000				SCREEN_END       = $009000 ;This space is avaialble for user code and variables, up to the beginning of the stack. Do not write past STACK_BEGIN
=$009800				STACK_BEGIN      = $009800 ;16384 Bytes The default beginning of stack space
=$00d7ff				STACK_END        = $00D7FF ;0 Byte  End of stack space. Everything below this is I/O space
=$00d800				IO_BEGIN         = $00D800 ; Byte  Beginning of IO space
=$00d800				IO_GAVIN         = $00D800 ;1024 Bytes GAVIN I/O space
=$00dc00				IO_SUPERIO       = $00DC00 ;1024 Bytes SuperIO I/O space
=$00e000				IO_VICKY         = $00E000 ;1024 Bytes VICKY I/O space
=$00e400				IO_BEATRIX       = $00E400 ;1024 Bytes BEATRIX I/O space
=$00e800				IO_RTC           = $00E800 ;1024 Bytes RTC I/O space
=$00ec00				IO_CIA           = $00EC00 ;4864 Bytes CIA I/O space
=$00ff00				IO_END           = $00FF00 ;*End of I/O space
=$00ff00				ISR_BEGIN        = $00FF00 ; Byte  Beginning of CPU vectors in Direct page
=$00ff00				HRESET           = $00FF00 ;16 Bytes Handle RESET asserted. Reboot computer and re-initialize the kernel.
=$00ff10				HCOP             = $00FF10 ;16 Bytes Handle the COP instruction
=$00ff20				HBRK             = $00FF20 ;16 Bytes Handle the BRK instruction. Returns to BASIC Ready prompt.
=$00ff30				HABORT           = $00FF30 ;16 Bytes Handle ABORT asserted. Return to Ready prompt with an error message.
=$00ff40				HNMI             = $00FF40 ;80 Bytes Handle NMI asserted.
=$00ff90				HIRQ             = $00FF90 ;80 Bytes Handle IRQ. Should read IRQ line from GAVIN and jump to appropriate IRQ handler.
=$00ffe0				ISR_END          = $00FFE0 ;*End of vector space
=$00ffe0				VECTORS_BEGIN    = $00FFE0 ;0 Byte  Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$00ffe0				JMP_READY        = $00FFE0 ;4 Bytes Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$00ffe4				VECTOR_COP       = $00FFE4 ;2 Bytes Native interrupt vector
=$00ffe6				VECTOR_BRK       = $00FFE6 ;2 Bytes Native interrupt vector
=$00ffe8				VECTOR_ABORT     = $00FFE8 ;2 Bytes Native interrupt vector
=$00ffea				VECTOR_NMI       = $00FFEA ;2 Bytes Native interrupt vector
=$00ffec				VECTOR_RESET     = $00FFEC ;2 Bytes Native interrupt vector
=$00ffee				VECTOR_IRQ       = $00FFEE ;2 Bytes Native interrupt vector
=$00fff4				VECTOR_ECOP      = $00FFF4 ;2 Bytes Emulation mode interrupt handler
=$00fff6				VECTOR_EBRK      = $00FFF6 ;2 Bytes Emulation mode interrupt handler
=$00fff8				VECTOR_EABORT    = $00FFF8 ;2 Bytes Emulation mode interrupt handler
=$00fffa				VECTOR_ENMI      = $00FFFA ;2 Bytes Emulation mode interrupt handler
=$00fffc				VECTOR_ERESET    = $00FFFC ;2 Bytes Emulation mode interrupt handler
=$00fffe				VECTOR_EIRQ      = $00FFFE ;2 Bytes Emulation mode interrupt handler
=$010000				VECTORS_END      = $010000 ;*End of vector space

;******  Return to file: kernel.asm


;******  Processing file: monitor_inc.asm

=$f10000				MONITOR     = $F10000
=$f10004				MBREAK      = $F10004
=$f10008				MSTATUS     = $F10008
=$f1000b				MREADY      = $F1000B
=$f10010				MRETURN	    = $F10010
=$f10014				MPARSE      = $F10014

;******  Return to file: kernel.asm


;******  Processing file: kernel_vectors.asm

.ffff00	5c 00 00 f8	jmp $f80000	                JML BOOT
.ffff10	5c 20 ff 00	jmp $00ff20	                JMP HBRK
.ffff20					RHBRK
.ffff20	c2 30		rep #$30	                REP #$30        ; set A&X long
.ffff22	8b		phb		                PHB
.ffff23	0b		phd		                PHD
.ffff24	48		pha		                PHA
.ffff25	da		phx		                PHX
.ffff26	5a		phy		                PHY
.ffff27	5c 08 00 f8	jmp $f80008	                JML BREAK
.ffff50					RHIRQ
.ffff50	c2 30		rep #$30	                REP #$30        ; set A&X long
.ffff52	8b		phb		                PHB
.ffff53	0b		phd		                PHD
.ffff54	48		pha		                PHA
.ffff55	da		phx		                PHX
.ffff56	5a		phy		                PHY
.ffff57	7a		ply		                PLY
.ffff58	fa		plx		                PLX
.ffff59	68		pla		                PLA
.ffff5a	2b		pld		                PLD
.ffff5b	ab		plb		                PLB
.ffff5c	40		rti		                RTI
.ffffe0					ROM_VECTORS
.ffffe0	5c 0c 00 f8	jmp $f8000c	JUMP_READY      JML READY
>ffffe4	10 ff				RVECTOR_COP     .word $FF10     ; FFE4
>ffffe6	20 ff				RVECTOR_BRK     .word $FF20     ; FFE6
>ffffe8	30 ff				RVECTOR_ABORT   .word $FF30     ; FFE8
>ffffea	40 ff				RVECTOR_NMI     .word $FF40     ; FFEA
>ffffec	00 00				                .word $0000     ; FFEC
>ffffee	50 ff				RVECTOR_IRQ     .word $FF50     ; FFEE
>fffff0	00 00				                .word $0000     ; FFF0
>fffff2	00 00				                .word $0000     ; FFF2
>fffff4	10 ff				RVECTOR_ECOP    .word $FF10     ; FFF4
>fffff6	20 ff				RVECTOR_EBRK    .word $FF20     ; FFF6
>fffff8	30 ff				RVECTOR_EABORT  .word $FF30     ; FFF8
>fffffa	40 ff				RVECTOR_ENMI    .word $FF40     ; FFFA
>fffffc	00 ff				RVECTOR_ERESET  .word $FF00     ; FFFC
>fffffe	50 ff				RVECTOR_EIRQ    .word $FF50     ; FFFE

;******  Return to file: kernel.asm


;******  Processing file: simulator_inc.asm


;******  Return to file: kernel.asm

.f80000	5c 03 10 f8	jmp $f81003	BOOT            JML IBOOT
.f80004	5c e0 11 f8	jmp $f811e0	RESTORE         JML IRESTORE
.f80008	5c 81 10 f8	jmp $f81081	BREAK           JML IBREAK
.f8000c	5c c4 10 f8	jmp $f810c4	READY           JML IREADY
.f80010	5c e1 11 f8	jmp $f811e1	SCINIT          JML ISCINIT
.f80014	5c e2 11 f8	jmp $f811e2	IOINIT          JML IIOINIT
.f80018	5c 40 11 f8	jmp $f81140	PUTC            JML IPUTC
.f8001c	5c 29 11 f8	jmp $f81129	PUTS            JML IPUTS
.f80020	5c 6d 11 f8	jmp $f8116d	PUTB            JML IPUTB
.f80024	5c e3 11 f8	jmp $f811e3	PUTBLOCK        JML IPUTBLOCK
.f80028	5c e4 11 f8	jmp $f811e4	SETLFS          JML ISETLFS
.f8002c	5c e5 11 f8	jmp $f811e5	SETNAM          JML ISETNAM
.f80030	5c e6 11 f8	jmp $f811e6	OPEN            JML IOPEN
.f80034	5c e7 11 f8	jmp $f811e7	CLOSE           JML ICLOSE
.f80038	5c e8 11 f8	jmp $f811e8	SETIN           JML ISETIN
.f8003c	5c e9 11 f8	jmp $f811e9	SETOUT          JML ISETOUT
.f80040	5c ea 11 f8	jmp $f811ea	GETB            JML IGETB
.f80044	5c eb 11 f8	jmp $f811eb	GETBLOCK        JML IGETBLOCK
.f80048	5c ec 11 f8	jmp $f811ec	GETCH           JML IGETCH
.f8004c	5c ef 10 f8	jmp $f810ef	GETCHW          JML IGETCHW
.f80050	5c e6 10 f8	jmp $f810e6	GETCHE          JML IGETCHE
.f80054	5c ed 11 f8	jmp $f811ed	GETS            JML IGETS
.f80058	5c ee 11 f8	jmp $f811ee	GETLINE         JML IGETLINE
.f8005c	5c ef 11 f8	jmp $f811ef	GETFIELD        JML IGETFIELD
.f80060	5c f0 11 f8	jmp $f811f0	TRIM            JML ITRIM
.f80064	5c f1 11 f8	jmp $f811f1	PRINTC          JML IPRINTC
.f80068	5c f2 11 f8	jmp $f811f2	PRINTS          JML IPRINTS
.f8006c	5c 6e 11 f8	jmp $f8116e	PRINTCR         JML IPRINTCR
.f80070	5c f3 11 f8	jmp $f811f3	PRINTF          JML IPRINTF
.f80074	5c f4 11 f8	jmp $f811f4	PRINTI          JML IPRINTI
.f80078	5c f5 11 f8	jmp $f811f5	PRINTH          JML IPRINTH
.f8007c	5c f6 11 f8	jmp $f811f6	PRINTAI         JML IPRINTAI
.f80080	5c f7 11 f8	jmp $f811f7	PRINTAH         JML IPRINTAH
.f80084	5c bc 11 f8	jmp $f811bc	LOCATE          JML ILOCATE
.f80088	5c f8 11 f8	jmp $f811f8	PUSHKEY         JML IPUSHKEY
.f8008c	5c f9 11 f8	jmp $f811f9	PUSHKEYS        JML IPUSHKEYS
.f80090	5c 8f 11 f8	jmp $f8118f	CSRRIGHT        JML ICSRRIGHT
.f80094	5c fa 11 f8	jmp $f811fa	CSRLEFT         JML ICSRLEFT
.f80098	5c ba 11 f8	jmp $f811ba	CSRUP           JML ICSRUP
.f8009c	5c bb 11 f8	jmp $f811bb	CSRDOWN         JML ICSRDOWN
.f800a0	5c fb 11 f8	jmp $f811fb	CSRHOME         JML ICSRHOME
.f81000	4c 03 10	jmp $f81003	IRESET          JMP IBOOT
.f81003					IBOOT
.f81003	18		clc		                CLC           ; clear the carry flag
.f81004	fb		xce		                XCE           ; move carry to emulation flag.
.f81005	c2 30		rep #$30	                REP #$30        ; set long A and X
.f81007	a9 ff d7	lda #$d7ff	                LDA #STACK_END   ; initialize stack pointer
.f8100a	1b		tcs		                TAS
.f8100b	48		pha		                PHA             ; begin setdp macro
.f8100c	08		php			PHP
.f8100d	c2 20		rep #$20	                REP #$20        ; set A long
.f8100f	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.f81012	5b		tcd		                TCD
.f81013	28		plp			PLP
.f81014	68		pla		                PLA             ; end setdp macro
.f81015	a9 00 10	lda #$1000	                LDA #$1000      ; store the initial screen buffer location
.f81018	85 0c		sta $0c		                STA SCREENBEGIN
.f8101a	e2 20		sep #$20	                SEP #$20        ; set A short
.f8101c	a9 00		lda #$00	                LDA #$00
.f8101e	85 0e		sta $0e		                STA SCREENBEGIN+2
.f81020	c2 20		rep #$20	                REP #$20        ; set A long
.f81022	a9 00 10	lda #$1000	                LDA #$1000      ; store the initial cursor position
.f81025	85 17		sta $17		                STA CURSORPOS
.f81027	e2 20		sep #$20	                SEP #$20        ; set A short
.f81029	a9 00		lda #$00	                LDA #$00
.f8102b	85 19		sta $19		                STA CURSORPOS+2
.f8102d	a2 00 00	ldx #$0000	                LDX #$0
.f81030	a0 00 00	ldy #$0000	                LDY #$0
.f81033	22 bc 11 f8	jsl $f811bc	                JSL ILOCATE
.f81037	e2 20		sep #$20	                SEP #$20        ; set A short
.f81039	a2 50 00	ldx #$0050	                LDX #80
.f8103c	86 0f		stx $0f		                STX COLS_VISIBLE
.f8103e	a0 1e 00	ldy #$001e	                LDY #30
.f81041	84 13		sty $13		                STY LINES_VISIBLE
.f81043	a2 80 00	ldx #$0080	                LDX #128
.f81046	86 11		stx $11		                STX COLS_PER_LINE
.f81048	a0 40 00	ldy #$0040	                LDY #64
.f8104b	84 15		sty $15		                STY LINES_MAX
.f8104d	c2 20		rep #$20	                REP #$20        ; set A long
.f8104f	9c 40 0f	stz $0f40	                STZ KEY_BUFFER_RPOS
.f81052	9c 42 0f	stz $0f42	                STZ KEY_BUFFER_WPOS
.f81055	c2 30		rep #$30	                REP #$30        ; set A&X long
.f81057	a9 ff 00	lda #$00ff	                LDA #$FF
.f8105a	a2 00 ff	ldx #$ff00	                LDX #$FF00
.f8105d	a0 00 ff	ldy #$ff00	                LDY #$FF00
.f81060	44 ff 00	mvp $00,$ff	                MVP $00, $FF
.f81063					greet
.f81063	48		pha		                PHA             ; begin setdbr macro
.f81064	08		php		                PHP
.f81065	e2 20		sep #$20	                SEP #$20        ; set A short
.f81067	a9 f8		lda #$f8		LDA #`greet_msg
.f81069	48		pha		                PHA
.f8106a	ab		plb		                PLB
.f8106b	28		plp		                PLP
.f8106c	68		pla		                PLA             ; end setdbr macro
.f8106d	a2 00 f0	ldx #$f000	                LDX #<>greet_msg
.f81070	22 20 11 f8	jsl $f81120	                JSL IPRINT       ; print the first line
.f81074	e2 20		sep #$20	                SEP #$20        ; set A short
.f81076	48		pha		                PHA             ; begin setdbr macro
.f81077	08		php		                PHP
.f81078	e2 20		sep #$20	                SEP #$20        ; set A short
.f8107a	a9 01		lda #$01		LDA #$01
.f8107c	48		pha		                PHA
.f8107d	ab		plb		                PLB
.f8107e	28		plp		                PLP
.f8107f	68		pla		                PLA             ; end setdbr macro
.f81080	00		brk #		greet_done      BRK             ;Terminate boot routine and go to Ready handler.
.f81081					IBREAK
.f81081	48		pha		                PHA             ; begin setdp macro
.f81082	08		php			PHP
.f81083	c2 20		rep #$20	                REP #$20        ; set A long
.f81085	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.f81088	5b		tcd		                TCD
.f81089	28		plp			PLP
.f8108a	68		pla		                PLA             ; end setdp macro
.f8108b	68		pla		                PLA             ; Pull .Y and stuff it in the CPUY variable
.f8108c	8f f8 01 00	sta $0001f8	                STA CPUY
.f81090	68		pla		                PLA             ; Pull .X and stuff it in the CPUY variable
.f81091	8f f6 01 00	sta $0001f6	                STA CPUX
.f81095	68		pla		                PLA             ; Pull .A and stuff it in the CPUY variable
.f81096	8f f4 01 00	sta $0001f4	                STA CPUA
.f8109a	68		pla		                PLA
.f8109b	8f fc 01 00	sta $0001fc	                STA CPUDP       ; Pull Direct page
.f8109f	e2 20		sep #$20	                SEP #$20        ; set A short
.f810a1	68		pla		                PLA             ; Pull Data Bank (8 bits)
.f810a2	8f f3 01 00	sta $0001f3	                STA CPUDBR
.f810a6	68		pla		                PLA             ; Pull Flags (8 bits)
.f810a7	8f fe 01 00	sta $0001fe	                STA CPUFLAGS
.f810ab	c2 20		rep #$20	                REP #$20        ; set A long
.f810ad	68		pla		                PLA             ; Pull Program Counter (16 bits)
.f810ae	8f f0 01 00	sta $0001f0	                STA CPUPC
.f810b2	e2 20		sep #$20	                SEP #$20        ; set A short
.f810b4	68		pla		                PLA             ; Pull Program Bank (8 bits)
.f810b5	8f f2 01 00	sta $0001f2	                STA CPUPBR
.f810b9	c2 20		rep #$20	                REP #$20        ; set A long
.f810bb	3b		tsc		                TSA             ; Get the stack
.f810bc	8f fa 01 00	sta $0001fa	                STA CPUSTACK    ; Store the stack at immediately before the interrupt was asserted
.f810c0	a9 ff d7	lda #$d7ff	                LDA #<>STACK_END   ; initialize stack pointer back to the bootup value
.f810c3	1b		tcs		                TAS
.f810c4					IREADY
.f810c4	48		pha		                PHA             ; begin setdbr macro
.f810c5	08		php		                PHP
.f810c6	e2 20		sep #$20	                SEP #$20        ; set A short
.f810c8	a9 f8		lda #$f8		LDA #`ready_msg
.f810ca	48		pha		                PHA
.f810cb	ab		plb		                PLB
.f810cc	28		plp		                PLP
.f810cd	68		pla		                PLA             ; end setdbr macro
.f810ce	e2 20		sep #$20	                SEP #$20        ; set A short
.f810d0	a2 65 f0	ldx #$f065	                LDX #<>ready_msg
.f810d3	22 20 11 f8	jsl $f81120	                JSL IPRINT
.f810d7					IREADYWAIT
.f810d7	22 e6 10 f8	jsl $f810e6	                JSL IGETCHE
.f810db	b0 fa		bcs $f810d7	                BCS IREADYWAIT
.f810dd	22 40 11 f8	jsl $f81140	                JSL IPUTC
.f810e1	4c d7 10	jmp $f810d7	                JMP IREADYWAIT
.f810e4	db		stp		IKEYDOWN        STP             ; Keyboard key pressed
.f810e5	db		stp		IRETURN         STP
.f810e6	22 ef 10 f8	jsl $f810ef	IGETCHE         JSL IGETCHW
.f810ea	22 40 11 f8	jsl $f81140	                JSL IPUTC
.f810ee	6b		rtl		                RTL
.f810ef	0b		phd		IGETCHW         PHD
.f810f0	da		phx		                PHX
.f810f1	08		php		                PHP
.f810f2	48		pha		                PHA             ; begin setdp macro
.f810f3	08		php			PHP
.f810f4	c2 20		rep #$20	                REP #$20        ; set A long
.f810f6	a9 00 0f	lda #$0f00	                LDA #$0F00         ; set DP to page 0
.f810f9	5b		tcd		                TCD
.f810fa	28		plp			PLP
.f810fb	68		pla		                PLA             ; end setdp macro
.f810fc	c2 30		rep #$30	                REP #$30        ; set A&X long
.f810fe	a6 40		ldx $0f40	igetchw1        LDX KEY_BUFFER_RPOS
.f81100	e4 42		cpx $0f42	                CPX KEY_BUFFER_WPOS
.f81102	d0 05		bne $f81109	                BNE igetchw2
>f81104	42 00				                .byte $42, $00
.f81106	4c fe 10	jmp $f810fe	                JMP igetchw1
.f81109	b5 00		lda $0f00,x	igetchw2        LDA $0,D,X  ; Read the value in the keyboard buffer
.f8110b	48		pha		                PHA
.f8110c	8a		txa		                TXA
.f8110d	18		clc		                CLC
.f8110e	69 02 00	adc #$0002	                ADC #$02
.f81111	c9 40 00	cmp #$0040	                CMP #KEY_BUFFER_LEN
.f81114	90 03		bcc $f81119	                BCC igetchw3
.f81116	a9 00 00	lda #$0000	                LDA #$0
.f81119	85 40		sta $0f40	igetchw3        STA KEY_BUFFER_RPOS
.f8111b	68		pla		                PLA
.f8111c	28		plp		igetchw_done    PLP
.f8111d	fa		plx		                PLX             ; Restore the saved registers and return
.f8111e	2b		pld		                PLD
.f8111f	6b		rtl		                RTL
.f81120	22 29 11 f8	jsl $f81129	IPRINT          JSL IPUTS
.f81124	22 6e 11 f8	jsl $f8116e	                JSL IPRINTCR
.f81128	6b		rtl		                RTL
.f81129	48		pha		IPUTS           PHA
.f8112a	08		php		                PHP
.f8112b	e2 20		sep #$20	                SEP #$20        ; set A short
.f8112d	c2 10		rep #$10	                REP #$10        ; set X long
.f8112f	bd 00 00	lda $f80000,x	iputs1          LDA $0,b,x      ; read from the string
.f81132	f0 08		beq $f8113c	                BEQ iputs_done
.f81134	22 40 11 f8	jsl $f81140	iputs2          JSL IPUTC
.f81138	e8		inx		iputs3          INX
.f81139	4c 2f 11	jmp $f8112f	                JMP iputs1
.f8113c	e8		inx		iputs_done      INX
.f8113d	28		plp		                PLP
.f8113e	68		pla		                PLA
.f8113f	6b		rtl		                RTL
.f81140	0b		phd		IPUTC           PHD
.f81141	08		php		                PHP             ; stash the flags (we'll be changing M)
.f81142	48		pha		                PHA             ; begin setdp macro
.f81143	08		php			PHP
.f81144	c2 20		rep #$20	                REP #$20        ; set A long
.f81146	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.f81149	5b		tcd		                TCD
.f8114a	28		plp			PLP
.f8114b	68		pla		                PLA             ; end setdp macro
.f8114c	e2 20		sep #$20	                SEP #$20        ; set A short
.f8114e	c9 0d		cmp #$0d	                CMP #$0D        ; handle CR
.f81150	d0 06		bne $f81158	                BNE iputc_bs
.f81152	22 6e 11 f8	jsl $f8116e	                JSL IPRINTCR
.f81156	80 10		bra $f81168	                bra iputc_done
.f81158	c9 08		cmp #$08	iputc_bs        CMP #$08        ; backspace
.f8115a	d0 06		bne $f81162	                BNE iputc_print
.f8115c	22 7f 11 f8	jsl $f8117f	                JSL IPRINTBS
.f81160	80 06		bra $f81168	                BRA iputc_done
.f81162	87 17		sta [$17]	iputc_print     STA [CURSORPOS] ; Save the character on the screen
.f81164	22 8f 11 f8	jsl $f8118f	                JSL ICSRRIGHT
.f81168					iputc_done
>f81168	42 01				                .byte $42, $01
.f8116a	28		plp		                PLP
.f8116b	2b		pld		                PLD
.f8116c	6b		rtl		                RTL
.f8116d					IPUTB
.f8116d	6b		rtl		                RTL
.f8116e	da		phx		IPRINTCR	PHX
.f8116f	5a		phy		                PHY
.f81170	08		php		                PHP
.f81171	a2 00 00	ldx #$0000	                LDX #0
.f81174	a4 1c		ldy $1c		                LDY CURSORY
.f81176	c8		iny		                INY
.f81177	22 bc 11 f8	jsl $f811bc	                JSL ILOCATE
.f8117b	28		plp		                PLP
.f8117c	7a		ply		                PLY
.f8117d	fa		plx		                PLX
.f8117e	6b		rtl		                RTL
.f8117f	da		phx		IPRINTBS	PHX
.f81180	5a		phy		                PHY
.f81181	08		php		                PHP
.f81182	a6 1a		ldx $1a		                LDX CURSORX
.f81184	a4 1c		ldy $1c		                LDY CURSORY
.f81186	ca		dex		                DEX
.f81187	22 bc 11 f8	jsl $f811bc	                JSL ILOCATE
.f8118b	28		plp		                PLP
.f8118c	7a		ply		                PLY
.f8118d	fa		plx		                PLX
.f8118e	6b		rtl		                RTL
.f8118f					ICSRRIGHT
.f8118f	da		phx		                PHX
.f81190	8b		phb		                PHB
.f81191	c2 20		rep #$20	                REP #$20        ; set A long
.f81193	c2 10		rep #$10	                REP #$10        ; set X long
.f81195	48		pha		                PHA             ; begin setdp macro
.f81196	08		php			PHP
.f81197	c2 20		rep #$20	                REP #$20        ; set A long
.f81199	a9 00 00	lda #$0000	                LDA #$0         ; set DP to page 0
.f8119c	5b		tcd		                TCD
.f8119d	28		plp			PLP
.f8119e	68		pla		                PLA             ; end setdp macro
.f8119f	e6 17		inc $17		                INC CURSORPOS
.f811a1	a6 1a		ldx $1a		                LDX CURSORX
.f811a3	e8		inx		                INX
.f811a4	e4 0f		cpx $0f		                CPX COLS_VISIBLE
.f811a6	90 0c		bcc $f811b4	                BCC icsr_nowrap  ; wrap if the cursor is at or past column 80
.f811a8	a2 00 00	ldx #$0000	                LDX #0
.f811ab	5a		phy		                PHY
.f811ac	a4 1c		ldy $1c		                LDY CURSORY
.f811ae	c8		iny		                INY
.f811af	22 bc 11 f8	jsl $f811bc	                JSL ILOCATE
.f811b3	7a		ply		                PLY
.f811b4	86 1a		stx $1a		icsr_nowrap     STX CURSORX
.f811b6	ab		plb		                PLB
.f811b7	fa		plx		                PLX
.f811b8	6b		rtl		                RTL
.f811b9	6b		rtl		ISRLEFT	RTL
.f811ba	6b		rtl		ICSRUP	RTL
.f811bb	6b		rtl		ICSRDOWN	RTL
.f811bc	48		pha		ILOCATE         PHA
.f811bd	08		php		                PHP
.f811be	c2 20		rep #$20	                REP #$20        ; set A long
.f811c0	c2 10		rep #$10	                REP #$10        ; set X long
.f811c2	86 1a		stx $1a		                STX CURSORX
.f811c4	84 1c		sty $1c		                STY CURSORY
.f811c6	c0 00 00	cpy #$0000	                CPY #$0
.f811c9	f0 0b		beq $f811d6	                BEQ ilocate_right
.f811cb	a5 0c		lda $0c		                LDA SCREENBEGIN
.f811cd	18		clc		ilocate_down    CLC
.f811ce	65 11		adc $11		                ADC COLS_PER_LINE
.f811d0	88		dey		                DEY
.f811d1	f0 03		beq $f811d6		BEQ ilocate_right
.f811d3	4c cd 11	jmp $f811cd	                JMP ilocate_down
.f811d6	18		clc		ilocate_right   CLC
.f811d7	65 1a		adc $1a		                ADC CURSORX             ; move the cursor right X columns
.f811d9	85 17		sta $17		                STA CURSORPOS
.f811db	a4 1c		ldy $1c			LDY CURSORY
.f811dd	28		plp		ilocate_done    PLP
.f811de	68		pla		                PLA
.f811df	6b		rtl		                RTL
.f811e0	00		brk #		IRESTORE        BRK ; Warm boot routine
.f811e1	00		brk #		ISCINIT         BRK ;
.f811e2	00		brk #		IIOINIT         BRK ;
.f811e3	00		brk #		IPUTBLOCK       BRK ; Ouput a binary block to the currently selected channel
.f811e4	00		brk #		ISETLFS         BRK ; Obsolete (done in OPEN)
.f811e5	00		brk #		ISETNAM         BRK ; Obsolete (done in OPEN)
.f811e6	00		brk #		IOPEN           BRK ; Open a channel for reading and/or writing. Use SETLFS and SETNAM to set the channels and filename first.
.f811e7	00		brk #		ICLOSE          BRK ; Close a channel
.f811e8	00		brk #		ISETIN          BRK ; Set the current input channel
.f811e9	00		brk #		ISETOUT         BRK ; Set the current output channel
.f811ea	00		brk #		IGETB           BRK ; Get a byte from input channel. Return 0 if no input. Carry is set if no input.
.f811eb	00		brk #		IGETBLOCK       BRK ; Get a X byes from input channel. If Carry is set, wait. If Carry is clear, do not wait.
.f811ec	00		brk #		IGETCH          BRK ; Get a character from the input channel. A=0 and Carry=1 if no data is wating
.f811ed	00		brk #		IGETS           BRK ; Get a string from the input channel. NULL terminates
.f811ee	00		brk #		IGETLINE        BRK ; Get a line of text from input channel. CR or NULL terminates.
.f811ef	00		brk #		IGETFIELD       BRK ; Get a field from the input channel. Value in A, CR, or NULL terminates
.f811f0	00		brk #		ITRIM           BRK ; Removes spaces at beginning and end of string.
.f811f1	00		brk #		IPRINTC         BRK ; Print character to screen. Handles terminal commands
.f811f2	00		brk #		IPRINTS         BRK ; Print string to screen. Handles terminal commands
.f811f3	00		brk #		IPRINTF         BRK ; Print a float value
.f811f4	00		brk #		IPRINTI         BRK ; Prints integer value in TEMP
.f811f5	00		brk #		IPRINTH         BRK ; Print Hex value in DP variable
.f811f6	00		brk #		IPRINTAI        BRK ; Prints integer value in A
.f811f7	00		brk #		IPRINTAH        BRK ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
.f811f8	00		brk #		IPUSHKEY        BRK ;
.f811f9	00		brk #		IPUSHKEYS       BRK ;
.f811fa	00		brk #		ICSRLEFT        BRK ;
.f811fb	00		brk #		ICSRHOME        BRK ;
>f8f000	20 20 2f 2f 2f 2f 2f 20		greet_msg       .text "  ///// FOENIX 256 DEVELOPMENT SYSTEM",$0D
>f8f008	46 4f 45 4e 49 58 20 32 35 36 20 44 45 56 45 4c
>f8f018	4f 50 4d 45 4e 54 20 53 59 53 54 45 4d 0d
>f8f026	20 2f 2f 2f 2f 2f 20 20		greet_msg1      .text " /////  OPEN SOURCE COMPUTER",$0D
>f8f02e	4f 50 45 4e 20 53 4f 55 52 43 45 20 43 4f 4d 50
>f8f03e	55 54 45 52 0d
>f8f043	2f 2f 2f 2f 2f 20 20 20		greet_msg2      .text "/////   8192KB SYSTEM 8128KB FREE",$00
>f8f04b	38 31 39 32 4b 42 20 53 59 53 54 45 4d 20 38 31
>f8f05b	32 38 4b 42 20 46 52 45 45 00
>f8f065	0d 52 45 41 44 59 2e 00		ready_msg       .text $0D,"READY.",$00
>f8f06d	3b 46 38 31 30 30 30 20		                .text ";F81000 0000 0000 0000 D6FF F8  0000 ------Z-",$00
>f8f075	30 30 30 30 20 30 30 30 30 20 30 30 30 30 20 44
>f8f085	36 46 46 20 46 38 20 20 30 30 30 30 20 2d 2d 2d
>f8f095	2d 2d 2d 5a 2d 00
>f8f09b	31 30 20 50 52 49 4e 54		hello_basic     .text "10 PRINT ""Hello World""",$0D
>f8f0a3	20 22 48 65 6c 6c 6f 20 57 6f 72 6c 64 22 0d
>f8f0b2	52 55 4e 0d			                .text "RUN",$0D
>f8f0b6	48 65 6c 6c 6f 20 57 6f		                .text "Hello World",$0D
>f8f0be	72 6c 64 0d
>f8f0c2	0d 52 45 41 44 59 2e 00		                .text $0D,"READY.",$00
>f8f0ca	47 20 30 32 30 30 30 30		hello_ml        .text "G 020000",$0D
>f8f0d2	0d
>f8f0d3	48 45 4c 4c 4f 20 57 4f		                .text "HELLO WORLD",$0D
>f8f0db	52 4c 44 0d
>f8f0df	0d				                .text $0D
>f8f0e0	20 50 43 20 20 20 20 20		                .text " PC     A    X    Y    SP   DBR DP   NVMXDIZC",$0D
>f8f0e8	41 20 20 20 20 58 20 20 20 20 59 20 20 20 20 53
>f8f0f8	50 20 20 20 44 42 52 20 44 50 20 20 20 4e 56 4d
>f8f108	58 44 49 5a 43 0d
>f8f10e	3b 30 30 32 31 31 32 20		                .text ";002112 0019 F0AA 0000 D6FF F8  0000 --M-----",$00
>f8f116	30 30 31 39 20 46 30 41 41 20 30 30 30 30 20 44
>f8f126	36 46 46 20 46 38 20 20 30 30 30 30 20 2d 2d 4d
>f8f136	2d 2d 2d 2d 2d 00
>f8f13c	41 42 4f 52 54 20 45 52		error_01        .text "ABORT ERROR",$00
>f8f144	52 4f 52 00

;******  End of listing
